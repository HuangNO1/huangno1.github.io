[{"categories":["Android"],"content":"前言 上一篇我們已經介紹完 RecyclerView 加載更多的實現，而這篇也是最後一篇，關於點擊新聞卡片進入新聞詳情頁(Activity)。 ","date":"2021-06-15","objectID":"/android_click_card_item_move_to_detail_page/:1:0","tags":["Android","Java","Android Studio","RecyclerView","Card","List","Adapter","WebView","Detail","Click","Activity"],"title":"Android Java - 簡易今日頭條 - 點擊新聞卡片進入新聞詳情頁與 WebView 顯示","uri":"/android_click_card_item_move_to_detail_page/"},{"categories":["Android"],"content":"Display 點擊卡片 Item 進入詳情頁展示Display_click_to_detail_page.gif \" 點擊卡片 Item 進入詳情頁展示 ","date":"2021-06-15","objectID":"/android_click_card_item_move_to_detail_page/:2:0","tags":["Android","Java","Android Studio","RecyclerView","Card","List","Adapter","WebView","Detail","Click","Activity"],"title":"Android Java - 簡易今日頭條 - 點擊新聞卡片進入新聞詳情頁與 WebView 顯示","uri":"/android_click_card_item_move_to_detail_page/"},{"categories":["Android"],"content":"項目倉庫 簡易今日頭條 - Github ","date":"2021-06-15","objectID":"/android_click_card_item_move_to_detail_page/:3:0","tags":["Android","Java","Android Studio","RecyclerView","Card","List","Adapter","WebView","Detail","Click","Activity"],"title":"Android Java - 簡易今日頭條 - 點擊新聞卡片進入新聞詳情頁與 WebView 顯示","uri":"/android_click_card_item_move_to_detail_page/"},{"categories":["Android"],"content":"具體實現 這裡我是在新聞卡片的適配器裡面去做，將 View 設置點擊事件，然後新增一個新聞活動頁面。 ","date":"2021-06-15","objectID":"/android_click_card_item_move_to_detail_page/:4:0","tags":["Android","Java","Android Studio","RecyclerView","Card","List","Adapter","WebView","Detail","Click","Activity"],"title":"Android Java - 簡易今日頭條 - 點擊新聞卡片進入新聞詳情頁與 WebView 顯示","uri":"/android_click_card_item_move_to_detail_page/"},{"categories":["Android"],"content":"ui/card/newsCardList/NewsCardAdapter.java 下面的 Code 中我舉出 NoImageCardViewHolder 子類，裡面的構造函數中去做 itemView 的點擊事件，點擊事件涉及到了傳參部份，傳參使用 intent.putExtra() 方法，然後在 NewsDetailActivity 做接收參數。 public class NewsCardAdapter extends RecyclerView.Adapter\u003cRecyclerView.ViewHolder\u003e { private final List\u003cNewsCardItemDataModel\u003e mDataModelList; private final Context mContext; // ... /** * Click the card item and move to NewsDetailActivity * * @param itemView */ public void onClickListener(@NonNull View itemView) { itemView.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { Activity activity = (Activity) mContext; TextView mSourceUrl = itemView.findViewById(R.id.text_view_source_url); Intent intent = new Intent(activity, NewsDetailActivity.class); intent.putExtra(\"source_url\", mSourceUrl.getText().toString()); mContext.startActivity(intent); activity.overridePendingTransition(R.animator.slide_in_right, R.animator.slide_out_left); } }); } // No image style card view holder class NoImageCardViewHolder extends RecyclerView.ViewHolder { private final ImageView mAvatarView; private final TextView mTitleTextView; private final TextView mSubTitleTextView; private final TextView mBottomTextView; private final TextView mSourceUrlTextView; public NoImageCardViewHolder(@NonNull View itemView) { super(itemView); mAvatarView = itemView.findViewById(R.id.image_view_card_avatar); mTitleTextView = itemView.findViewById(R.id.text_view_card_title); mSubTitleTextView = itemView.findViewById(R.id.text_view_card_subtitle); mBottomTextView = itemView.findViewById(R.id.text_view_card_bottom_text); mSourceUrlTextView = itemView.findViewById(R.id.text_view_source_url); // set onClick onClickListener(itemView); } public void bindData(NewsCardItemDataModel dataModel, Context context) { // ... } } } ","date":"2021-06-15","objectID":"/android_click_card_item_move_to_detail_page/:4:1","tags":["Android","Java","Android Studio","RecyclerView","Card","List","Adapter","WebView","Detail","Click","Activity"],"title":"Android Java - 簡易今日頭條 - 點擊新聞卡片進入新聞詳情頁與 WebView 顯示","uri":"/android_click_card_item_move_to_detail_page/"},{"categories":["Android"],"content":"layout/activity_news_detail.xml 這個是 NewsDetailActivity 的 xml Layout 文件。 \u003c?xml version=\"1.0\" encoding=\"utf-8\"?\u003e \u003candroidx.coordinatorlayout.widget.CoordinatorLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:app=\"http://schemas.android.com/apk/res-auto\" xmlns:tools=\"http://schemas.android.com/tools\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" tools:context=\".activity.NewsDetailActivity\"\u003e \u003ccom.google.android.material.appbar.AppBarLayout android:id=\"@+id/app_bar\" android:layout_height=\"40dp\" android:layout_width=\"match_parent\" android:background=\"@color/tabbed_bg\"\u003e \u003ccom.google.android.material.appbar.CollapsingToolbarLayout android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" app:toolbarId=\"@+id/toolbar\" app:layout_scrollFlags=\"scroll|exitUntilCollapsed\"\u003e \u003candroidx.appcompat.widget.Toolbar android:id=\"@+id/tool_bar\" android:layout_height=\"40dp\" android:layout_width=\"match_parent\"\u003e \u003candroidx.appcompat.widget.LinearLayoutCompat android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\"\u003e \u003cButton android:id=\"@+id/button_back\" android:layout_width=\"25dp\" android:layout_height=\"25dp\" android:layout_margin=\"1dp\" android:backgroundTint=\"@color/white\" app:layout_constraintStart_toStartOf=\"parent\" app:layout_constraintBottom_toBottomOf=\"parent\" android:background=\"@drawable/ic_baseline_arrow_back_ios_24\"/\u003e \u003c/androidx.appcompat.widget.LinearLayoutCompat\u003e \u003c/androidx.appcompat.widget.Toolbar\u003e \u003c/com.google.android.material.appbar.CollapsingToolbarLayout\u003e \u003c/com.google.android.material.appbar.AppBarLayout\u003e \u003ccom.airbnb.lottie.LottieAnimationView android:id=\"@+id/animation_view_loading\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:scaleX=\"0.7\" android:scaleY=\"0.7\" app:layout_constraintStart_toStartOf=\"parent\" app:layout_constraintTop_toTopOf=\"parent\" app:lottie_autoPlay=\"true\" app:lottie_loop=\"true\" /\u003e \u003candroidx.core.widget.NestedScrollView android:id=\"@+id/nested_scroll_view_web\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" app:layout_behavior=\"com.google.android.material.appbar.AppBarLayout$ScrollingViewBehavior\"\u003e \u003cFrameLayout android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" tools:context=\".ui.page.news_detail.NewsDetailFragment\"\u003e \u003cWebView android:id=\"@+id/web_view\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" app:layout_constraintLeft_toLeftOf=\"parent\" app:layout_constraintRight_toRightOf=\"parent\" /\u003e \u003cProgressBar android:id=\"@+id/progress_bar_loading\" style=\"@style/Widget.AppCompat.ProgressBar.Horizontal\" android:layout_width=\"match_parent\" android:layout_height=\"2dp\" app:layout_constraintTop_toTopOf=\"parent\"/\u003e \u003c/FrameLayout\u003e \u003c/androidx.core.widget.NestedScrollView\u003e \u003ccom.google.android.material.floatingactionbutton.FloatingActionButton android:id=\"@+id/fab_scroll_to_top\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:layout_gravity=\"bottom|end\" android:layout_marginEnd=\"10dp\" android:layout_marginBottom=\"30dp\" android:backgroundTint=\"@color/red_200\" android:clickable=\"true\" android:contentDescription=\"@string/scrolltotop\" android:focusable=\"true\" android:isScrollContainer=\"false\" android:src=\"@drawable/ic_baseline_keyboard_arrow_up_24\" android:tint=\"@color/white\" app:borderWidth=\"0dp\" /\u003e \u003c/androidx.coordinatorlayout.widget.CoordinatorLayout\u003e ","date":"2021-06-15","objectID":"/android_click_card_item_move_to_detail_page/:4:2","tags":["Android","Java","Android Studio","RecyclerView","Card","List","Adapter","WebView","Detail","Click","Activity"],"title":"Android Java - 簡易今日頭條 - 點擊新聞卡片進入新聞詳情頁與 WebView 顯示","uri":"/android_click_card_item_move_to_detail_page/"},{"categories":["Android"],"content":"activity/NewsDetailActivity.java 在 onCreate() 中用 Bundle args = getIntent().getExtras(); 獲取傳來的 source_url，並設置 WebView 顯示該連結。 注意：有一些 API 傳回來的新聞詳情連結中已經有包含 http 字符，所以這部份要做處理，提前判斷該 URL 是否已經完整。 package com.example.toutiao.activity; // ... import androidx.annotation.RequiresApi; import androidx.appcompat.app.AppCompatActivity; import androidx.core.widget.NestedScrollView; import com.airbnb.lottie.LottieAnimationView; import com.example.toutiao.R; import com.google.android.material.floatingactionbutton.FloatingActionButton; /** * A Activity to be showed news detail. */ public class NewsDetailActivity extends AppCompatActivity { private WebView mNewsDetailWebView; private ProgressBar mProgressBar; private Button mBackButton; private LottieAnimationView mLoadingAnimationView; private FloatingActionButton mScrollToTopFAB; private NestedScrollView mWebNestedScrollView; @RequiresApi(api = Build.VERSION_CODES.M) @SuppressLint(\"SetJavaScriptEnabled\") @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_news_detail); Bundle args = getIntent().getExtras(); String url = \"\"; if (args != null) { url = args.getString(\"source_url\"); } Window window = getWindow(); window.addFlags(WindowManager.LayoutParams.FLAG_DRAWS_SYSTEM_BAR_BACKGROUNDS); window.setStatusBarColor(getResources().getColor(R.color.tabbed_bg)); mLoadingAnimationView = findViewById(R.id.animation_view_loading); mLoadingAnimationView.setAnimation(\"load-animation.json\"); mLoadingAnimationView.setSpeed(1); mLoadingAnimationView.playAnimation(); mNewsDetailWebView = findViewById(R.id.web_view); mProgressBar = findViewById(R.id.progress_bar_loading); mProgressBar.setMax(100); mProgressBar.setProgress(1); // avoid the url has \"http\" if (url.contains(\"http\")) { setNewsDetailWebView(url); } else { setNewsDetailWebView(\"https://m.toutiao.com\" + url); } mBackButton = findViewById(R.id.button_back); setBackButtonOnClick(); mWebNestedScrollView = findViewById(R.id.nested_scroll_view_web); mWebNestedScrollView.setOnScrollChangeListener(new View.OnScrollChangeListener() { @Override public void onScrollChange(View v, int scrollX, int scrollY, int oldScrollX, int oldScrollY) { if (scrollY == 0) { // hide FAB when NestedScrollView is at the top mScrollToTopFAB.hide(); } else { mScrollToTopFAB.show(); } } }); mScrollToTopFAB = findViewById(R.id.fab_scroll_to_top); mScrollToTopFAB.hide(); mScrollToTopFAB.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { // scroll to top mWebNestedScrollView.smoothScrollTo(0, 0); } }); } @SuppressLint(\"SetJavaScriptEnabled\") private void setNewsDetailWebView(String url) { // TODO: Make WebView Faster mNewsDetailWebView.setWebChromeClient(new WebChromeClient() { public void onProgressChanged(WebView view, int progress) { mProgressBar.setProgress(progress); } }); mNewsDetailWebView.setWebViewClient(new WebViewClient() { @Override public boolean shouldOverrideUrlLoading(WebView view, String url) { mProgressBar.setVisibility(View.VISIBLE); return super.shouldOverrideUrlLoading(view, url); } @Override public void onPageFinished(WebView view, String url) { mLoadingAnimationView.setVisibility(View.GONE); mProgressBar.setVisibility(View.GONE); } }); mNewsDetailWebView.getSettings().setAppCacheEnabled(true); mNewsDetailWebView.getSettings().setLoadsImagesAutomatically(true); mNewsDetailWebView.getSettings().setMixedContentMode(WebSettings.MIXED_CONTENT_ALWAYS_ALLOW); // hardware acceleration mNewsDetailWebView.setLayerType(View.LAYER_TYPE_HARDWARE, null); // enabling javascript mNewsDetailWebView.getSettings().setJavaScriptEnabled(true); // enable Dom storage mNewsDetailWebView.getSettings().setDomStorageEnabled(true); mNewsDetailWebView.loadUrl(url); } private void setBackButtonOnClick() { mBackButton.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { Leave(); } }); } @Override public void onBackPressed() { super.onBackPressed(","date":"2021-06-15","objectID":"/android_click_card_item_move_to_detail_page/:4:3","tags":["Android","Java","Android Studio","RecyclerView","Card","List","Adapter","WebView","Detail","Click","Activity"],"title":"Android Java - 簡易今日頭條 - 點擊新聞卡片進入新聞詳情頁與 WebView 顯示","uri":"/android_click_card_item_move_to_detail_page/"},{"categories":["Android"],"content":"Reference 簡易今日頭條 - Github ","date":"2021-06-15","objectID":"/android_click_card_item_move_to_detail_page/:5:0","tags":["Android","Java","Android Studio","RecyclerView","Card","List","Adapter","WebView","Detail","Click","Activity"],"title":"Android Java - 簡易今日頭條 - 點擊新聞卡片進入新聞詳情頁與 WebView 顯示","uri":"/android_click_card_item_move_to_detail_page/"},{"categories":["Android"],"content":"前言 上一篇我們說到了下拉刷新的實現，這篇我接著講如何實現上拉加載更多。 ","date":"2021-06-15","objectID":"/android_java_recyclerview_load_more/:1:0","tags":["Android","Java","Android Studio","RecyclerView","Card","List","Adapter","UI","Render","Load","More"],"title":"Android Java - 簡易今日頭條 - Load More 加載更多新聞內容","uri":"/android_java_recyclerview_load_more/"},{"categories":["Android"],"content":"Display 加載更多展示Display_load_more.gif \" 加載更多展示 ","date":"2021-06-15","objectID":"/android_java_recyclerview_load_more/:2:0","tags":["Android","Java","Android Studio","RecyclerView","Card","List","Adapter","UI","Render","Load","More"],"title":"Android Java - 簡易今日頭條 - Load More 加載更多新聞內容","uri":"/android_java_recyclerview_load_more/"},{"categories":["Android"],"content":"項目倉庫 簡易今日頭條 - Github ","date":"2021-06-15","objectID":"/android_java_recyclerview_load_more/:3:0","tags":["Android","Java","Android Studio","RecyclerView","Card","List","Adapter","UI","Render","Load","More"],"title":"Android Java - 簡易今日頭條 - Load More 加載更多新聞內容","uri":"/android_java_recyclerview_load_more/"},{"categories":["Android"],"content":"具體實現 這裡需要使用 RecyclerView 的監聽滾動方法，當無法在往下滾動的時候，就調用加載更多的方法。 以下是 RecyclerView 設置滾動監聽的參考案例： 這裡使用了 addOnScrollListener 方法做滾動監聽，接著在 onScrolled 方法中做處理，!recyclerView.canScrollVertically(1) 代表 recyclerView 已經無法繼續往下滾了。 // cardList mCardListRecyclerView = view.findViewById(R.id.recycler_view_card_list); mCardListRecyclerView.addOnScrollListener(new RecyclerView.OnScrollListener() { @Override public void onScrollStateChanged(@NonNull @NotNull RecyclerView recyclerView, int newState) { super.onScrollStateChanged(recyclerView, newState); } @Override public void onScrolled(@NonNull @NotNull RecyclerView recyclerView, int dx, int dy) { super.onScrolled(recyclerView, dx, dy); if (!recyclerView.canScrollVertically(1)) { // 1 for down loadMoreNews(); } } }); 這裡比較需要注意的地方是如果需要在加載更多後的 mCardListAdapter 要使用 notifyDataSetChanged() 方法更新頁面的 Item 渲染。 mCardListAdapter.setDataModelList(tempCardDataModelList); Log.v(\"after load more\", \"card list size: \" + mCardListAdapter.getItemCount()); mIsLoadMore = false; mCardListAdapter.notifyDataSetChanged(); ","date":"2021-06-15","objectID":"/android_java_recyclerview_load_more/:4:0","tags":["Android","Java","Android Studio","RecyclerView","Card","List","Adapter","UI","Render","Load","More"],"title":"Android Java - 簡易今日頭條 - Load More 加載更多新聞內容","uri":"/android_java_recyclerview_load_more/"},{"categories":["Android"],"content":"Reference 簡易今日頭條 - Github ","date":"2021-06-15","objectID":"/android_java_recyclerview_load_more/:5:0","tags":["Android","Java","Android Studio","RecyclerView","Card","List","Adapter","UI","Render","Load","More"],"title":"Android Java - 簡易今日頭條 - Load More 加載更多新聞內容","uri":"/android_java_recyclerview_load_more/"},{"categories":["Android"],"content":"前言 上次的文章中我寫了關於圖片緩存與懶加載的部份。這篇文章就簡要說一下怎麼實現下拉刷新。 ","date":"2021-06-15","objectID":"/android_java_pull_to_refresh/:1:0","tags":["Android","Java","Android Studio","RecyclerView","Card","List","Adapter","UI","Render"],"title":"Android Java - 簡易今日頭條 - Pull To Refresh 刷新新聞內容","uri":"/android_java_pull_to_refresh/"},{"categories":["Android"],"content":"Display 下拉刷新展示Display_pull_to_refresh.gif \" 下拉刷新展示 ","date":"2021-06-15","objectID":"/android_java_pull_to_refresh/:2:0","tags":["Android","Java","Android Studio","RecyclerView","Card","List","Adapter","UI","Render"],"title":"Android Java - 簡易今日頭條 - Pull To Refresh 刷新新聞內容","uri":"/android_java_pull_to_refresh/"},{"categories":["Android"],"content":"項目倉庫 簡易今日頭條 - Github ","date":"2021-06-15","objectID":"/android_java_pull_to_refresh/:3:0","tags":["Android","Java","Android Studio","RecyclerView","Card","List","Adapter","UI","Render"],"title":"Android Java - 簡易今日頭條 - Pull To Refresh 刷新新聞內容","uri":"/android_java_pull_to_refresh/"},{"categories":["Android"],"content":"具體實現 刷新的部份我是推薦使用 AndroidX 官方的方法： Swiperefreshlayout，具體說明可參考官方的 Swiperefreshlayout - Android Developers，雖然我一開始有考慮過網上一堆酷炫的第三方刷新頭，但是那些東西其實很多都是過時的，並不支持 AndroidX，使用上也有很多問題，或許你覺得 Swiperefreshlayout 很丑？但是包括 Bilibili 等手機應用大都是使用這個組件。而我目前使用的是 Github 上別人的開源項目 tuesda/CircleRefreshLayout - Github，因為這項目是已經過時的，所以我自己將該項目下載下來自己修改過時的 API，將其套用在自己的項目上，然而這項目依然有一些問題存在，但作者似乎也沒打算更新？ 這裡就介紹如何用 Swiperefreshlayout。也可以看 Implementing Pull to Refresh Guide - CODEPATH 首先要加上依賴 dependencies { implementation \"androidx.swiperefreshlayout:swiperefreshlayout:1.1.0\" } 接著在 xml 中需要刷新渲染的 RecyclerView 或是 ListView 加上該組件。 \u003c!-- ... --\u003e \u003candroidx.swiperefreshlayout.widget.SwipeRefreshLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" android:id=\"@+id/swiperefresh\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\"\u003e \u003candroidx.recyclerview.widget.RecyclerView android:id=\"@android:id/list\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" /\u003e \u003c/androidx.swiperefreshlayout.widget.SwipeRefreshLayout\u003e \u003c!-- ... --\u003e 下拉刷新組件都會有個監聽刷新動作的方法讓你使用，你可以在組件的相關說明文檔找到。在你的刷新地方進行刷新監聽。 public class TimelineActivity extends Activity { private SwipeRefreshLayout swipeContainer; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); // Only ever call `setContentView` once right at the top setContentView(R.layout.activity_main); // Lookup the swipe container view swipeContainer = (SwipeRefreshLayout) findViewById(R.id.swipeContainer); // Setup refresh listener which triggers new data loading swipeContainer.setOnRefreshListener(new SwipeRefreshLayout.OnRefreshListener() { @Override public void onRefresh() { // Your code to refresh the list here. // Make sure you call swipeContainer.setRefreshing(false) // once the network request has completed successfully. refreshData(); } }); // Configure the refreshing colors swipeContainer.setColorSchemeResources(android.R.color.holo_blue_bright, android.R.color.holo_green_light, android.R.color.holo_orange_light, android.R.color.holo_red_light); } } ","date":"2021-06-15","objectID":"/android_java_pull_to_refresh/:4:0","tags":["Android","Java","Android Studio","RecyclerView","Card","List","Adapter","UI","Render"],"title":"Android Java - 簡易今日頭條 - Pull To Refresh 刷新新聞內容","uri":"/android_java_pull_to_refresh/"},{"categories":["Android"],"content":"Reference 簡易今日頭條 - Github ","date":"2021-06-15","objectID":"/android_java_pull_to_refresh/:5:0","tags":["Android","Java","Android Studio","RecyclerView","Card","List","Adapter","UI","Render"],"title":"Android Java - 簡易今日頭條 - Pull To Refresh 刷新新聞內容","uri":"/android_java_pull_to_refresh/"},{"categories":["Android"],"content":"前言 上次的文章中我寫了關於新聞數據請求渲染的部份。這篇文章就簡要說一下怎麼做到圖片緩存與懶加載。 ","date":"2021-06-15","objectID":"/android_java_image_cache_and_lazy_load/:1:0","tags":["Android","Java","Android Studio","RecyclerView","Card","List","Adapter","request","OkHttp","Thread","UI","Render","Image","Cache","Picasso","Lazy"],"title":"Android Java - 簡易今日頭條 - 圖片緩存與懶加載","uri":"/android_java_image_cache_and_lazy_load/"},{"categories":["Android"],"content":"Display 圖片緩存與懶加載展示Display_image_picasso.gif \" 圖片緩存與懶加載展示 ","date":"2021-06-15","objectID":"/android_java_image_cache_and_lazy_load/:2:0","tags":["Android","Java","Android Studio","RecyclerView","Card","List","Adapter","request","OkHttp","Thread","UI","Render","Image","Cache","Picasso","Lazy"],"title":"Android Java - 簡易今日頭條 - 圖片緩存與懶加載","uri":"/android_java_image_cache_and_lazy_load/"},{"categories":["Android"],"content":"項目倉庫 簡易今日頭條 - Github ","date":"2021-06-15","objectID":"/android_java_image_cache_and_lazy_load/:3:0","tags":["Android","Java","Android Studio","RecyclerView","Card","List","Adapter","request","OkHttp","Thread","UI","Render","Image","Cache","Picasso","Lazy"],"title":"Android Java - 簡易今日頭條 - 圖片緩存與懶加載","uri":"/android_java_image_cache_and_lazy_load/"},{"categories":["Android"],"content":"具體實現 圖片的緩存最直接的方法就是將圖片下載到本地緩存，然後顯示到圖片，然而網上有一個 API 是 square/picasso - Github，實現原理可以看 Picasso从使用到原理详解 - JasonWang’s Blog，這篇文章講的很好。Picasso 可以將我們的圖片進行二級緩存，並檢查內存是否有這張圖片，如果有就無需下載，沒有就進行 OkHttp 在線程池的子線程請求（也就是異步請求回調函數使用的線程）。 我是將圖片緩存寫到了 ui/card/newsCardList/NewsCardItemDataModel.java 中的 RecyclerView.ViewHolder 子類中 bindData()，這裡就只寫一下簡單的使用方式。 Picasso.get().load(dataModel.getAvatar()).into(mAvatarView); ","date":"2021-06-15","objectID":"/android_java_image_cache_and_lazy_load/:4:0","tags":["Android","Java","Android Studio","RecyclerView","Card","List","Adapter","request","OkHttp","Thread","UI","Render","Image","Cache","Picasso","Lazy"],"title":"Android Java - 簡易今日頭條 - 圖片緩存與懶加載","uri":"/android_java_image_cache_and_lazy_load/"},{"categories":["Android"],"content":"Reference 簡易今日頭條 - Github ","date":"2021-06-15","objectID":"/android_java_image_cache_and_lazy_load/:5:0","tags":["Android","Java","Android Studio","RecyclerView","Card","List","Adapter","request","OkHttp","Thread","UI","Render","Image","Cache","Picasso","Lazy"],"title":"Android Java - 簡易今日頭條 - 圖片緩存與懶加載","uri":"/android_java_image_cache_and_lazy_load/"},{"categories":["Android"],"content":"前言 上一篇文章中我介紹了如何在 RecyclerView 中渲染三種不同的卡片樣式，這次我們加上了數據請求渲染，使該頁面是動態加載的。 ","date":"2021-06-15","objectID":"/android_java_request_and_card_list_render/:1:0","tags":["Android","Java","Android Studio","RecyclerView","Card","List","Adapter","request","OkHttp","Thread","UI","Render"],"title":"Android Java - 簡易今日頭條 - 新聞數據請求與卡片渲染","uri":"/android_java_request_and_card_list_render/"},{"categories":["Android"],"content":"Display 請求與渲染展示Display_request_and_render.gif \" 請求與渲染展示 ","date":"2021-06-15","objectID":"/android_java_request_and_card_list_render/:2:0","tags":["Android","Java","Android Studio","RecyclerView","Card","List","Adapter","request","OkHttp","Thread","UI","Render"],"title":"Android Java - 簡易今日頭條 - 新聞數據請求與卡片渲染","uri":"/android_java_request_and_card_list_render/"},{"categories":["Android"],"content":"項目倉庫 簡易今日頭條 - Github ","date":"2021-06-15","objectID":"/android_java_request_and_card_list_render/:3:0","tags":["Android","Java","Android Studio","RecyclerView","Card","List","Adapter","request","OkHttp","Thread","UI","Render"],"title":"Android Java - 簡易今日頭條 - 新聞數據請求與卡片渲染","uri":"/android_java_request_and_card_list_render/"},{"categories":["Android"],"content":"具體實現 關於卡片渲染細節我已經在 RecyclerView 顯示多種寫過了，所以這裡專注於怎麼使用 OkHttp 進行數據請求，與重新回到主 UI Thread 進行卡片渲染。 ","date":"2021-06-15","objectID":"/android_java_request_and_card_list_render/:4:0","tags":["Android","Java","Android Studio","RecyclerView","Card","List","Adapter","request","OkHttp","Thread","UI","Render"],"title":"Android Java - 簡易今日頭條 - 新聞數據請求與卡片渲染","uri":"/android_java_request_and_card_list_render/"},{"categories":["Android"],"content":"models/news/NewsDataModel.java 這個類是為了請求回來的數據做一個數據模型，方便後面將數據添入 NewsCardItemDataModel，使邏輯更加清晰。這裡一樣有三種構造函數，分別代表三種不同的卡片類型。 package com.example.toutiao.models.news; import java.util.ArrayList; /** * Data Model Class for news After requesting */ public class NewsDataModel { public static final int NO_IMAGE_TYPE = 0; public static final int ONE_IMAGE_TYPE = 1; public static final int THREE_IMAGE_TYPE = 2; // same private int mNewsCardStyleType; // three different card style private String mNewsId; // id private String mNewsTitle; // news title private String mNewsAbstract; // news abstract private int mNewsCommentsCount; // comments count private String mNewsSource; // author name private String mNewsMediaAvatarUrl; // author avatar private String mNewsSourceUrl; // detail page url // different private String mNewsImageUrl; // one image card style private ArrayList\u003cString\u003e mNewsThreeImage; // three image card style // no image style constructor public NewsDataModel( int newsCardStyleType, String newsId, String newsTitle, String newsAbstract, int newsCommentsCount, String newsSource, String newsMediaAvatarUrl, String newsSourceUrl ) { mNewsCardStyleType = newsCardStyleType; mNewsId = newsId; mNewsTitle = newsTitle; mNewsAbstract = newsAbstract; mNewsCommentsCount = newsCommentsCount; mNewsSource = newsSource; mNewsMediaAvatarUrl = newsMediaAvatarUrl; mNewsSourceUrl = newsSourceUrl; } // one image style constructor public NewsDataModel( int newsCardStyleType, String newsId, String newsTitle, String newsAbstract, int newsCommentsCount, String newsSource, String newsMediaAvatarUrl, String newsSourceUrl, String newsImageUrl ) { mNewsCardStyleType = newsCardStyleType; mNewsId = newsId; mNewsTitle = newsTitle; mNewsAbstract = newsAbstract; mNewsCommentsCount = newsCommentsCount; mNewsSource = newsSource; mNewsMediaAvatarUrl = newsMediaAvatarUrl; mNewsSourceUrl = newsSourceUrl; mNewsImageUrl = newsImageUrl; } // three image style constructor public NewsDataModel( int newsCardStyleType, String newsId, String newsTitle, String newsAbstract, int newsCommentsCount, String newsSource, String newsMediaAvatarUrl, String newsSourceUrl, ArrayList\u003cString\u003e newsThreeImage ) { mNewsCardStyleType = newsCardStyleType; mNewsId = newsId; mNewsTitle = newsTitle; mNewsAbstract = newsAbstract; mNewsCommentsCount = newsCommentsCount; mNewsSource = newsSource; mNewsMediaAvatarUrl = newsMediaAvatarUrl; mNewsSourceUrl = newsSourceUrl; mNewsThreeImage = newsThreeImage; } public int getNewsCardStyleType() { return mNewsCardStyleType; } public void setNewsCardStyleType(int newsCardStyleType) { mNewsCardStyleType = newsCardStyleType; } public String getNewsId() { return mNewsId; } public void setNewsId(String newsId) { mNewsId = newsId; } public String getNewsTitle() { return mNewsTitle; } public void setNewsTitle(String newsTitle) { mNewsTitle = newsTitle; } public String getNewsAbstract() { return mNewsAbstract; } public void setNewsAbstract(String newsAbstract) { mNewsAbstract = newsAbstract; } public int getNewsCommentsCount() { return mNewsCommentsCount; } public void setNewsCommentsCount(int newsCommentsCount) { mNewsCommentsCount = newsCommentsCount; } public String getNewsSource() { return mNewsSource; } public void setNewsSource(String newsSource) { mNewsSource = newsSource; } public String getNewsMediaAvatarUrl() { return mNewsMediaAvatarUrl; } public void setNewsMediaAvatarUrl(String newsMediaAvatarUrl) { mNewsMediaAvatarUrl = newsMediaAvatarUrl; } public String getNewsSourceUrl() { return mNewsSourceUrl; } public void setNewsSourceUrl(String newsSourceUrl) { mNewsSourceUrl = newsSourceUrl; } public String getNewsImageUrl() { return mNewsImageUrl; } public void setNewsImageUrl(String newsImageUrl) { mNewsImageUrl = newsImageUrl; } public ArrayList\u003cString\u003e getNewsThreeImage() { return mNewsThreeImage; } /* * add a image to mNewsThreeImage array list */ public void setNewsThreeImage(String newsImageUrl) { this.mNewsThreeImage.add(newsImageUrl); } } ","date":"2021-06-15","objectID":"/android_java_request_and_card_list_render/:4:1","tags":["Android","Java","Android Studio","RecyclerView","Card","List","Adapter","request","OkHttp","Thread","UI","Render"],"title":"Android Java - 簡易今日頭條 - 新聞數據請求與卡片渲染","uri":"/android_java_request_and_card_list_render/"},{"categories":["Android"],"content":"ui/page/newsChannel/newsChannelFragment.java 這裡是我們需要進行新聞內容請求的 Fragment。我使用的是 OkHttp 的方法，如果不知道 OkHttp 可以去 Github 看看 square/okhttp - github。 引入依賴需要在 build.gradle 中加上下面一段話： dependencies { // ... implementation 'com.squareup.okhttp3:okhttp:4.9.1' } 注意：為了能夠進行網路請求需要在 /manifests/AndroidManifest.xml 中加上 \u003cuses-permission android:name=\"android.permission.INTERNET\" /\u003e 這段話。 \u003c?xml version=\"1.0\" encoding=\"utf-8\"?\u003e \u003cmanifest xmlns:android=\"http://schemas.android.com/apk/res/android\" package=\"com.example.toutiao\"\u003e \u003cuses-permission android:name=\"android.permission.INTERNET\" /\u003e \u003cuses-permission android:name=\"android.permission.ACCESS_NETWORK_STATE\" /\u003e // ... 下面的 Code 中我分別使用 getUserAgent() 固定 UA，getInitNews() 請求新聞數據，initRenderCardList() 做數據渲染，dealWithResponseBody() 處理請求回來的 ResponseBody，dealWithNewsObject() 處理每個新聞列表，mHandler 負責請求後回到在主 UI 線程裡面進行渲染（也就是initRenderCardList()），這裡的注意點有： 除了固定 UA 外，需要將請求回來的 Response 中 Header 的 Set-Cookie 加入下一次請求中的 Cookie，這樣避免了請求回來的數據與原數據重複性。 請求必須使用多線程的方式進行異步請求，不能在 UI 主線程請求，這是新的 Android 規定，所以我建議可以使用 AsyncTask 或是 Okhttp 的異步回調方法。我下面的 Example 是使用了後者。 OkHttp 中異步請求的 response.body().string() 只能使用一次，使用完一次後就會將回應 Body 刪除節省資源（我也不知道為什麼要這樣設計），所以需要先存成 String 類型，再接著使用。 注意處理每一次數據，檢查是否有些數據不完整，或是 ResponseBody 是空的情況都需要考慮，如果沒有考慮到，就會經常在運行項目時產生 Crash。 package com.example.toutiao.ui.page.newsChannel; // ... import okhttp3.Call; import okhttp3.Callback; import okhttp3.OkHttpClient; import okhttp3.Request; import okhttp3.Response; import static com.example.toutiao.ui.card.newsCardList.NewsCardItemDataModel.NO_IMAGE_TYPE; import static com.example.toutiao.ui.card.newsCardList.NewsCardItemDataModel.ONE_IMAGE_TYPE; import static com.example.toutiao.ui.card.newsCardList.NewsCardItemDataModel.THREE_IMAGE_TYPE; /** * A simple {@link Fragment} subclass. * Use the {@link NewsChannelFragment#newInstance} factory method to * create an instance of this fragment. */ public class NewsChannelFragment extends Fragment { private static final String BASE_URL = \"https://www.toutiao.com/api/pc/feed/?max_behot_time=%d\u0026category=%s\"; private static final String[] CATEGORY_ATTR = new String[]{ \"__all__\", \"news_tech\", // \"news_image\", \"news_hot\", \"news_entertainment\", \"news_game\", \"news_sports\", \"news_finance\", \"digital\" }; private static final String DEFAULT_AVATAR = \"https://img.88icon.com/download/jpg/20200901/84083236c883964781afea41f1ea4e9c_512_511.jpg!88bg\"; private static final String DEFAULT_IMAGE = \"https://www.asiapacdigital.com/Zh_Cht/img/ap/services/reseller/TouTiao_1.jpg\"; private static final int INIT_OR_REFRESH = 0; private static final int LOAD_MORE = 1; private static final int LOAD_FAIL = 2; private ArrayList\u003cNewsDataModel\u003e mNewsDataModelList = new ArrayList\u003c\u003e(); private PageViewModel mPageViewModel; private RecyclerView mCardListRecyclerView; private NewsCardAdapter mCardListAdapter; private RecyclerView.LayoutManager mCardListLayoutManager; private Boolean mIsScrollToTop = false; private final List\u003cNewsCardItemDataModel\u003e mCardDataModelList = new ArrayList\u003c\u003e(); private String mCategory; private int mIndex; private boolean mIsRefresh = false; private boolean mIsLoadMore = false; private boolean mIsLoadingFail = false; private int mMaxBehotTime = 0; private String mCookie; public NewsChannelFragment() { } /** * Use this factory method to create a new instance of * this fragment using the provided parameters. */ public static NewsChannelFragment newInstance(String category, int index) { NewsChannelFragment fragment = new NewsChannelFragment(); Bundle bundle = new Bundle(); bundle.putString(\"category\", category); bundle.putInt(\"index\", index); fragment.setArguments(bundle); return fragment; } @Override public void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); mPageViewModel = new ViewModelProvider(this).get(PageViewModel.class); if (getArguments() != null) { mCategory = getArguments().getString(\"category\"); mIndex = getArguments().getInt(\"index\"); } mPageViewModel.setCategory(mCategory); mPageViewModel.setIndex(mIndex); } @Over","date":"2021-06-15","objectID":"/android_java_request_and_card_list_render/:4:2","tags":["Android","Java","Android Studio","RecyclerView","Card","List","Adapter","request","OkHttp","Thread","UI","Render"],"title":"Android Java - 簡易今日頭條 - 新聞數據請求與卡片渲染","uri":"/android_java_request_and_card_list_render/"},{"categories":["Android"],"content":"Reference 簡易今日頭條 - Github ","date":"2021-06-15","objectID":"/android_java_request_and_card_list_render/:5:0","tags":["Android","Java","Android Studio","RecyclerView","Card","List","Adapter","request","OkHttp","Thread","UI","Render"],"title":"Android Java - 簡易今日頭條 - 新聞數據請求與卡片渲染","uri":"/android_java_request_and_card_list_render/"},{"categories":["Android"],"content":"前言 上篇文章中我講述了如何實現Tabs 頻道頁面切換，接下來我們進一步實現 Tab Channel 中的新聞卡片列表渲染。 ","date":"2021-06-15","objectID":"/android_java_recyclerview_different_cards/:1:0","tags":["Android","Java","Android Studio","RecyclerView","Card","List","Adapter"],"title":"Android Java - 簡易今日頭條 - RecyclerView 渲染多種不同樣式的新聞卡片","uri":"/android_java_recyclerview_different_cards/"},{"categories":["Android"],"content":"項目倉庫 簡易今日頭條 - Github ","date":"2021-06-15","objectID":"/android_java_recyclerview_different_cards/:2:0","tags":["Android","Java","Android Studio","RecyclerView","Card","List","Adapter"],"title":"Android Java - 簡易今日頭條 - RecyclerView 渲染多種不同樣式的新聞卡片","uri":"/android_java_recyclerview_different_cards/"},{"categories":["Android"],"content":"Display 不同卡片樣式展示Display_recyclerView_different_card_styles.gif \" 不同卡片樣式展示 ","date":"2021-06-15","objectID":"/android_java_recyclerview_different_cards/:3:0","tags":["Android","Java","Android Studio","RecyclerView","Card","List","Adapter"],"title":"Android Java - 簡易今日頭條 - RecyclerView 渲染多種不同樣式的新聞卡片","uri":"/android_java_recyclerview_different_cards/"},{"categories":["Android"],"content":"具體實現 由於一種的渲染方法比較簡單，通常設計者是卡在顯示多種類型的 RecyclerView Item，在多種卡片 item 的設計這裡我只需要設計一種 DataModel ，然後在 DataModel 中添加 type 成員變量判斷是哪種類型的卡片。 以下我舉出實現的 Example，簡化的部份 Code，這裡的 Code 去掉： HTTP 請求的渲染、Pull To ReFresh、Load More。後面會再一一舉例。 ","date":"2021-06-15","objectID":"/android_java_recyclerview_different_cards/:4:0","tags":["Android","Java","Android Studio","RecyclerView","Card","List","Adapter"],"title":"Android Java - 簡易今日頭條 - RecyclerView 渲染多種不同樣式的新聞卡片","uri":"/android_java_recyclerview_different_cards/"},{"categories":["Android"],"content":"layout/fragment_news_channel.xml 在需要渲染列表的地方加上 RecyclerView 組件。 \u003c?xml version=\"1.0\" encoding=\"utf-8\"?\u003e \u003candroidx.coordinatorlayout.widget.CoordinatorLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:app=\"http://schemas.android.com/apk/res-auto\" xmlns:tools=\"http://schemas.android.com/tools\" android:id=\"@+id/fragment_news_channel\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:orientation=\"vertical\" tools:context=\".ui.page.newsChannel.NewsChannelFragment\"\u003e \u003cLinearLayout android:id=\"@+id/linearLayout\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:orientation=\"vertical\" tools:ignore=\"MissingClass,MissingConstraints\"\u003e \u003cTextView android:id=\"@+id/text_view_section_label\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:visibility=\"gone\" /\u003e \u003candroidx.recyclerview.widget.RecyclerView android:id=\"@+id/recycler_view_card_list\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:layout_marginBottom=\"5dp\" android:nestedScrollingEnabled=\"true\" android:scrollbars=\"vertical\" /\u003e \u003c/LinearLayout\u003e \u003c/androidx.coordinatorlayout.widget.CoordinatorLayout\u003e ","date":"2021-06-15","objectID":"/android_java_recyclerview_different_cards/:4:1","tags":["Android","Java","Android Studio","RecyclerView","Card","List","Adapter"],"title":"Android Java - 簡易今日頭條 - RecyclerView 渲染多種不同樣式的新聞卡片","uri":"/android_java_recyclerview_different_cards/"},{"categories":["Android"],"content":"layout/no_image_card_item.xml、layout/one_image_card_item.xml、three_images_card_item.xml 這是我們需要渲染的三種新聞卡片，我這裡就舉出第一種卡片 no_image_card_item，其他的可以自己去設計，不多贅述一一放出來。 \u003c?xml version=\"1.0\" encoding=\"utf-8\"?\u003e \u003candroidx.cardview.widget.CardView xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:app=\"http://schemas.android.com/apk/res-auto\" xmlns:tools=\"http://schemas.android.com/tools\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:layout_margin=\"5dp\" app:cardCornerRadius=\"10dp\" app:cardElevation=\"2dp\"\u003e \u003cTextView android:id=\"@+id/text_view_source_url\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:visibility=\"gone\"/\u003e \u003cLinearLayout android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:layout_marginLeft=\"16dp\" android:layout_marginTop=\"16dp\" android:layout_marginRight=\"16dp\" android:layout_marginBottom=\"8dp\" android:orientation=\"vertical\"\u003e \u003cLinearLayout android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\"\u003e \u003cImageView android:id=\"@+id/image_view_card_avatar\" android:layout_width=\"25dp\" android:layout_height=\"25dp\" android:layout_marginEnd=\"10dp\" tools:ignore=\"MissingConstraints\" tools:srcCompat=\"@drawable/avatar_1\" android:contentDescription=\"@string/avatar\" /\u003e \u003cTextView android:id=\"@+id/text_view_card_title\" style=\"@style/TextAppearance.MaterialComponents.Headline6\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:text=\"@string/title_goes_here\" app:layout_constraintBottom_toTopOf=\"@+id/avatar\" app:layout_constraintStart_toEndOf=\"@+id/avatar\" app:layout_constraintTop_toBottomOf=\"@+id/avatar\" tools:ignore=\"MissingConstraints\" /\u003e \u003c/LinearLayout\u003e \u003cTextView android:id=\"@+id/text_view_card_subtitle\" style=\"@style/TextAppearance.MaterialComponents.Caption\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:layout_marginTop=\"8dp\" android:text=\"@string/subtitle_goes_here\" app:layout_constraintStart_toStartOf=\"@+id/card_title\" app:layout_constraintTop_toBottomOf=\"@+id/card_title\" /\u003e \u003cTextView android:id=\"@+id/text_view_card_bottom_text\" style=\"@style/TextAppearance.MaterialComponents.Overline\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:layout_marginTop=\"8dp\" android:text=\"@string/comment\" app:layout_constraintStart_toStartOf=\"@+id/card_subtitle\" app:layout_constraintTop_toBottomOf=\"@+id/card_subtitle\" /\u003e \u003c/LinearLayout\u003e \u003c/androidx.cardview.widget.CardView\u003e ","date":"2021-06-15","objectID":"/android_java_recyclerview_different_cards/:4:2","tags":["Android","Java","Android Studio","RecyclerView","Card","List","Adapter"],"title":"Android Java - 簡易今日頭條 - RecyclerView 渲染多種不同樣式的新聞卡片","uri":"/android_java_recyclerview_different_cards/"},{"categories":["Android"],"content":"ui/card/newsCardList/NewsCardItemDataModel.java 我在 ui/card/newsCardList/ 創建了兩個文件：NewsCardItemDataModel.java、NewsCardAdapter.java，分別代表卡片的數據模型和 RecyclerView 適配器。 我這裡寫了三種構造類方法對應三種不同類型的卡片所需數據，並使用 mItemType 判斷卡片類型。 package com.example.toutiao.ui.card.newsCardList; import java.util.ArrayList; import java.util.Locale; /** * CardItemDataModel class: the card item data model in New Channel Fragment */ public class NewsCardItemDataModel { public static final int NO_IMAGE_TYPE = 0; public static final int ONE_IMAGE_TYPE = 1; public static final int THREE_IMAGE_TYPE = 2; private int mItemType; // cart type private String mId; //id private String mAvatar; // avatar private ArrayList\u003cString\u003e mThreeImageDrawable; // three image private String mImageDrawable; // one image private String mTitle; // title private String mSubTitle; // subtitle private String mBottomText; // bottom text private String mDetailUrl; // detail text to jump // no image style constructor public NewsCardItemDataModel(int itemType, String id, String newsTitle, String newsAbstract, int newsCommentsCount, String newsSource, String newsMediaAvatarUrl, String newsSourceUrl ) { mItemType = itemType; mId = id; mAvatar = newsMediaAvatarUrl; mTitle = String.format(Locale.CHINESE, \"%s\", newsTitle); mSubTitle = String.format(Locale.CHINESE, \"%s\", newsAbstract); mBottomText = String.format(Locale.CHINESE, \"%s %d 评论\", newsSource, newsCommentsCount); mDetailUrl = newsSourceUrl; } // one image style constructor public NewsCardItemDataModel(int itemType, String id, String newsTitle, String newsAbstract, int newsCommentsCount, String newsSource, String newsMediaAvatarUrl, String newsSourceUrl, String imageDrawable ) { mItemType = itemType; mId = id; mAvatar = newsMediaAvatarUrl; mTitle = String.format(Locale.CHINESE, \"%s\", newsTitle); mSubTitle = String.format(Locale.CHINESE, \"%s\", newsAbstract); mBottomText = String.format(Locale.CHINESE, \"%s %d 评论\", newsSource, newsCommentsCount); mDetailUrl = newsSourceUrl; // one mImageDrawable = imageDrawable; } // three image style constructor public NewsCardItemDataModel(int itemType, String id, String newsTitle, String newsAbstract, int newsCommentsCount, String newsSource, String newsMediaAvatarUrl, String newsSourceUrl, ArrayList\u003cString\u003e threeImageDrawable ) { mItemType = itemType; mId = id; mAvatar = newsMediaAvatarUrl; mTitle = String.format(Locale.CHINESE, \"%s\", newsTitle); mSubTitle = String.format(Locale.CHINESE, \"%s\", newsAbstract); mBottomText = String.format(Locale.CHINESE, \"%s %d 评论\", newsSource, newsCommentsCount); mDetailUrl = newsSourceUrl; // three mThreeImageDrawable = threeImageDrawable; } public int getItemType() { return mItemType; } public void setItemType(int itemType) { mItemType = itemType; } public String getId() { return mId; } public void setId(String id) { mId = id; } public String getAvatar() { return mAvatar; } public void setAvatar(String avatar) { mAvatar = avatar; } public String getBottomText() { return mBottomText; } public void setBottomText(String bottomText) { mBottomText = bottomText; } public String getTitle() { return mTitle; } public void setTitle(String title) { mTitle = title; } public String getSubTitle() { return mSubTitle; } public void setSubTitle(String subTitle) { mSubTitle = subTitle; } public ArrayList\u003cString\u003e getThreeImageDrawable() { return mThreeImageDrawable; } public void setThreeImageDrawable(ArrayList\u003cString\u003e threeImageDrawable) { mThreeImageDrawable = threeImageDrawable; } public String getImageDrawable() { return mImageDrawable; } public void setImageDrawable(String imageDrawable) { mImageDrawable = imageDrawable; } public String getDetailUrl() { return mDetailUrl; } public void setDetailUrl(String detailUrl) { mDetailUrl = detailUrl; } } ","date":"2021-06-15","objectID":"/android_java_recyclerview_different_cards/:4:3","tags":["Android","Java","Android Studio","RecyclerView","Card","List","Adapter"],"title":"Android Java - 簡易今日頭條 - RecyclerView 渲染多種不同樣式的新聞卡片","uri":"/android_java_recyclerview_different_cards/"},{"categories":["Android"],"content":"ui/card/newsCardList/NewsCardAdapter.java 這是渲染卡片的 RecyclerView 適配器類，三種卡片類型就會有三種 ViewHolder 子類。 onCreateViewHolder 綁定 UI 文件，onBindViewHolder 綁定數據。 package com.example.toutiao.ui.card.newsCardList; // ... import androidx.annotation.NonNull; import androidx.recyclerview.widget.RecyclerView; import com.example.toutiao.R; import com.example.toutiao.activity.NewsDetailActivity; import com.squareup.picasso.Picasso; import org.jetbrains.annotations.NotNull; import java.util.ArrayList; import java.util.List; /** * A card adapter to help perform to control card item's render in news channel fragment */ public class NewsCardAdapter extends RecyclerView.Adapter\u003cRecyclerView.ViewHolder\u003e { private final List\u003cNewsCardItemDataModel\u003e mDataModelList; private final Context mContext; public NewsCardAdapter(List\u003cNewsCardItemDataModel\u003e modelList, Context context) { mDataModelList = modelList; mContext = context; } @Override public int getItemViewType(final int position) { switch (mDataModelList.get(position).getItemType()) { case NewsCardItemDataModel.NO_IMAGE_TYPE: return NewsCardItemDataModel.NO_IMAGE_TYPE; case NewsCardItemDataModel.ONE_IMAGE_TYPE: return NewsCardItemDataModel.ONE_IMAGE_TYPE; case NewsCardItemDataModel.THREE_IMAGE_TYPE: return NewsCardItemDataModel.THREE_IMAGE_TYPE; default: return -1; } } /** * load more news and add to mDataModelList * * @param modelList */ public void setDataModelList(List\u003cNewsCardItemDataModel\u003e modelList) { mDataModelList.addAll(modelList); } @Override public int getItemCount() { return mDataModelList.size(); } @NonNull @Override public RecyclerView.ViewHolder onCreateViewHolder(@NonNull ViewGroup parent, int viewType) { View view; switch (viewType) { case NewsCardItemDataModel.NO_IMAGE_TYPE: view = LayoutInflater.from(parent.getContext()) .inflate(R.layout.no_image_card_item, parent, false); return new NoImageCardViewHolder(view); case NewsCardItemDataModel.ONE_IMAGE_TYPE: view = LayoutInflater.from(parent.getContext()) .inflate(R.layout.one_image_card_item, parent, false); return new OneImageCardViewHolder(view); case NewsCardItemDataModel.THREE_IMAGE_TYPE: view = LayoutInflater.from(parent.getContext()) .inflate(R.layout.three_images_card_item, parent, false); return new ThreeImageCardViewHolder(view); default: return null; } } @Override public void onBindViewHolder(@NotNull final RecyclerView.ViewHolder holder, final int position) { NewsCardItemDataModel object = mDataModelList.get(position); if (object != null) { switch (object.getItemType()) { case NewsCardItemDataModel.NO_IMAGE_TYPE: NoImageCardViewHolder holder1 = (NoImageCardViewHolder) holder; holder1.bindData(object, mContext); break; case NewsCardItemDataModel.ONE_IMAGE_TYPE: OneImageCardViewHolder holder2 = (OneImageCardViewHolder) holder; holder2.bindData(object, mContext); break; case NewsCardItemDataModel.THREE_IMAGE_TYPE: ThreeImageCardViewHolder holder3 = (ThreeImageCardViewHolder) holder; holder3.bindData(object, mContext); break; default: break; } } } // No image style card view holder class NoImageCardViewHolder extends RecyclerView.ViewHolder { private final ImageView mAvatarView; private final TextView mTitleTextView; private final TextView mSubTitleTextView; private final TextView mBottomTextView; private final TextView mSourceUrlTextView; public NoImageCardViewHolder(@NonNull View itemView) { super(itemView); mAvatarView = itemView.findViewById(R.id.image_view_card_avatar); mTitleTextView = itemView.findViewById(R.id.text_view_card_title); mSubTitleTextView = itemView.findViewById(R.id.text_view_card_subtitle); mBottomTextView = itemView.findViewById(R.id.text_view_card_bottom_text); mSourceUrlTextView = itemView.findViewById(R.id.text_view_source_url); } public void bindData(NewsCardItemDataModel dataModel, Context context) { Picasso.get().load(dataModel.getAvatar()).into(mAvatarView); // deal with title's length and subtitle's length String title = dataModel.getTitle(); if (title.length() \u003e 15) { title = title.substring(0, 16); tit","date":"2021-06-15","objectID":"/android_java_recyclerview_different_cards/:4:4","tags":["Android","Java","Android Studio","RecyclerView","Card","List","Adapter"],"title":"Android Java - 簡易今日頭條 - RecyclerView 渲染多種不同樣式的新聞卡片","uri":"/android_java_recyclerview_different_cards/"},{"categories":["Android"],"content":"ui/page/newsChannel/newsChannelFragment.java 在需要渲染的 Fragment，添加渲染 Code。 package com.example.toutiao.ui.page.newsChannel; // ... import androidx.annotation.NonNull; import androidx.annotation.Nullable; import androidx.fragment.app.Fragment; import androidx.lifecycle.Observer; import androidx.lifecycle.ViewModelProvider; import androidx.recyclerview.widget.LinearLayoutManager; import androidx.recyclerview.widget.RecyclerView; import com.example.toutiao.R; import com.example.toutiao.ui.card.newsCardList.NewsCardAdapter; import com.example.toutiao.ui.card.newsCardList.NewsCardItemDataModel; /** * A simple {@link Fragment} subclass. * Use the {@link NewsChannelFragment#newInstance} factory method to * create an instance of this fragment. */ public class NewsChannelFragment extends Fragment { private String mCategory; private int mIndex; private RecyclerView mCardListRecyclerView; private NewsCardAdapter mCardListAdapter; private RecyclerView.LayoutManager mCardListLayoutManager; private final List\u003cNewsCardItemDataModel\u003e mCardDataModelList = new ArrayList\u003c\u003e(); public NewsChannelFragment() { } /** * Use this factory method to create a new instance of * this fragment using the provided parameters. */ public static NewsChannelFragment newInstance(String category, int index) { NewsChannelFragment fragment = new NewsChannelFragment(); Bundle bundle = new Bundle(); bundle.putString(\"category\", category); bundle.putInt(\"index\", index); fragment.setArguments(bundle); return fragment; } @Override public void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); // ... } @Override public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) { View view = inflater.inflate(R.layout.fragment_news_channel, container, false); // ... for (int i = 0; i \u003c 10; i++) { int type = i % 3; String newsId = i; String newsTitle = \"你好\"; String newsAbstract = \"我是卡片\"; int newsCommentsCount = 100; String newsSource = \"https://example.com/e.png\"; String newsMediaAvatarUrl = \"https://example.com/e.png\"; String newsSourceUrl = \"www.google.com\"; if (type == NO_IMAGE_TYPE) { mCardDataModelList.add(new NewsCardItemDataModel( NO_IMAGE_TYPE, newsId, newsTitle, newsAbstract, newsCommentsCount, newsSource, newsMediaAvatarUrl, newsSourceUrl )); } else if (type == ONE_IMAGE_TYPE) { String middleImage = \"https://example.com/e.png\"; mCardDataModelList.add(new NewsCardItemDataModel( ONE_IMAGE_TYPE, newsId, newsTitle, newsAbstract, newsCommentsCount, newsSource, newsMediaAvatarUrl, newsSourceUrl, middleImage )); } else if (type == THREE_IMAGE_TYPE) { ArrayList\u003cString\u003e newsThreeImage = new ArrayList()\u003c\u003e; newsThreeImage.add(\"https://example.com/e.png\"); newsThreeImage.add(\"https://example.com/e.png\"); newsThreeImage.add(\"https://example.com/e.png\"); mCardDataModelList.add(new NewsCardItemDataModel( THREE_IMAGE_TYPE, newsId, newsTitle, newsAbstract, newsCommentsCount, newsSource, newsMediaAvatarUrl, newsSourceUrl, newsThreeImage )); } } // cardList mCardListRecyclerView = view.findViewById(R.id.recycler_view_card_list); // use this setting to improve performance if you know that changes // in content do not change the layout size of the RecyclerView mCardListRecyclerView.setHasFixedSize(true); // use a linear layout manager mCardListLayoutManager = new LinearLayoutManager(getContext()); mCardListRecyclerView.setLayoutManager(mCardListLayoutManager); // specify an adapter and pass in our data model list mCardListAdapter = new NewsCardAdapter(mCardDataModelList, getContext()); mCardListRecyclerView.setAdapter(mCardListAdapter); return view; } } ","date":"2021-06-15","objectID":"/android_java_recyclerview_different_cards/:4:5","tags":["Android","Java","Android Studio","RecyclerView","Card","List","Adapter"],"title":"Android Java - 簡易今日頭條 - RecyclerView 渲染多種不同樣式的新聞卡片","uri":"/android_java_recyclerview_different_cards/"},{"categories":["Android"],"content":"Reference 簡易今日頭條 - Github ","date":"2021-06-15","objectID":"/android_java_recyclerview_different_cards/:5:0","tags":["Android","Java","Android Studio","RecyclerView","Card","List","Adapter"],"title":"Android Java - 簡易今日頭條 - RecyclerView 渲染多種不同樣式的新聞卡片","uri":"/android_java_recyclerview_different_cards/"},{"categories":["Android"],"content":"前言 上一篇文章我寫了關於底部導覽頁的切換，這次換到關於簡易今日頭條中的 Tab Channel 切換。 ","date":"2021-06-15","objectID":"/android_java_swip_views_with_tabs/:1:0","tags":["Android","Java","Android Studio","Tabs","Fragment","Views","ViewPager"],"title":"Android Java - 簡易今日頭條 - Tabs 頻道頁面切換","uri":"/android_java_swip_views_with_tabs/"},{"categories":["Android"],"content":"項目倉庫 簡易今日頭條 - Github ","date":"2021-06-15","objectID":"/android_java_swip_views_with_tabs/:2:0","tags":["Android","Java","Android Studio","Tabs","Fragment","Views","ViewPager"],"title":"Android Java - 簡易今日頭條 - Tabs 頻道頁面切換","uri":"/android_java_swip_views_with_tabs/"},{"categories":["Android"],"content":"Display Tab Channel 展示Display_tabbed.gif \" Tab Channel 展示 ","date":"2021-06-15","objectID":"/android_java_swip_views_with_tabs/:3:0","tags":["Android","Java","Android Studio","Tabs","Fragment","Views","ViewPager"],"title":"Android Java - 簡易今日頭條 - Tabs 頻道頁面切換","uri":"/android_java_swip_views_with_tabs/"},{"categories":["Android"],"content":"具體實現 這裡我一開始使用的是舊的 API 方法(ViewPagerFragment、PagerAdapter)，如果你使用的是： androidx.viewpager.widget.ViewPager androidx.fragment.app.FragmentPagerAdapter 你會得到一個提示是這 兩個 API 是已經棄用(deprecated) 的，尤其是在寫 FragmentPagerAdapter 類的時候，Android Studio 會在父類類名上刪除線(Strikethrough)，所以我們需要切換到新的 API： androidx.viewpager2.widget.ViewPager2 androidx.viewpager2.adapter.FragmentStateAdapter 那我們來開始看具體寫法，可以參考官方文檔Create swipe views with tabs using ViewPager2 - Android developers。 註：由於這個的 tabbed 項目需求的頁面是相同的，都是展示新聞卡片，所以我們就只需要設計一個 Fragment 類，但是如果我們需要每個新聞頻道 Tab 頁面有不同的設計，就需要設計多個 Fragment 類。 ","date":"2021-06-15","objectID":"/android_java_swip_views_with_tabs/:4:0","tags":["Android","Java","Android Studio","Tabs","Fragment","Views","ViewPager"],"title":"Android Java - 簡易今日頭條 - Tabs 頻道頁面切換","uri":"/android_java_swip_views_with_tabs/"},{"categories":["Android"],"content":"layout/fragment_home.xml 我需要在 Home Fragment 展示我的 Tabs，然後在 NewsChannelFragment 顯示各頁面內容，這裡我們有 TabLayout 和最新的 ViewPager2。 \u003c?xml version=\"1.0\" encoding=\"utf-8\"?\u003e \u003candroidx.coordinatorlayout.widget.CoordinatorLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:tools=\"http://schemas.android.com/tools\" xmlns:app=\"http://schemas.android.com/apk/res-auto\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\"\u003e \u003ccom.google.android.material.appbar.AppBarLayout android:id=\"@+id/app_bar\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:theme=\"@style/Theme.PopupOverlay\" android:background=\"@color/tabbed_bg\"\u003e \u003candroidx.appcompat.widget.Toolbar android:layout_width=\"match_parent\" android:layout_height=\"?attr/actionBarSize\" android:layout_marginEnd=\"10dp\" app:layout_scrollFlags=\"scroll|enterAlways\"\u003e \u003ccom.example.toutiao.ui.searchBar.SearchView android:id=\"@+id/search_view_news\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:clickable=\"true\" android:focusable=\"true\" android:layout_marginEnd=\"30dp\" /\u003e \u003cButton android:layout_width=\"30dp\" android:layout_height=\"30dp\" android:layout_gravity=\"right|center_vertical\" android:background=\"@drawable/ic_baseline_add_circle_24\" android:backgroundTint=\"@color/white\" android:clickable=\"true\" android:focusable=\"true\" tools:ignore=\"RtlHardcoded\" /\u003e \u003c/androidx.appcompat.widget.Toolbar\u003e \u003ccom.google.android.material.tabs.TabLayout android:id=\"@+id/tabs_channel\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" app:tabIndicatorColor=\"#FFFFFF\" app:tabMode=\"scrollable\" app:tabRippleColor=\"#00FFFFFF\" app:tabSelectedTextColor=\"@color/white\" app:tabTextColor=\"#D1D1D1\"\u003e \u003c/com.google.android.material.tabs.TabLayout\u003e \u003c/com.google.android.material.appbar.AppBarLayout\u003e \u003candroidx.viewpager2.widget.ViewPager2 android:id=\"@+id/view_pager_channel\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" app:layout_behavior=\"@string/appbar_scrolling_view_behavior\"/\u003e \u003cLinearLayout android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:orientation=\"vertical\" tools:context=\".ui.home.HomeFragment\"/\u003e \u003c/androidx.coordinatorlayout.widget.CoordinatorLayout\u003e ","date":"2021-06-15","objectID":"/android_java_swip_views_with_tabs/:4:1","tags":["Android","Java","Android Studio","Tabs","Fragment","Views","ViewPager"],"title":"Android Java - 簡易今日頭條 - Tabs 頻道頁面切換","uri":"/android_java_swip_views_with_tabs/"},{"categories":["Android"],"content":"layout/fragment_news_channel.xml 這裡就沒有比較需要注意的東西。 \u003c?xml version=\"1.0\" encoding=\"utf-8\"?\u003e \u003candroidx.coordinatorlayout.widget.CoordinatorLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:app=\"http://schemas.android.com/apk/res-auto\" xmlns:tools=\"http://schemas.android.com/tools\" android:id=\"@+id/fragment_news_channel\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:orientation=\"vertical\" tools:context=\".ui.page.newsChannel.NewsChannelFragment\"\u003e \u003c!-- ... --\u003e \u003c/androidx.coordinatorlayout.widget.CoordinatorLayout\u003e ","date":"2021-06-15","objectID":"/android_java_swip_views_with_tabs/:4:2","tags":["Android","Java","Android Studio","Tabs","Fragment","Views","ViewPager"],"title":"Android Java - 簡易今日頭條 - Tabs 頻道頁面切換","uri":"/android_java_swip_views_with_tabs/"},{"categories":["Android"],"content":"ui/page/newsChannel/newsChannelFragment.java 我在 ui/page/newsChannel 目錄下加了三個文件，分別是 newsChannelFragment.java、PageViewModel.java、SectionsPagerAdapter.java。代表我們需要的 Fragment 頻道展示頁面、Fragment 的 ViewModel、ViewPager 的適配器。 這裡的注意點是在 public static NewsChannelFragment newInstance(String category, int index) 方法中返回一個自己的 Fragment 實例對象，還有 onCreate 中的傳參數獲取。 package com.example.toutiao.ui.page.newsChannel; import android.content.Context; import android.os.Bundle; import android.os.Handler; import android.view.Gravity; import android.view.LayoutInflater; import android.view.View; import android.view.ViewGroup; import androidx.annotation.NonNull; import androidx.annotation.Nullable; import androidx.fragment.app.Fragment; import androidx.lifecycle.Observer; import androidx.lifecycle.ViewModelProvider; /** * A simple {@link Fragment} subclass. * Use the {@link NewsChannelFragment#newInstance} factory method to * create an instance of this fragment. */ public class NewsChannelFragment extends Fragment { private String mCategory; private int mIndex; public NewsChannelFragment() { } /** * Use this factory method to create a new instance of * this fragment using the provided parameters. */ public static NewsChannelFragment newInstance(String category, int index) { NewsChannelFragment fragment = new NewsChannelFragment(); Bundle bundle = new Bundle(); bundle.putString(\"category\", category); bundle.putInt(\"index\", index); fragment.setArguments(bundle); return fragment; } @Override public void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); mPageViewModel = new ViewModelProvider(this).get(PageViewModel.class); if (getArguments() != null) { mCategory = getArguments().getString(\"category\"); mIndex = getArguments().getInt(\"index\"); } mPageViewModel.setCategory(mCategory); mPageViewModel.setIndex(mIndex); } @Override public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) { View view = inflater.inflate(R.layout.fragment_news_channel, container, false); // ... return view; } } ","date":"2021-06-15","objectID":"/android_java_swip_views_with_tabs/:4:3","tags":["Android","Java","Android Studio","Tabs","Fragment","Views","ViewPager"],"title":"Android Java - 簡易今日頭條 - Tabs 頻道頁面切換","uri":"/android_java_swip_views_with_tabs/"},{"categories":["Android"],"content":"ui/page/newsChannel/PageViewModel.java package com.example.toutiao.ui.page.newsChannel; import androidx.lifecycle.MutableLiveData; import androidx.lifecycle.ViewModel; /** * A [ViewModel] for NewsChannelFragment */ public class PageViewModel extends ViewModel { private final MutableLiveData\u003cInteger\u003e mIndex = new MutableLiveData\u003c\u003e(); private final MutableLiveData\u003cString\u003e mCategory = new MutableLiveData\u003c\u003e(); public MutableLiveData\u003cString\u003e getCategory() { return mCategory; } public void setCategory(String category) { mCategory.setValue(category); } public MutableLiveData\u003cInteger\u003e getIndex() { return mIndex; } public void setIndex(int index) { mIndex.setValue(index); } } ","date":"2021-06-15","objectID":"/android_java_swip_views_with_tabs/:4:4","tags":["Android","Java","Android Studio","Tabs","Fragment","Views","ViewPager"],"title":"Android Java - 簡易今日頭條 - Tabs 頻道頁面切換","uri":"/android_java_swip_views_with_tabs/"},{"categories":["Android"],"content":"ui/page/newsChannel/SectionsPagerAdapter.java 這裡使用的是最新的 API：FragmentStateAdapter。成員變量 mArrayList 是我們的 Fragment 數組，我們渲染多少頻道就有多大。addFragment 方法添加新的 fragment。 package com.example.toutiao.ui.page.newsChannel; import androidx.annotation.NonNull; import androidx.fragment.app.Fragment; import androidx.fragment.app.FragmentManager; import androidx.lifecycle.Lifecycle; import androidx.viewpager2.adapter.FragmentStateAdapter; import org.jetbrains.annotations.NotNull; import java.util.ArrayList; /** * A [FragmentStateAdapter] that returns a fragment corresponding to * one of the sections/tabs/pages. */ public class SectionsPagerAdapter extends FragmentStateAdapter { private final ArrayList\u003cFragment\u003e mArrayList = new ArrayList\u003c\u003e(); public SectionsPagerAdapter(@NonNull FragmentManager fragmentManager, @NonNull Lifecycle lifecycle) { super(fragmentManager, lifecycle); } public void addFragment(Fragment fragment) { mArrayList.add(fragment); } @NonNull @NotNull @Override public Fragment createFragment(int position) { // return your fragment that corresponds to this 'position' return mArrayList.get(position); } @Override public int getItemCount() { // Show total pages. return mArrayList.size(); } } ","date":"2021-06-15","objectID":"/android_java_swip_views_with_tabs/:4:5","tags":["Android","Java","Android Studio","Tabs","Fragment","Views","ViewPager"],"title":"Android Java - 簡易今日頭條 - Tabs 頻道頁面切換","uri":"/android_java_swip_views_with_tabs/"},{"categories":["Android"],"content":"ui/home/HomeFragment.java 這是最關鍵的文件，關於設定 TabLayout和 ViewPager2。 package com.example.toutiao.ui.home; // ... import androidx.annotation.StringRes; import androidx.fragment.app.Fragment; import androidx.viewpager2.widget.ViewPager2; import com.example.toutiao.R; import com.example.toutiao.activity.SearchActivity; import com.example.toutiao.ui.page.newsChannel.NewsChannelFragment; import com.example.toutiao.ui.page.newsChannel.SectionsPagerAdapter; import com.example.toutiao.ui.searchBar.SearchView; import com.google.android.material.tabs.TabLayout; import com.google.android.material.tabs.TabLayoutMediator; /** * A simple {@link Fragment} subclass. * Use the {@link com.example.toutiao.ui.home.HomeFragment#newInstance} factory method to * create an instance of this fragment. */ public class HomeFragment extends Fragment { private SectionsPagerAdapter mSectionsPagerAdapter; @StringRes private static final int[] TAB_TITLES = new int[]{ R.string.title__all__, R.string.title_news_tech, // R.string.title_news_image, R.string.title_news_hot, R.string.title_news_entertainment, R.string.title_news_game, R.string.title_news_sports, R.string.title_news_finance, R.string.title_digital, }; private ViewPager2 mViewPagerChannel; private SearchView mNewsSearchView; private TabLayout mTabsChannel; // // TODO: Rename parameter arguments, choose names that match // // // TODO: Rename and change types of parameters public HomeFragment() { // Required empty public constructor } /** * Use this factory method to create a new instance of * this fragment using the provided parameters. * * @return A new instance of fragment AccountFragment. */ // TODO: Rename and change types and number of parameters public static HomeFragment newInstance() { HomeFragment fragment = new HomeFragment(); Bundle args = new Bundle(); return fragment; } @Override public void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); } @Override public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) { // setting status bar's color Window mWindow = getActivity().getWindow(); mWindow.addFlags(WindowManager.LayoutParams.FLAG_DRAWS_SYSTEM_BAR_BACKGROUNDS); mWindow.setStatusBarColor(getResources().getColor(R.color.tabbed_bg)); // Inflate the layout for this fragment View view = inflater.inflate(R.layout.fragment_home, container, false); Context context = container.getContext(); // setting tabbed mSectionsPagerAdapter = new SectionsPagerAdapter(getChildFragmentManager(), getLifecycle()); mViewPagerChannel = view.findViewById(R.id.view_pager_channel); // add Fragments in your ViewPagerFragmentAdapter class for (int i = 0; i \u003c TAB_TITLES.length; i++) { String category = context.getString(TAB_TITLES[i]); mSectionsPagerAdapter.addFragment(NewsChannelFragment.newInstance(category, i)); } // setting switch Orientation mViewPagerChannel.setOrientation(ViewPager2.ORIENTATION_HORIZONTAL); // setting adapter to view pager mViewPagerChannel.setAdapter(mSectionsPagerAdapter); mTabsChannel = view.findViewById(R.id.tabs_channel); // setting tabbed new TabLayoutMediator(mTabsChannel, mViewPagerChannel, (tab, position) -\u003e tab.setText(context.getString(TAB_TITLES[position])) ).attach(); return view; } } ","date":"2021-06-15","objectID":"/android_java_swip_views_with_tabs/:4:6","tags":["Android","Java","Android Studio","Tabs","Fragment","Views","ViewPager"],"title":"Android Java - 簡易今日頭條 - Tabs 頻道頁面切換","uri":"/android_java_swip_views_with_tabs/"},{"categories":["Android"],"content":"Reference 簡易今日頭條 - Github ","date":"2021-06-15","objectID":"/android_java_swip_views_with_tabs/:5:0","tags":["Android","Java","Android Studio","Tabs","Fragment","Views","ViewPager"],"title":"Android Java - 簡易今日頭條 - Tabs 頻道頁面切換","uri":"/android_java_swip_views_with_tabs/"},{"categories":["Android"],"content":"前言 我接下來會寫一系列關於安卓開發的過程，由於這學期我選修了安卓應用開發，該課程與字節跳動客戶端員工合作，課程的項目設計是 “簡易頭條”，而我身為安卓零基礎的學生在一週內邊做邊學，最終完成了成果。在 Blog 我所遇到的細節技術實現。這篇文章是關於底部導覽頁的實現。 ","date":"2021-06-15","objectID":"/android_java_btn_nav/:1:0","tags":["Android","Java","Android Studio","Navigation","Fragment","Bottom","Button"],"title":"Android Java - 簡易今日頭條 - 實現底部按鈕導覽切換 Fragment 頁面","uri":"/android_java_btn_nav/"},{"categories":["Android"],"content":"項目倉庫 簡易今日頭條 - Github ","date":"2021-06-15","objectID":"/android_java_btn_nav/:2:0","tags":["Android","Java","Android Studio","Navigation","Fragment","Bottom","Button"],"title":"Android Java - 簡易今日頭條 - 實現底部按鈕導覽切換 Fragment 頁面","uri":"/android_java_btn_nav/"},{"categories":["Android"],"content":"Display Bottom Nav 展示Display_nav.gif \" Bottom Nav 展示 ","date":"2021-06-15","objectID":"/android_java_btn_nav/:3:0","tags":["Android","Java","Android Studio","Navigation","Fragment","Bottom","Button"],"title":"Android Java - 簡易今日頭條 - 實現底部按鈕導覽切換 Fragment 頁面","uri":"/android_java_btn_nav/"},{"categories":["Android"],"content":"具體實現 使用 BottomNavigationView、NavController 與 NavigationUI.setupWithNavController() 方法去實現。 現在我需要使用三個子頁面(Fragment)分別是首頁(home)、視頻(video)、我的(account)： 注意：目錄的正確需要自己去修改 ","date":"2021-06-15","objectID":"/android_java_btn_nav/:4:0","tags":["Android","Java","Android Studio","Navigation","Fragment","Bottom","Button"],"title":"Android Java - 簡易今日頭條 - 實現底部按鈕導覽切換 Fragment 頁面","uri":"/android_java_btn_nav/"},{"categories":["Android"],"content":"layout/activity.xml \u003c?xml version=\"1.0\" encoding=\"utf-8\"?\u003e \u003candroidx.constraintlayout.widget.ConstraintLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:app=\"http://schemas.android.com/apk/res-auto\" xmlns:tools=\"http://schemas.android.com/tools\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:id=\"@+id/main_activity\" tools:context=\".activity.MainActivity\"\u003e \u003ccom.google.android.material.bottomnavigation.BottomNavigationView android:id=\"@+id/nav_view\" android:layout_width=\"0dp\" android:layout_height=\"wrap_content\" android:layout_marginStart=\"0dp\" android:layout_marginEnd=\"0dp\" android:background=\"?android:attr/windowBackground\" app:layout_constraintBottom_toBottomOf=\"parent\" app:layout_constraintLeft_toLeftOf=\"parent\" app:layout_constraintRight_toRightOf=\"parent\" app:menu=\"@menu/bottom_nav_menu\" /\u003e \u003cfragment android:id=\"@+id/nav_host_fragment_activity_main\" android:name=\"androidx.navigation.fragment.NavHostFragment\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" app:defaultNavHost=\"true\" app:layout_constraintBottom_toTopOf=\"@id/nav_view\" app:layout_constraintLeft_toLeftOf=\"parent\" app:layout_constraintRight_toRightOf=\"parent\" app:layout_constraintTop_toTopOf=\"parent\" app:navGraph=\"@navigation/mobile_navigation\" /\u003e \u003c/androidx.constraintlayout.widget.ConstraintLayout\u003e ","date":"2021-06-15","objectID":"/android_java_btn_nav/:4:1","tags":["Android","Java","Android Studio","Navigation","Fragment","Bottom","Button"],"title":"Android Java - 簡易今日頭條 - 實現底部按鈕導覽切換 Fragment 頁面","uri":"/android_java_btn_nav/"},{"categories":["Android"],"content":"navigation/mobile_navigation.xml navigation 是可以設計導覽圖的一個組件也包括 Fragment 頁面的跳轉。 使用可以參考官方文檔 Navigation 组件使用入门 - Android 开发者。 \u003c?xml version=\"1.0\" encoding=\"utf-8\"?\u003e \u003cnavigation xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:app=\"http://schemas.android.com/apk/res-auto\" xmlns:tools=\"http://schemas.android.com/tools\" android:id=\"@+id/mobile_navigation\" app:startDestination=\"@+id/navigation_home\"\u003e \u003cfragment android:id=\"@+id/navigation_home\" android:name=\"com.example.toutiao.ui.home.HomeFragment\" android:label=\"@string/title_home\" tools:layout=\"@layout/fragment_home\" /\u003e \u003cfragment android:id=\"@+id/navigation_video\" android:name=\"com.example.toutiao.ui.video.VideoFragment\" android:label=\"@string/title_video\" tools:layout=\"@layout/fragment_video\" /\u003e \u003cfragment android:id=\"@+id/navigation_account\" android:name=\"com.example.toutiao.ui.account.AccountFragment\" android:label=\"@string/title_notifications\" tools:layout=\"@layout/fragment_account\" /\u003e \u003c/navigation\u003e ","date":"2021-06-15","objectID":"/android_java_btn_nav/:4:2","tags":["Android","Java","Android Studio","Navigation","Fragment","Bottom","Button"],"title":"Android Java - 簡易今日頭條 - 實現底部按鈕導覽切換 Fragment 頁面","uri":"/android_java_btn_nav/"},{"categories":["Android"],"content":"layout/fragment_home.xml、layout/fragment_video.xml、layout/fragment_account.xml 三個 Fragment 需要創建，內容都一樣，自行替換裡面的參數。 \u003c?xml version=\"1.0\" encoding=\"utf-8\"?\u003e \u003cFrameLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:tools=\"http://schemas.android.com/tools\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" tools:context=\".ui.home.HomeFragment\"\u003e \u003c!-- TODO: Update blank fragment layout --\u003e \u003cTextView android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:text=\"@string/hello_home_fragment\" /\u003e \u003c/FrameLayout\u003e ","date":"2021-06-15","objectID":"/android_java_btn_nav/:4:3","tags":["Android","Java","Android Studio","Navigation","Fragment","Bottom","Button"],"title":"Android Java - 簡易今日頭條 - 實現底部按鈕導覽切換 Fragment 頁面","uri":"/android_java_btn_nav/"},{"categories":["Android"],"content":"activity/MainActivity.java package com.example.toutiao.activity; import android.os.Bundle; import androidx.appcompat.app.AppCompatActivity; import androidx.navigation.NavController; import androidx.navigation.Navigation; import androidx.navigation.ui.NavigationUI; import com.example.toutiao.R; import com.google.android.material.bottomnavigation.BottomNavigationView; public class MainActivity extends AppCompatActivity { @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); BottomNavigationView navView = findViewById(R.id.nav_view); // binding the bottom_nav and fragment to transfer NavController navController = Navigation.findNavController(this, R.id.nav_host_fragment_activity_main); NavigationUI.setupWithNavController(navView, navController); } } ","date":"2021-06-15","objectID":"/android_java_btn_nav/:4:4","tags":["Android","Java","Android Studio","Navigation","Fragment","Bottom","Button"],"title":"Android Java - 簡易今日頭條 - 實現底部按鈕導覽切換 Fragment 頁面","uri":"/android_java_btn_nav/"},{"categories":["Android"],"content":"ui/home/HomeFragment.java、ui/video/VideoFragment.java、ui/account/AccountFragment.java 這三個類文件都一致，自己去做調整。以下取 VideoFragment.java 作為參考。 package com.example.toutiao.ui.video; import android.os.Bundle; import androidx.fragment.app.Fragment; import android.view.LayoutInflater; import android.view.View; import android.view.ViewGroup; import com.example.toutiao.R; /** * A simple {@link Fragment} subclass. * Use the {@link VideoFragment#newInstance} factory method to * create an instance of this fragment. */ public class VideoFragment extends Fragment { // TODO: Rename parameter arguments, choose names that match // the fragment initialization parameters, e.g. ARG_ITEM_NUMBER private static final String ARG_PARAM1 = \"param1\"; private static final String ARG_PARAM2 = \"param2\"; // TODO: Rename and change types of parameters private String mParam1; private String mParam2; public VideoFragment() { // Required empty public constructor } /** * Use this factory method to create a new instance of * this fragment using the provided parameters. * * @param param1 Parameter 1. * @param param2 Parameter 2. * @return A new instance of fragment VideoFragment. */ // TODO: Rename and change types and number of parameters public static VideoFragment newInstance(String param1, String param2) { VideoFragment fragment = new VideoFragment(); Bundle args = new Bundle(); args.putString(ARG_PARAM1, param1); args.putString(ARG_PARAM2, param2); fragment.setArguments(args); return fragment; } @Override public void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); if (getArguments() != null) { mParam1 = getArguments().getString(ARG_PARAM1); mParam2 = getArguments().getString(ARG_PARAM2); } } @Override public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) { // Inflate the layout for this fragment return inflater.inflate(R.layout.fragment_video, container, false); } } ","date":"2021-06-15","objectID":"/android_java_btn_nav/:4:5","tags":["Android","Java","Android Studio","Navigation","Fragment","Bottom","Button"],"title":"Android Java - 簡易今日頭條 - 實現底部按鈕導覽切換 Fragment 頁面","uri":"/android_java_btn_nav/"},{"categories":["Android"],"content":"項目心得 由於這次的項目因為我本身是安卓零基礎，而我卻使用了一週的時間將整體的 Code 邏輯架構寫好了，這是因為我會使用 Google 用關鍵字搜索，StackOverFlow 大多數時候都能給我比較好的答案，在做項目之前我頂多是有了做過 Qt C++ 的基礎，所以了解了一下安卓的組件生命週期還有哪些控件和布局，我就直接邊做邊學，我覺得這樣子對我的成長和動手能力提升很多，也謝謝字節跳動客戶端開發的大哥們一直提點我的不足。最終得以完成這個項目。 ","date":"2021-06-15","objectID":"/android_java_btn_nav/:5:0","tags":["Android","Java","Android Studio","Navigation","Fragment","Bottom","Button"],"title":"Android Java - 簡易今日頭條 - 實現底部按鈕導覽切換 Fragment 頁面","uri":"/android_java_btn_nav/"},{"categories":["Android"],"content":"Reference 簡易今日頭條 - Github ","date":"2021-06-15","objectID":"/android_java_btn_nav/:6:0","tags":["Android","Java","Android Studio","Navigation","Fragment","Bottom","Button"],"title":"Android Java - 簡易今日頭條 - 實現底部按鈕導覽切換 Fragment 頁面","uri":"/android_java_btn_nav/"},{"categories":["Moment"],"content":"前言 我將在這篇文章分享我的春招找實習心得，並且分享如何準備應聘。 ","date":"2021-05-10","objectID":"/2021_spring_recruitment/:1:0","tags":["2021","春招","實習","面試","LeetCode","CS","計算機科學","軟件工程"],"title":"2021  3 - 4 月春招找實習過程心得","uri":"/2021_spring_recruitment/"},{"categories":["Moment"],"content":"背景 985 中南大學計算機學院軟件工程 18 級大三本科生 已修操作系統、計算機網路、數據庫、數據結構、算法等必要課程 時間安排從 7 月份開始能實習 3 - 4 個月 比較萬油精，可以前後端開發，偏好 C/C++ 崗位 (因為 Java 崗太卷了) ","date":"2021-05-10","objectID":"/2021_spring_recruitment/:2:0","tags":["2021","春招","實習","面試","LeetCode","CS","計算機科學","軟件工程"],"title":"2021  3 - 4 月春招找實習過程心得","uri":"/2021_spring_recruitment/"},{"categories":["Moment"],"content":"心得 這次 2021 年的春招實習，我先後投遞了各個大廠，像是阿里巴巴、騰訊、快手、字節跳動、華為，然而一直沒有好結果，加上自己一開始準備筆試面試並沒有準備多少，對我來說就像是突如其來的考試，最終到了五月份依然沒拿到好的 Offer。我過程有時被撈了又面掛了，剛開始每次面試我都很緊張，因為沒有面試經驗，甚至有一次我緊張到整晚都睡不著，然後面掛了又覺得自己是不是實力不夠，那段期間真的是不斷的自我懷疑，面到後面我都覺得有點無感隨緣了，感覺一切都無所謂了。 一開始我投的阿里巴巴招聘流程讓人覺得詭譎，說不出來的奇妙感，面試時問的問題過於硬核，然後阿里巴巴的崗位可能是因為內推關係，不能改比較坑。字節面試一面時感受得出面試官的不耐煩，華為的筆試我以為很簡單，結果我那次機考意外的難很多，我又寫題時間分配錯誤以及題意理解錯誤，最終以失敗告終，我或許不適合大廠。 至於小廠，小廠的面試反而沒那麼多八股文，就純聊天了解你的情況，但是最終都涼了，包括深圳的同為數碼科技(做監控安全方面)和武漢的統信(UOS、Deepin)，拒我的理由大多是 “我們針對實習生的需求進行調整”。感覺計算機行業競爭很激烈。 我想我最後打擊的事情是在深圳的華為 HR 大哥評價我的簡歷，學校不夠優秀，實踐雖然可以，但是可能對他們來說技術含量低，又專業不對口，所以建議我不要急著去找實習，要我去考個 C9 的研究生。 最後還是希望各位面試時盡量放輕鬆，不然容易腦袋死機，語言邏輯等表達不通順。然後提醒一下很多大廠的面試電話是別人打得了給你，你打不了電話給別人。 ","date":"2021-05-10","objectID":"/2021_spring_recruitment/:3:0","tags":["2021","春招","實習","面試","LeetCode","CS","計算機科學","軟件工程"],"title":"2021  3 - 4 月春招找實習過程心得","uri":"/2021_spring_recruitment/"},{"categories":["Moment"],"content":"關於面試準備工作 註：一定要提前準備 1 個月以上。 我們應該在這裡針對下面三個部份： 數據結構與算法 對應崗位的八股文 簡歷項目 ","date":"2021-05-10","objectID":"/2021_spring_recruitment/:4:0","tags":["2021","春招","實習","面試","LeetCode","CS","計算機科學","軟件工程"],"title":"2021  3 - 4 月春招找實習過程心得","uri":"/2021_spring_recruitment/"},{"categories":["Moment"],"content":"數據結構與算法 首先，我不是 ACM 的選手，也沒有算法競賽背景，所以說想要在部份過關，我的建議是在 LeetCode(力扣) 上進行刷題練習，很多人會有困惑，“要怎麼刷？\"，我依序列出順序： 1. 劍指 Offer 75 題（劍指 Offer 是性價比最高，面試高頻考題） 2. 在題庫中照題目的出現頻率去刷，優先刷高頻出現率的題，刷題數約 100 題 其中面試很愛考得重點無非就是 DP(動態規劃)、鏈表、堆棧、隊列、排序(快排與歸併)、二分查找、數組、二叉樹、字符串處理、回溯、DFS、BFS、最短路徑算法(比較少考)。 你只要做到我所說的上面要求，基本大多數算法面試都能解決，如果之前學的東西都忘了沒關係，你邊刷題邊複習，學的效率很快。 我是在幾次面試的失敗毒打後，才開始刷 LeetCode，接著發現之前面試的算法題大多都是從劍指 Offer 選出來的。耗時一個月，已經刷了 180 題以上。 我的 LeetCodemy_leetcode_training.png \" 我的 LeetCode ","date":"2021-05-10","objectID":"/2021_spring_recruitment/:4:1","tags":["2021","春招","實習","面試","LeetCode","CS","計算機科學","軟件工程"],"title":"2021  3 - 4 月春招找實習過程心得","uri":"/2021_spring_recruitment/"},{"categories":["Moment"],"content":"八股文 通用性的八股文有：數據結構、算法、語言基礎、操作系統、Linux、計算機網路、數據庫，這部份我在前幾天文章有整理到：互聯網公司大廠 – 面試八股文彙整，八股文需要自己去牛課網等網站自己去找面試經歷分享，並整理。 前端崗位的話，需要自己另外去整理 JS 相關的面試題，還有 VueJS 等。 八股文一定要背熟，不然會被刷，尤其因為在校生沒有工作經驗，大廠就會看重你的基礎知識掌握，然而有時考得很艱難晦澀，或是背不起來。印象比較深刻的一次艱苦面試就是阿里巴巴 Base 北京的廣告部門，基礎架構研發工程師實習生，問的問題就是關於操作系統的虛擬內存、編譯原理等方面底層知識，當然我涼了，最後我問了面試官我的表現，他說他比較希望我能從這方面的技術發明背景下進行說明，像是為什麼當時的人要去設計這個東西、設計這東西的思想與原理、這技術改善了當時什麼問題又引發了什麼問題，如果是你，你會去怎麼設計。 ","date":"2021-05-10","objectID":"/2021_spring_recruitment/:4:2","tags":["2021","春招","實習","面試","LeetCode","CS","計算機科學","軟件工程"],"title":"2021  3 - 4 月春招找實習過程心得","uri":"/2021_spring_recruitment/"},{"categories":["Moment"],"content":"簡歷項目 簡歷項目上的項目我覺得至少要有三個，但是是可以說得過去的項目，而不是自己隨便寫的學習 Demo，這些為了簡歷而弄簡歷的項目反而並不是很有用。 面試官會根據你在簡歷上寫的項目進行盤問深挖，並且問你一些理論知識，所以一定要放上自己熟悉的項目。 ","date":"2021-05-10","objectID":"/2021_spring_recruitment/:4:3","tags":["2021","春招","實習","面試","LeetCode","CS","計算機科學","軟件工程"],"title":"2021  3 - 4 月春招找實習過程心得","uri":"/2021_spring_recruitment/"},{"categories":["Moment"],"content":"結語 祝想要找實習或是校招的同學未來面試順利，還有一點需要提醒的是各位要找到自己的崗位定向，然後針對你的崗位進行學習與努力。 ","date":"2021-05-10","objectID":"/2021_spring_recruitment/:5:0","tags":["2021","春招","實習","面試","LeetCode","CS","計算機科學","軟件工程"],"title":"2021  3 - 4 月春招找實習過程心得","uri":"/2021_spring_recruitment/"},{"categories":["Python"],"content":"前言 因為這期學期上半我選了機器學習與數據挖掘，我在課程小組項目中負責了爬蟲這個部份，我會在這篇文章紀錄一下我的過程，並教導大家如何實戰 Python 爬蟲。 ","date":"2021-05-04","objectID":"/python_spider_experience_instruct_github_repos/:1:0","tags":["Python","Spider","Github","Repository"],"title":"Python 爬蟲實戰教學 - Github 倉庫特徵爬取","uri":"/python_spider_experience_instruct_github_repos/"},{"categories":["Python"],"content":"項目說明 我們這個小組項目的爬取需求是爬取 Github 項目的各個特徵，這篇文章會分兩個部份，第一個部份是使用 BeautifulSoup 爬取原生的 HTML 頁面，第二部份是使用 Github API，其中第二部份包含了每個倉庫的 Commits、pull_request 等月變化量(2020.03 ~2021.03)。 P.S. 其實是我在剛開始寫爬蟲的時候，覺得 GIthub API 回傳的數據特徵有點少，所以就直接爬 Github 原生 HTML 頁面，沒有去爬月變化的數據，結果組長說要我重新去寫爬蟲，要爬月變化數據。 ","date":"2021-05-04","objectID":"/python_spider_experience_instruct_github_repos/:2:0","tags":["Python","Spider","Github","Repository"],"title":"Python 爬蟲實戰教學 - Github 倉庫特徵爬取","uri":"/python_spider_experience_instruct_github_repos/"},{"categories":["Python"],"content":"開發前準備 ","date":"2021-05-04","objectID":"/python_spider_experience_instruct_github_repos/:3:0","tags":["Python","Spider","Github","Repository"],"title":"Python 爬蟲實戰教學 - Github 倉庫特徵爬取","uri":"/python_spider_experience_instruct_github_repos/"},{"categories":["Python"],"content":"安裝相關庫 因為我們需要使用到的庫有 BeautifulSoup 和 requests 等。所以有些需要自己去安裝， import requests import time import csv import json from bs4 import BeautifulSoup pip install requests BeautifulSoup ","date":"2021-05-04","objectID":"/python_spider_experience_instruct_github_repos/:3:1","tags":["Python","Spider","Github","Repository"],"title":"Python 爬蟲實戰教學 - Github 倉庫特徵爬取","uri":"/python_spider_experience_instruct_github_repos/"},{"categories":["Python"],"content":"Github 私人 Token 因為我們需要爬取 Github 的網頁和使用 Github API，我們需要申請 Personal token，避免我們的請求達到 Rate Limit，Github 有限制一分鐘內的請求次數。 Github 私人 token 申請github_personal_token.png \" Github 私人 token 申請 ","date":"2021-05-04","objectID":"/python_spider_experience_instruct_github_repos/:3:2","tags":["Python","Spider","Github","Repository"],"title":"Python 爬蟲實戰教學 - Github 倉庫特徵爬取","uri":"/python_spider_experience_instruct_github_repos/"},{"categories":["Python"],"content":"請求設定 我們請求在請求頁面時需要模仿瀏覽器的請求方式 如果自己沒有 proxies 可以去掉這一項。 # request settings # token token = '' # proxy proxies = { \"http\": \"http://127.0.0.1:7890\", \"https\": \"http://127.0.0.1:7890\", } # through Github api headers = { 'Accept': 'application/vnd.github.v3+json', 'Authorization': 'token {token}'.format(token = token) } # 模仿瀏覽器請求原生頁面 headers_raw_page = { 'User-Agent': 'Mozilla/5.0 (X11; Linux x86_64; rv:89.0) Gecko/20100101 Firefox/89.0', 'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8', 'Authorization': 'token {token}'.format(token = token) } timeoutSec = 15 # setup your timeout spec(sec) ","date":"2021-05-04","objectID":"/python_spider_experience_instruct_github_repos/:3:3","tags":["Python","Spider","Github","Repository"],"title":"Python 爬蟲實戰教學 - Github 倉庫特徵爬取","uri":"/python_spider_experience_instruct_github_repos/"},{"categories":["Python"],"content":"第一部份 - 原生頁面 ","date":"2021-05-04","objectID":"/python_spider_experience_instruct_github_repos/:4:0","tags":["Python","Spider","Github","Repository"],"title":"Python 爬蟲實戰教學 - Github 倉庫特徵爬取","uri":"/python_spider_experience_instruct_github_repos/"},{"categories":["Python"],"content":"確定爬取規則 先確定要爬的數據，我們預先在 Github topic 中爬取 deep-learning 的相關 Repositories 的 URL 作為我們數據分析的數據量。並且觀察頁面的請求與分頁。 topic 頁面deep_learning_topic.png \" topic 頁面 我們可以按下 F12 可以在網路請求部份找到我們頁面請求的內容，並且在傳參部份找的到 page 參數，page 參數以及 per_page 參數可以作為我們循環請求的依據。 per_page 參數是決定每頁顯示多少列倉庫，這部份是我在看完 Github API 後知道的參數。 觀察請求規則topic_request_page.png \" 觀察請求規則 ","date":"2021-05-04","objectID":"/python_spider_experience_instruct_github_repos/:4:1","tags":["Python","Spider","Github","Repository"],"title":"Python 爬蟲實戰教學 - Github 倉庫特徵爬取","uri":"/python_spider_experience_instruct_github_repos/"},{"categories":["Python"],"content":"爬取我們要的所有倉庫 下面是使用迴圈去調參，接著使用 BS4 去解析頁面元素。爬取的內容會存到 start_urls。 start_urls = [] # save urls base_url = \"https://github.com/topics/deep-learning?page=\" allowed_domains = \"https://github.com\" print(\"\\n------------start grabbing all urls--------------------------\\n\") for i in range(1, 35): try: html = requests.get(base_url+str(i), headers=headers_raw_page, proxies=proxies, timeout= timeoutSec) except Exception as e: print(e) print('fail to get request from ip via proxy') soup = BeautifulSoup(html.text, \"html.parser\") # print(soup.prettify()) # urls = soup.find_all(\"a\", {'class': 'text-bold'}) for j in soup.find_all(\"a\", {'class': 'text-bold'}): start_urls.append(allowed_domains + j['href']) print(allowed_domains + j['href']) time.sleep(1.5) ","date":"2021-05-04","objectID":"/python_spider_experience_instruct_github_repos/:4:2","tags":["Python","Spider","Github","Repository"],"title":"Python 爬蟲實戰教學 - Github 倉庫特徵爬取","uri":"/python_spider_experience_instruct_github_repos/"},{"categories":["Python"],"content":"細爬每個倉庫特徵 由於我們一開始爬的倉庫特徵並不是很夠，我們需要去細爬我們每個倉庫的更多數據特徵，接著我們根據 start_url 存的內容去爬取需要的倉庫細節。 觀察單個倉庫的頁面元素repository_html.png \" 觀察單個倉庫的頁面元素 print(start_urls) print(\"The data length: \", len(start_urls), \"\\n\") result = [] labels = ['name', 'star', 'commits', 'fork', 'issues', 'pull_requests', 'branches', 'tags'] print(\"\\n------------start grabbing data--------------------------\\n\") time.sleep(1.5) i = 1 for url in start_urls: try: html = requests.get(url, headers=headers, proxies=proxies, timeout= timeoutSec) except Exception as e: print(e) print('fail to get request from ip via proxy') # print(html) soup = BeautifulSoup(html.text, \"html.parser\") # star = soup.findall(\"a\", text=\"starred\") # print(soup.prettify()) item = {} item['name'] = url print(\"all: \", len(start_urls), \"index \", i, \", start: \", item['name']) i+=1 num = soup.find_all(\"a\", {'class': 'social-count'}) # print(num) # print('\\n') item['star'] = num[0] item['fork'] = num[1] num = soup.find_all(\"span\", {'class': 'd-none d-sm-inline'}) # print('\\n') # print(num) if(len(num) == 2): item['commits'] = num[1] else: item['commits'] = num[0] num = soup.find_all(\"span\", {'class': 'Counter'}) # print('\\n') # print(num) item['issues'] = num[1] item['pull_requests'] = num[2] # item['contributors'] = num[7] # item['projects'] = num[4] # item['security'] = num[5] num = soup.find_all(\"a\", {'class': 'Link--primary no-underline'}) # print('\\n') # print(num) item['branches'] = num[0] # item['release'] = num[1] # item['used_by'] = num[3] # num = soup.find_all(\"span\", {'class': 'Counter'}) # item['contributors'] = num[4] num = soup.find_all(\"a\", {'class': 'ml-3 Link--primary no-underline'}) # print('\\n') # print(num) item['tags'] = num[0] print(\"end\", item['name'], \"\\n\") # print(\"\\n\", item['commits']) result.append(item) time.sleep(1.5) ","date":"2021-05-04","objectID":"/python_spider_experience_instruct_github_repos/:4:3","tags":["Python","Spider","Github","Repository"],"title":"Python 爬蟲實戰教學 - Github 倉庫特徵爬取","uri":"/python_spider_experience_instruct_github_repos/"},{"categories":["Python"],"content":"存成 CSV 我們接下來根據 labels 去存成 CSV 文件。 print(\"\\n------------start saving data as csv--------------------------\\n\") try: with open('csv_dct.csv', 'w') as f: writer = csv.DictWriter(f, fieldnames=labels) writer.writeheader() for elem in result: writer.writerow(elem) print(\"save success\") except IOError: print(\"I/O error\") ","date":"2021-05-04","objectID":"/python_spider_experience_instruct_github_repos/:4:4","tags":["Python","Spider","Github","Repository"],"title":"Python 爬蟲實戰教學 - Github 倉庫特徵爬取","uri":"/python_spider_experience_instruct_github_repos/"},{"categories":["Python"],"content":"第二部份 - Github API ","date":"2021-05-04","objectID":"/python_spider_experience_instruct_github_repos/:5:0","tags":["Python","Spider","Github","Repository"],"title":"Python 爬蟲實戰教學 - Github 倉庫特徵爬取","uri":"/python_spider_experience_instruct_github_repos/"},{"categories":["Python"],"content":"確定爬取需求 我們需要的是各語言的熱門 repository，每個倉庫的最終 name、language、stargzers、forks、open_issues、watchers、readme，以按照月份變化(2020.03 ~2021.03)的 commits、pull requests、forks、issues events。 為了求方便 我們需要使用 GIthub 提供的 API 進行爬取，然而 Readme 部分需要去爬取原生的 HTML 頁面。 確定爬取後需要分成三張表，基本數據 gitub_basic.csv；月變化數據 github_commits.csv、github_pull_requests.csv。(後面因為 forks 和 issues 的樂變化數據爬取過多，拖長每個 repo 的數據處理進度，導致平均一個 repo 需要爬取 8 mins 左右，所以棄掉這兩項月變化數據) ","date":"2021-05-04","objectID":"/python_spider_experience_instruct_github_repos/:5:1","tags":["Python","Spider","Github","Repository"],"title":"Python 爬蟲實戰教學 - Github 倉庫特徵爬取","uri":"/python_spider_experience_instruct_github_repos/"},{"categories":["Python"],"content":"先查看 Github API 我們先查看 Github 提供的 API 文檔。 Github REST APIgithub_rest_api_docs.png \" Github REST API 我們首先需要用到的 API 是 Search 裡面的 https://api.github.com/search/repositories。 Github api listgithub_api_list.png \" Github api list 我們先測試一下 API： 你也可以使用 Postman 去做測試，因為有時回傳值太長了，終端機直接砍掉前面部份。 Github API 測試github_api_test.png \" Github API 測試 ","date":"2021-05-04","objectID":"/python_spider_experience_instruct_github_repos/:5:2","tags":["Python","Spider","Github","Repository"],"title":"Python 爬蟲實戰教學 - Github 倉庫特徵爬取","uri":"/python_spider_experience_instruct_github_repos/"},{"categories":["Python"],"content":"確定特徵 因為我們使用 Github API 回傳的數據特徵已經有 name language stargazers forks open_issues watchers 以及各種請求 URL（作為後面爬取各），雖然特徵沒有第一部份爬取 HTML 頁面的數據特徵多，但作為數據分析特徵夠了。 ","date":"2021-05-04","objectID":"/python_spider_experience_instruct_github_repos/:5:3","tags":["Python","Spider","Github","Repository"],"title":"Python 爬蟲實戰教學 - Github 倉庫特徵爬取","uri":"/python_spider_experience_instruct_github_repos/"},{"categories":["Python"],"content":"編寫爬取類 編寫爬蟲類的成員變量，與構造函數。並且使用 Github search repositories 的 API 分別，總共的語言有 python、java、golang、js。 其中 repositories: 爬取的 repo basic_table: repo 的基本特徵 commits_table: 每個 repo 的 commits 月變化數據 pull_requests_table: 每個 repo 的 pull requests月變化數據 forks_table: 每個 repo 的 forks月變化數據 issues_table: 每個 repo 的 issues月變化數據 basic_url: 根據爬取語言熱門 repos 的爬取 api basic_labels: basic_table 存成 csv 文件的標籤 template_labels: 月變化數據存成 csv 文件的標籤 template_table: 月變化數據初始化賦值模板 class github_grab(object): def __init__(self): self.repositories = [] self.basic_table = [] self.commits_table = [] self.pull_requests_table = [] self.forks_table = [] self.issues_table = [] self.base_url = [ \"https://api.github.com/search/repositories?q=language:python\u0026sort=stars\", \"https://api.github.com/search/repositories?q=language:java\u0026sort=stars\", \"https://api.github.com/search/repositories?q=language:c\u0026sort=stars\", \"https://api.github.com/search/repositories?q=language:golang\u0026sort=stars\", \"https://api.github.com/search/repositories?q=language:js\u0026sort=stars\" ] self.basic_labels = [ 'name', 'language', 'stargazers' , 'forks', 'open_issues', 'watchers', 'readme' ] # commits pull_requests forks issues_events self.template_labels = [ 'name', '2019_01', '2019_02', '2019_03', '2019_04', '2019_05', '2019_06', '2019_07', '2019_08', '2019_09', '2019_10', '2019_11', '2019_12', '2020_01', '2020_02', '2020_03', '2020_04', '2020_05', '2020_06', '2020_07', '2020_08', '2020_09', '2020_10', '2020_11', '2020_12', '2021_01', '2021_02', '2021_03' ] self.template_table = { 'name': '', '2020_03': 0, '2020_04': 0, '2020_05': 0, '2020_06': 0, '2020_07': 0, '2020_08': 0, '2020_09': 0, '2020_10': 0, '2020_11': 0, '2020_12': 0, '2021_01': 0, '2021_02': 0, '2021_03': 0 } ","date":"2021-05-04","objectID":"/python_spider_experience_instruct_github_repos/:5:4","tags":["Python","Spider","Github","Repository"],"title":"Python 爬蟲實戰教學 - Github 倉庫特徵爬取","uri":"/python_spider_experience_instruct_github_repos/"},{"categories":["Python"],"content":"爬取我們需要的所有熱門倉庫 根據爬取類的 baseURL 遍歷請求，由於怕數據量太大，爬取過久，所以我們每個語言的熱門倉庫只爬取 40 個，總共會爬取 200 個倉庫。每次請求都需要設定如果爬取回來的狀態碼如果是 403，則需要等待 1 分鐘繼續爬取，如果是 404 或是 204 則代表資源不存在。 class github_grab(object): # ... def get_all_repositories(self): print(\"\\n------------start grabbing all repositories--------------------------\\n\") index = 1 for url in self.base_url: print(\"\\nbase url : \" + url + \"\\n\") for i in range(1, 5): try: req = requests.get(url + \"\u0026page=\" + str(i) + \"\u0026per_page=100\", headers=headers, proxies=proxies, timeout=timeoutSec) if(req.status_code == 403): print(\"Rate limit, sleep 60 sec\") time.sleep(60) i -= 1 continue elif(req.status_code == 404 or req.status_code == 204): print('The source is not found') continue items = req.json()['items'] # temp = json.loads(req) # print(type(req)) print(\"req len \" + str(len(items))) self.repositories += items print('grab page ' + str(index) + ', current repository quantity : ' + str(len(self.repositories))) index += 1 # print(self.repositories) except Exception as e: print(e) print('fail to get request from ip via proxy') # sleep # time.sleep(2) ","date":"2021-05-04","objectID":"/python_spider_experience_instruct_github_repos/:5:5","tags":["Python","Spider","Github","Repository"],"title":"Python 爬蟲實戰教學 - Github 倉庫特徵爬取","uri":"/python_spider_experience_instruct_github_repos/"},{"categories":["Python"],"content":"編寫 Readme 爬取方法 由於每個倉庫的 readme 的文件名都不一樣，所以我只要以文件名是 readme 或 README，文件類型是 *.md 或 *.rst，如果還有其它的命名方式，我們可以認為該倉庫的文件命名不規範，不需加入考量。這裡的爬取使用 BS4。 class github_grab(object): # ... def get_repository_readme(self, url): print(\"start to get \" + url + \" readme\") try: req = requests.get(\"https://github.com/\" + url + \"/blob/master/README.md\", headers=headers_raw_page, proxies=proxies, timeout=timeoutSec) if(req.status_code == 403): print(\"Rate limit, sleep 60 sec\") time.sleep(60) req = requests.get(\"https://github.com/\" + url + \"/blob/master/README.md\", headers=headers_raw_page, proxies=proxies, timeout=timeoutSec) elif(req.status_code == 404 or req.status_code == 204): print('The source is not found') # print(type(req)) soup = BeautifulSoup(req.text.replace('\\n', ''), \"html.parser\") num = soup.find_all(\"div\", {'id': 'readme'}) # print(req) # print(\"req len \" + str(len(req))) # time.sleep(2) return num[0] if len(num) \u003e= 1 else \"\" except Exception as e: print(e) print('fail to get request from ip via proxy') ","date":"2021-05-04","objectID":"/python_spider_experience_instruct_github_repos/:5:6","tags":["Python","Spider","Github","Repository"],"title":"Python 爬蟲實戰教學 - Github 倉庫特徵爬取","uri":"/python_spider_experience_instruct_github_repos/"},{"categories":["Python"],"content":"編寫處理所有的 repo 方法 由於我們在前面在 get_all_repositories 類方法已經將很多基本數據爬下來，所以我們 basic 部分不需要進一步爬取，月變化數據需要另外寫類方法處理。 class github_grab(object): # ... def deal_with_repositories(self): print(\"-------------------start to deal with repo\\'s data----------------------\\n\") i = 1 for repo in self.repositories: print('deal with the ' + str(i) + ' / ' + str(len(self.repositories)) + \" \" + repo['full_name']) i += 1 # basic_table basic_temp = {} basic_temp['name'] = repo['full_name'] basic_temp['stargazers'] = repo['stargazers_count'] basic_temp['watchers'] = repo['watchers_count'] basic_temp['language'] = repo['language'] basic_temp['forks'] = repo['forks_count'] basic_temp['open_issues'] = repo['open_issues'] basic_temp['readme'] = self.get_repository_readme( repo['full_name']) self.basic_table.append(basic_temp) # commits_table # init use copy temp = self.template_table.copy() # print('init temp') # print(temp) temp['name'] = repo['full_name'] temp = self.get_repository_commits(temp) # print(temp) self.commits_table.append(temp) # print(\"-----\") # print(self.commits_table) # print(\"----\") # pull request temp = self.template_table.copy() temp['name'] = repo['full_name'] temp = self.get_repository_pull_requests(temp) self.pull_requests_table.append(temp) # # forks # temp = self.template_table.copy() # temp['name'] = repo['full_name'] # temp = self.get_repository_forks(temp) # self.forks_table.append(temp) # # issues_events # temp = self.template_table.copy() # temp['name'] = repo['full_name'] # temp = self.get_repository_issues(temp) # self.issues_table.append(temp) ","date":"2021-05-04","objectID":"/python_spider_experience_instruct_github_repos/:5:7","tags":["Python","Spider","Github","Repository"],"title":"Python 爬蟲實戰教學 - Github 倉庫特徵爬取","uri":"/python_spider_experience_instruct_github_repos/"},{"categories":["Python"],"content":"編寫月份分類方法 因為我們的月份分得較死，一時沒想到怎麼封裝，所以寫起來又臭又長。 class github_grab(object): # ... def date_classify(self, temp, date_time): # print(date_time) if(\"2021-03-01T00:00:00Z\" \u003c= date_time and date_time \u003c \"2021-04-01T00:00:00Z\"): temp['2021_03'] += 1 elif(\"2021-02-01T00:00:00Z\" \u003c= date_time and date_time \u003c \"2021-03-01T00:00:00Z\"): temp['2021_02'] += 1 elif(\"2021-01-01T00:00:00Z\" \u003c= date_time and date_time \u003c \"2021-02-01T00:00:00Z\"): temp['2021_01'] += 1 elif(\"2020-12-01T00:00:00Z\" \u003c= date_time and date_time \u003c \"2021-01-01T00:00:00Z\"): temp['2020_12'] += 1 elif(\"2020-11-01T00:00:00Z\" \u003c= date_time and date_time \u003c \"2020-12-01T00:00:00Z\"): temp['2020_11'] += 1 elif(\"2020-10-01T00:00:00Z\" \u003c= date_time and date_time \u003c \"2020-11-01T00:00:00Z\"): temp['2020_10'] += 1 elif(\"2020-09-01T00:00:00Z\" \u003c= date_time and date_time \u003c \"2020-10-01T00:00:00Z\"): temp['2020_09'] += 1 elif(\"2020-08-01T00:00:00Z\" \u003c= date_time and date_time \u003c \"2020-09-01T00:00:00Z\"): temp['2020_08'] += 1 elif(\"2020-07-01T00:00:00Z\" \u003c= date_time and date_time \u003c \"2020-08-01T00:00:00Z\"): temp['2020_07'] += 1 elif(\"2020-06-01T00:00:00Z\" \u003c= date_time and date_time \u003c \"2020-07-01T00:00:00Z\"): temp['2020_06'] += 1 elif(\"2020-05-01T00:00:00Z\" \u003c= date_time and date_time \u003c \"2020-06-01T00:00:00Z\"): temp['2020_05'] += 1 elif(\"2020-04-01T00:00:00Z\" \u003c= date_time and date_time \u003c \"2020-05-01T00:00:00Z\"): temp['2020_04'] += 1 elif(\"2020-03-01T00:00:00Z\" \u003c= date_time and date_time \u003c \"2020-04-01T00:00:00Z\"): temp['2020_03'] += 1 return temp ","date":"2021-05-04","objectID":"/python_spider_experience_instruct_github_repos/:5:8","tags":["Python","Spider","Github","Repository"],"title":"Python 爬蟲實戰教學 - Github 倉庫特徵爬取","uri":"/python_spider_experience_instruct_github_repos/"},{"categories":["Python"],"content":"編寫單個 repo 月份 commits 變化 這裡主要就是需要注意要先自己使用 Postman 或是命令指令行試著請求看，檢查回傳的查詢結果的結構，還有時間的判斷，後面的月份變化爬取也是差不多這樣。 class github_grab(object): # ... def get_repository_commits(self, commits_temp): print(\"start to get \" + commits_temp['name'] + \" commits\\'data\") try: for i in range(1, 100000): req = requests.get(\"https://api.github.com/repos/\" + commits_temp['name'] + \"/commits?per_page=100\u0026page=\" + str(i), headers=headers, proxies=proxies, timeout=timeoutSec) if(req.status_code == 403): print(\"Rate limit, sleep 60 sec\") time.sleep(60) i -= 1 continue elif(req.status_code == 404 or req.status_code == 204): print('The source is not found') continue # print(\"commits times\" + str(i)) items = req.json() # if no data if len(items) == 0: break # if the time is too older if(items[0]['commit']['author']['date'] \u003c \"2020-03-01T00:00:00Z\"): break if(items[-1]['commit']['author']['date'] \u003e \"2021-04-01T00:00:00Z\"): continue for date_time in items: if(date_time['commit']['author']['date'] \u003c \"2020-03-01T00:00:00Z\"): break commits_temp = self.date_classify( commits_temp, date_time['commit']['author']['date']) # time.sleep(2) return commits_temp except Exception as e: print(e) print('fail to get request from ip via proxy') ","date":"2021-05-04","objectID":"/python_spider_experience_instruct_github_repos/:5:9","tags":["Python","Spider","Github","Repository"],"title":"Python 爬蟲實戰教學 - Github 倉庫特徵爬取","uri":"/python_spider_experience_instruct_github_repos/"},{"categories":["Python"],"content":"編寫單個 repo 月份 pull requests 變化 class github_grab(object): # ... def get_repository_pull_requests(self, pr_temp): print(\"start to get \" + pr_temp['name'] + \" pull requests\\'data\") try: for i in range(1, 100000): req = requests.get(\"https://api.github.com/repos/\" + pr_temp['name'] + \"/pulls?per_page=100\u0026page=\" + str(i), headers=headers, proxies=proxies, timeout=timeoutSec) if(req.status_code == 403): print(\"Rate limit, sleep 60 sec\") time.sleep(60) i -= 1 continue elif(req.status_code == 404 or req.status_code == 204): print('The source is not found') continue items = req.json() # if no data if len(items) == 0: break # if the time is too older if(items[0]['created_at'] \u003c \"2020-03-01T00:00:00Z\"): break if(items[-1]['created_at'] \u003e \"2021-04-01T00:00:00Z\"): continue for date_time in items: # print(date_time['created_at']) if(date_time['created_at'] \u003c \"2020-03-01T00:00:00Z\"): break pr_temp = self.date_classify( pr_temp, date_time['created_at']) # time.sleep(2) return pr_temp except Exception as e: print(e) print('fail to get request from ip via proxy') ","date":"2021-05-04","objectID":"/python_spider_experience_instruct_github_repos/:5:10","tags":["Python","Spider","Github","Repository"],"title":"Python 爬蟲實戰教學 - Github 倉庫特徵爬取","uri":"/python_spider_experience_instruct_github_repos/"},{"categories":["Python"],"content":"編寫單個 repo 月份 forks 變化 雖然最後沒有用到這個類方法，但還是將代碼放出來。 class github_grab(object): # ... def get_repository_forks(self, forks_temp): print(\"start to get \" + forks_temp['name'] + \" forks\\'data\") try: for i in range(1, 100000): req = requests.get(\"https://api.github.com/repos/\" + forks_temp['name'] + \"/forks?per_page=100\u0026page=\" + str(i), headers=headers, proxies=proxies, timeout=timeoutSec) if(req.status_code == 403): print(\"Rate limit, sleep 60 sec\") time.sleep(60) i -= 1 continue elif(req.status_code == 404 or req.status_code == 204): print('The source is not found') continue items = req.json() # print(\"forks times\" + str(i)) # if no data if len(items) == 0: break # if the time is too older if(items[0]['created_at'] \u003c \"2020-03-01T00:00:00Z\"): break if(items[-1]['created_at'] \u003e \"2021-04-01T00:00:00Z\"): continue for date_time in items: # print(date_time['created_at']) if(date_time['created_at'] \u003c \"2020-03-01T00:00:00Z\"): break forks_temp = self.date_classify( forks_temp, date_time['created_at']) # time.sleep(2) return forks_temp except Exception as e: print(e) print('fail to get request from ip via proxy') ","date":"2021-05-04","objectID":"/python_spider_experience_instruct_github_repos/:5:11","tags":["Python","Spider","Github","Repository"],"title":"Python 爬蟲實戰教學 - Github 倉庫特徵爬取","uri":"/python_spider_experience_instruct_github_repos/"},{"categories":["Python"],"content":"編寫單個 repo 月份 issues 變化 class github_grab(object): # ... def get_repository_issues(self, issues_temp): print(\"start to get \" + issues_temp['name'] + \" issues\\'data\") try: for i in range(1, 100000): req = requests.get(\"https://api.github.com/repos/\" + issues_temp['name'] + \"/issues/events?per_page=100\u0026page=\" + str(i), headers=headers, proxies=proxies, timeout=timeoutSec) if(req.status_code == 403): print(\"Rate limit, sleep 60 sec\") time.sleep(60) i -= 1 continue elif(req.status_code == 404 or req.status_code == 204): print('The source is not found') continue items = req.json() # if no data if len(items) == 0: break # if the time is too older if(items[0]['created_at'] \u003c \"2020-03-01T00:00:00Z\"): break if(items[-1]['created_at'] \u003e \"2021-04-01T00:00:00Z\"): continue for date_time in items: # print(date_time['created_at']) if(date_time['created_at'] \u003c \"2020-03-01T00:00:00Z\"): break issues_temp = self.date_classify( issues_temp, date_time['created_at']) # time.sleep(2) return issues_temp except Exception as e: print(e) print('fail to get request from ip via proxy') ","date":"2021-05-04","objectID":"/python_spider_experience_instruct_github_repos/:5:12","tags":["Python","Spider","Github","Repository"],"title":"Python 爬蟲實戰教學 - Github 倉庫特徵爬取","uri":"/python_spider_experience_instruct_github_repos/"},{"categories":["Python"],"content":"將所有的數據從成 CSV 文件 分別有三個 *.csv 文件，github_basic.csv 是基本的 repo 數據，其它兩個是月變化數據。這裡需要注意的是編碼方式要使用 utf-8，因為 readme 有很多中文字，如果不使用 utf-8，會報存儲錯誤。 def save_all_to_csv(self): self.save_as_csv(\"github_basic.csv\", self.basic_labels, self.basic_table) self.save_as_csv(\"github_commits.csv\", self.template_labels, self.commits_table) self.save_as_csv(\"github_pull_requests.csv\", self.template_labels, self.pull_requests_table) # self.save_as_csv(\"github_forks.csv\", self.template_labels, self.forks_table) # self.save_as_csv(\"github_issues.csv\", self.template_labels, self.issues_table) def save_as_csv(self, fileName, labels, table): print(\"\\n------------start saving data as csv--------------------------\\n\") # save csv try: with open(fileName, 'w') as f: writer = csv.DictWriter(f, fieldnames=labels) writer.writeheader() for elem in table: writer.writerow(elem) print(\"save \" + fileName + \" success\") except IOError: print(\"I/O error\") ","date":"2021-05-04","objectID":"/python_spider_experience_instruct_github_repos/:5:13","tags":["Python","Spider","Github","Repository"],"title":"Python 爬蟲實戰教學 - Github 倉庫特徵爬取","uri":"/python_spider_experience_instruct_github_repos/"},{"categories":["Python"],"content":"編寫 main 函數 if __name__ == \"__main__\": github = github_grab() github.get_all_repositories() print(\"repo len \" + str(len(github.repositories))) github.deal_with_repositories() # print(github.basic_table) # print(github.commits_table) # print(github.pull_requests_table) # print(github.forks_table) # print(github.issues_table) github.save_all_to_csv() ","date":"2021-05-04","objectID":"/python_spider_experience_instruct_github_repos/:5:14","tags":["Python","Spider","Github","Repository"],"title":"Python 爬蟲實戰教學 - Github 倉庫特徵爬取","uri":"/python_spider_experience_instruct_github_repos/"},{"categories":["Python"],"content":"確認結果 執行文件確認運行結果。 運行結果github_part2_result.png \" 運行結果 ","date":"2021-05-04","objectID":"/python_spider_experience_instruct_github_repos/:5:15","tags":["Python","Spider","Github","Repository"],"title":"Python 爬蟲實戰教學 - Github 倉庫特徵爬取","uri":"/python_spider_experience_instruct_github_repos/"},{"categories":["Python"],"content":"補充 ","date":"2021-05-04","objectID":"/python_spider_experience_instruct_github_repos/:6:0","tags":["Python","Spider","Github","Repository"],"title":"Python 爬蟲實戰教學 - Github 倉庫特徵爬取","uri":"/python_spider_experience_instruct_github_repos/"},{"categories":["Python"],"content":"Javascript 的指針問題 因為我在賦值 dict 對象時，發現如果只是普通的用 = 去賦值會導致指針問題，必須使用 dict 對象的 copy() 方法。 temp = self.template_table.copy() ","date":"2021-05-04","objectID":"/python_spider_experience_instruct_github_repos/:6:1","tags":["Python","Spider","Github","Repository"],"title":"Python 爬蟲實戰教學 - Github 倉庫特徵爬取","uri":"/python_spider_experience_instruct_github_repos/"},{"categories":["Python"],"content":"結語 源碼 這次的機器學習與數據挖掘的實驗我負責爬蟲的部分，由於一開始我沒有爬月變化的數據特徵，所以導致全組都在等我重新爬取新的數據，也在合作過程中發現自己的缺失，這次的工作分配讓我學到很多數據爬取的技巧，感謝大家的分工合作，最後完成了小組項目。 ","date":"2021-05-04","objectID":"/python_spider_experience_instruct_github_repos/:7:0","tags":["Python","Spider","Github","Repository"],"title":"Python 爬蟲實戰教學 - Github 倉庫特徵爬取","uri":"/python_spider_experience_instruct_github_repos/"},{"categories":["Moment"],"content":"前言 因為 2021/03 月份我已經是大三了，我開始在春招找實習 Offer，在找實習的期間我在牛課網以及各大平台的面經驗分享中整理出一份八文面試題，整理的過程整整花了我將近一週的時間，希望我整理的內容對各位有幫助。 註：這篇文章是針對 C/C++ 崗位的面試題，數據結構、算法、操作系統、計算機網路、數據庫對大部分崗位是通用的。 ","date":"2021-05-03","objectID":"/cs_interview_eight_part_questions/:1:0","tags":["互聯網","大廠","面試題","計算機網路","操作系統","Database","數據結構","演算法","MySQL","C","C++","LeetCode","CS","計算機科學","軟件工程"],"title":"互聯網公司大廠 – 面試八股文彙整","uri":"/cs_interview_eight_part_questions/"},{"categories":["Moment"],"content":"重要度 重要性: 語言基礎 \u003e= 數據結構 == 算法 \u003e 操作系統 \u003e 計算機網路 \u003e 數據庫 \u003e= 機器學習 ","date":"2021-05-03","objectID":"/cs_interview_eight_part_questions/:2:0","tags":["互聯網","大廠","面試題","計算機網路","操作系統","Database","數據結構","演算法","MySQL","C","C++","LeetCode","CS","計算機科學","軟件工程"],"title":"互聯網公司大廠 – 面試八股文彙整","uri":"/cs_interview_eight_part_questions/"},{"categories":["Moment"],"content":"語言基礎 ","date":"2021-05-03","objectID":"/cs_interview_eight_part_questions/:3:0","tags":["互聯網","大廠","面試題","計算機網路","操作系統","Database","數據結構","演算法","MySQL","C","C++","LeetCode","CS","計算機科學","軟件工程"],"title":"互聯網公司大廠 – 面試八股文彙整","uri":"/cs_interview_eight_part_questions/"},{"categories":["Moment"],"content":"C++ 三大特性 封装性是基础，继承性是关键，多态性是补充，并且多态性存在于继承的环境中。 C++语言中支持数据封装，类是支持数据封装的工具，对象是数据封装的实现。 在封装中，还提供一种对数据访问的控制机制，使得一些数据被隐藏在封装体内，因此具有隐藏性。 ","date":"2021-05-03","objectID":"/cs_interview_eight_part_questions/:3:1","tags":["互聯網","大廠","面試題","計算機網路","操作系統","Database","數據結構","演算法","MySQL","C","C++","LeetCode","CS","計算機科學","軟件工程"],"title":"互聯網公司大廠 – 面試八股文彙整","uri":"/cs_interview_eight_part_questions/"},{"categories":["Moment"],"content":"封裝、繼承、多態，簡單說明 封装性:把客观事物封装成抽象的类，并且类可以把自己的数据和方法只让可信的类或者对象操作，对不可信的进行信息隐藏。 类将成员变量和成员函数封装在类的内部，根据需要设置访问权限，通过成员函数管理内部状态。 class Person { private://数据私有 string bame; int num; public://方法公有 void getName() { return name; } }; 繼承:继承所表达的是类之间相关的关系，这种关系使得对象可以继承另外一类对象的特征和能力。 继承的作用：避免公用代码的重复开发，减少代码和数据冗余。 #include \u003ciostream\u003e using namespace std; class Base { public: void printBase(void) { cout\u003c\u003c\"Base中的printBase\"\u003c\u003cendl; } }; class Son:public Base { }; int main(int argc, char *argv[]) { Son ob; ob.printBase(); return 0; } 多態:多态性可以简单地概括为“一个接口，多种方法”，字面意思为多种形态。程序在运行时才决定调用的函数，它是面向对象编程领域的核心概念。比如函数重载、运算符重载、虚函数等。 #include \u003ciostream\u003e using namespace std; class Base { public: virtual void printMsg(void) { cout\u003c\u003c\"Base中的printMsg\"\u003c\u003cendl; } }; class Son:public Base { public: virtual void printMsg(void) { cout\u003c\u003c\"Son中的printMsg\"\u003c\u003cendl; } }; int main(int argc, char *argv[]) { Base *p = new Son; p-\u003eprintMsg(); return 0; } ","date":"2021-05-03","objectID":"/cs_interview_eight_part_questions/:3:2","tags":["互聯網","大廠","面試題","計算機網路","操作系統","Database","數據結構","演算法","MySQL","C","C++","LeetCode","CS","計算機科學","軟件工程"],"title":"互聯網公司大廠 – 面試八股文彙整","uri":"/cs_interview_eight_part_questions/"},{"categories":["Moment"],"content":"引用和指针的区别 指针从本质上讲就是存放变量地址的一个变量，在逻辑上是独立的，它可以被改变，包括其所指向的地址的改变和其指向的地址中所存放的数据的改变。 而引用是一个别名，它在逻辑上不是独立的，它的存在具有依附性，所以引用必须在一开始就被初始化，而且其引用的对象在其整个生命周期中是不能被改变的（自始至终只能依附于同一个变量）。 ","date":"2021-05-03","objectID":"/cs_interview_eight_part_questions/:3:3","tags":["互聯網","大廠","面試題","計算機網路","操作系統","Database","數據結構","演算法","MySQL","C","C++","LeetCode","CS","計算機科學","軟件工程"],"title":"互聯網公司大廠 – 面試八股文彙整","uri":"/cs_interview_eight_part_questions/"},{"categories":["Moment"],"content":"智能指针有哪些 C++ 标准模板库STL（Standard Template Library） 一共给我们提供了四种智能指针：auto_ptr、unique_ptr、shared_ptr 和weak_ptr，其中auto_ptr 是C++98 提出的，C++11 已将其摒弃，并提出了unique_ptr 替代auto_ptr。 ","date":"2021-05-03","objectID":"/cs_interview_eight_part_questions/:3:4","tags":["互聯網","大廠","面試題","計算機網路","操作系統","Database","數據結構","演算法","MySQL","C","C++","LeetCode","CS","計算機科學","軟件工程"],"title":"互聯網公司大廠 – 面試八股文彙整","uri":"/cs_interview_eight_part_questions/"},{"categories":["Moment"],"content":"智能指针的实现原理 智能指针将一个计数器与类指向的对象相关联，引用计数跟踪共有多少个类对象共享同一指针，每次创建类的新对象时，初始化指针并将引用计数置为1. 当对象作为另一对象的副本而创建时，拷贝构造函数拷贝指针并增加与之相应的引用计数。 ","date":"2021-05-03","objectID":"/cs_interview_eight_part_questions/:3:5","tags":["互聯網","大廠","面試題","計算機網路","操作系統","Database","數據結構","演算法","MySQL","C","C++","LeetCode","CS","計算機科學","軟件工程"],"title":"互聯網公司大廠 – 面試八股文彙整","uri":"/cs_interview_eight_part_questions/"},{"categories":["Moment"],"content":"使用智能指针可能发生内存泄漏吗，如何解决 會。 这里在 C++11 前有的是 auto_ptr，它是怎么做的呢？ 利用auto_ptr声明一个智能指针p1并且指向一个内存地址，再次调用生成一个智能指针p2，无指向。p2=p1，此时不会报错，但是我们调用p1是不对的，因为他已经赋值给p2了，也就是说他成了个野指针，这样就产生了内存泄漏的可能。 因此在c++11中引入unique_ptr的概念，重复上述操作，但是他要求一段内存地址同一时间仅能有一个智能指针指向，因此p2=p1就会报错，这样就可以防止p1赋值给p2成为野指针带来的潜在危险，即内存泄漏。 ","date":"2021-05-03","objectID":"/cs_interview_eight_part_questions/:3:6","tags":["互聯網","大廠","面試題","計算機網路","操作系統","Database","數據結構","演算法","MySQL","C","C++","LeetCode","CS","計算機科學","軟件工程"],"title":"互聯網公司大廠 – 面試八股文彙整","uri":"/cs_interview_eight_part_questions/"},{"categories":["Moment"],"content":"new 和 malloc 的区别 屬性: new/delete是C++关键字，需要编译器支持。malloc/free是库函数，需要头文件支持。 參數: 使用new操作符申请内存分配时无须指定内存块的大小，编译器会根据类型信息自行计算。而malloc则需要显式地指出所需内存的尺寸。 返回类型: new操作符内存分配成功时，返回的是对象类型的指针，类型严格与对象匹配，无须进行类型转换，故new是符合类型安全性的操作符。而malloc内存分配成功则是返回void * ，需要通过强制类型转换将void*指针转换成我们需要的类型。 分配失败: new内存分配失败时，会抛出bac_alloc异常。malloc分配内存失败时返回NULL。 自定义类型: new会先调用operator new函数，申请足够的内存（通常底层使用malloc实现）。然后调用类型的构造函数，初始化成员变量，最后返回自定义类型指针。delete先调用析构函数，然后调用operator delete函数释放内存（通常底层使用free实现）。 malloc/free是库函数，只能动态的申请和释放内存，无法强制要求其做自定义类型对象构造和析构工作。 重载: C++允许重载new/delete操作符，特别的，布局new的就不需要为对象分配内存，而是指定了一个地址作为内存起始区域，new在这段内存上为对象调用构造函数完成初始化工作，并返回此地址。而malloc不允许重载。 内存区域: new操作符从自由存储区（free store）上为对象动态分配内存空间，而malloc函数从堆上动态分配内存。自由存储区是C++基于new操作符的一个抽象概念，凡是通过new操作符进行内存申请，该内存即为自由存储区。而堆是操作系统中的术语，是操作系统所维护的一块特殊内存，用于程序的内存动态分配，C语言使用malloc从堆上分配内存，使用free释放已分配的对应内存。自由存储区不等于堆，如上所述，布局new就可以不位于堆中。 ","date":"2021-05-03","objectID":"/cs_interview_eight_part_questions/:3:7","tags":["互聯網","大廠","面試題","計算機網路","操作系統","Database","數據結構","演算法","MySQL","C","C++","LeetCode","CS","計算機科學","軟件工程"],"title":"互聯網公司大廠 – 面試八股文彙整","uri":"/cs_interview_eight_part_questions/"},{"categories":["Moment"],"content":"静态成员函数和普通函数的区别 类的静态成员(变量和方法)属于类本身，在类加载的时候就会分配内存，可以通过类名直接去访问；非静态成员（变量和方法）属于类的对象，所以只有在类的对象产生（创建类的实例）时才会分配内存，然后通过类的对象（实例）去访问。 静态函数只有当程序结束的时候才从内存消失。而非静态则是动态加载到内存，不需要的时候就从内存消失。 据个例子，调用类中的静态函数，你不需要创建对象就可以调用。而对于非静态的函数，你必须要先创建对象，才能够由对象调用。 ","date":"2021-05-03","objectID":"/cs_interview_eight_part_questions/:3:8","tags":["互聯網","大廠","面試題","計算機網路","操作系統","Database","數據結構","演算法","MySQL","C","C++","LeetCode","CS","計算機科學","軟件工程"],"title":"互聯網公司大廠 – 面試八股文彙整","uri":"/cs_interview_eight_part_questions/"},{"categories":["Moment"],"content":"静态成员函数和普通的静态函数的区别，可以通过对象实例访问吗 如上，静态成员函数無法透過對象實例訪問，普通的静态函数可以透過對象實例訪問。 ","date":"2021-05-03","objectID":"/cs_interview_eight_part_questions/:3:9","tags":["互聯網","大廠","面試題","計算機網路","操作系統","Database","數據結構","演算法","MySQL","C","C++","LeetCode","CS","計算機科學","軟件工程"],"title":"互聯網公司大廠 – 面試八股文彙整","uri":"/cs_interview_eight_part_questions/"},{"categories":["Moment"],"content":"C++ 的内存管理 這個問題有難度，可以說很難，…看以下知乎回答 https://zhuanlan.zhihu.com/p/51855842 ","date":"2021-05-03","objectID":"/cs_interview_eight_part_questions/:3:10","tags":["互聯網","大廠","面試題","計算機網路","操作系統","Database","數據結構","演算法","MySQL","C","C++","LeetCode","CS","計算機科學","軟件工程"],"title":"互聯網公司大廠 – 面試八股文彙整","uri":"/cs_interview_eight_part_questions/"},{"categories":["Moment"],"content":"什么是多态，实现多态的机制 虚函数是C++中用于实现多态(polymorphism)的机制。 核心理念就是通过基类访问派生类定义的函数。 多态性指相同对象收到不同消息或不同对象收到相同消息时产生不同的实现动作。 C++支持两种多态性：编译时多态性，运行时多态性。 ","date":"2021-05-03","objectID":"/cs_interview_eight_part_questions/:3:11","tags":["互聯網","大廠","面試題","計算機網路","操作系統","Database","數據結構","演算法","MySQL","C","C++","LeetCode","CS","計算機科學","軟件工程"],"title":"互聯網公司大廠 – 面試八股文彙整","uri":"/cs_interview_eight_part_questions/"},{"categories":["Moment"],"content":"虚函数表存放的内容 https://www.jianshu.com/p/64f3b9c22898 虚函数的地址被存储一张叫做虚表的东西里，我们其实很容易拿到这个虚表。 ","date":"2021-05-03","objectID":"/cs_interview_eight_part_questions/:3:12","tags":["互聯網","大廠","面試題","計算機網路","操作系統","Database","數據結構","演算法","MySQL","C","C++","LeetCode","CS","計算機科學","軟件工程"],"title":"互聯網公司大廠 – 面試八股文彙整","uri":"/cs_interview_eight_part_questions/"},{"categories":["Moment"],"content":"什么是纯虚函数 纯虚函数，在虚函数后加“=0”，如 virtual void func()=0 當類裡面有純虛函數，則該類無法被實例化，是作為一個抽象的概念。 ","date":"2021-05-03","objectID":"/cs_interview_eight_part_questions/:3:13","tags":["互聯網","大廠","面試題","計算機網路","操作系統","Database","數據結構","演算法","MySQL","C","C++","LeetCode","CS","計算機科學","軟件工程"],"title":"互聯網公司大廠 – 面試八股文彙整","uri":"/cs_interview_eight_part_questions/"},{"categories":["Moment"],"content":"构造函数可以是虚函数吗，为什么 而构造函数是在创建对象时自动调用的，不可能通过父类的指针或者引用去调用，因此也就规定构造函数不能是虚函数。 构造函数不能是虚成员函数，但析构函数可以是虚成员函数。 ","date":"2021-05-03","objectID":"/cs_interview_eight_part_questions/:3:14","tags":["互聯網","大廠","面試題","計算機網路","操作系統","Database","數據結構","演算法","MySQL","C","C++","LeetCode","CS","計算機科學","軟件工程"],"title":"互聯網公司大廠 – 面試八股文彙整","uri":"/cs_interview_eight_part_questions/"},{"categories":["Moment"],"content":"析构函数可以是虚函数吗，为什么 析构函数可以为虚函数，主要是基类指针指向子类对象的情况下，在基类销毁时，只调用基类的析构函数而不调用子类的析构函数，从而导致内存泄漏，所以需要虚函数机制来帮助系统' 识别’需要释放资源。 ","date":"2021-05-03","objectID":"/cs_interview_eight_part_questions/:3:15","tags":["互聯網","大廠","面試題","計算機網路","操作系統","Database","數據結構","演算法","MySQL","C","C++","LeetCode","CS","計算機科學","軟件工程"],"title":"互聯網公司大廠 – 面試八股文彙整","uri":"/cs_interview_eight_part_questions/"},{"categories":["Moment"],"content":"struct 和 class 的区别 class 和struct 最本质的区别: class 是引用类型，它在堆中分配空间，栈中保存的只是引用；而struct 是值类型，它在栈中分配空间。 什么是class? class（类）是面向对象编程的基本概念，是一种自定义数据结构类型，通常包含字段、属性、方法、构造函数、索引器、操作符等。 1.默认的继承访问权。class默认的是private,strcut默认的是public。 2.默认访问权限：struct作为数据结构的实现体，它默认的数据访问控制是public的，而class作为对象的实现体，它默认的成员变量访问控制是private的。 3.“class”这个关键字还用于定义模板参数，就像“typename”。但关建字**“struct”不用于定义模板参数** 4.class和struct在使用大括号{ }上的区别 关于使用大括号初始化 1.）class和struct如果定义了构造函数的话，都不能用大括号进行初始化 2.）如果没有定义构造函数，struct可以用大括号初始化。 3.）如果没有定义构造函数，且所有成员变量全是public的话，class可以用大括号初始化 ","date":"2021-05-03","objectID":"/cs_interview_eight_part_questions/:3:16","tags":["互聯網","大廠","面試題","計算機網路","操作系統","Database","數據結構","演算法","MySQL","C","C++","LeetCode","CS","計算機科學","軟件工程"],"title":"互聯網公司大廠 – 面試八股文彙整","uri":"/cs_interview_eight_part_questions/"},{"categories":["Moment"],"content":"C 和 C++ struct 的区别 在C中struct只单纯的用作数据的复合类型，也就是说，在结构体声明中只能将数据成员放在里面，而不能将函数放在里面 struct Base{ //public char v1; int v2; double v3; void show(); //error! }; 并且在C结构体中所有成员**默认均是公有类型(public)**也就是说在结构体外部可以直接通过结构体变量对成员进行访问，例如下面C代码： struct Base s1; //在C中定义结构体变量方式 s1.v1 = 'A'; s1.v2 = 10; s1.v3 = 95.6; 在C结构体声明中不能使用C++访问修饰符，如：public、protected、private 而在C++中可以使用，例如下面C++代码： struct BasePlus{ //public int v0; private: char v1; protected: float v2; public: double v3; }; C的结构体不能继承（没有这一概念）而C++的结构体可以继承并且还可以定义成模版。 ","date":"2021-05-03","objectID":"/cs_interview_eight_part_questions/:3:17","tags":["互聯網","大廠","面試題","計算機網路","操作系統","Database","數據結構","演算法","MySQL","C","C++","LeetCode","CS","計算機科學","軟件工程"],"title":"互聯網公司大廠 – 面試八股文彙整","uri":"/cs_interview_eight_part_questions/"},{"categories":["Moment"],"content":"抽象类有什么作用 抽象类是一种特殊的类，它是为了抽象和设计的目的而建立的，它处于继承层次结构的较上层。抽象类是不能定义对象的，在实际中为了强调一个类是抽象类，可将该类的构造函数说明为保护的访问控制权限。 抽象类的主要作用是将有关的组织在一个继承层次结构中，由它来为它们提供一个公共的根，相关的子类是从这个根派生出来的。 ","date":"2021-05-03","objectID":"/cs_interview_eight_part_questions/:3:18","tags":["互聯網","大廠","面試題","計算機網路","操作系統","Database","數據結構","演算法","MySQL","C","C++","LeetCode","CS","計算機科學","軟件工程"],"title":"互聯網公司大廠 – 面試八股文彙整","uri":"/cs_interview_eight_part_questions/"},{"categories":["Moment"],"content":"强制类型转换有哪些，区别和使用方法 C++的四种强制类型转换，所以C++不是类型安全的。分别为：static_cast , dynamic_cast , const_cast , reinterpret_cast static_cast: 可以实现C++中内置基本数据类型之间的相互转换；如果涉及到类的话，static_cast只能在有相互联系的类型中进行相互转换,不一定包含虚函数。 int c=static_cast\u003cint\u003e(7.987); //基本数据类型之间相互转换 class A //类类型之间转换 {}; class B:public A {}; class C {}; int main() { A* a=new A; B* b; C* c; b=static_cast\u003cB\u003e(a); // 编译不会报错, B类继承A类 c=static_cast\u003cB\u003e(a); // 编译报错, C类与A类没有任何关系 return 1; } const_cast: const_cast操作不能在不同的种类间转换。相反，它仅仅把一个它作用的表达式转换成常量。它可以使一个本来不是const类型的数据转换成const类型的，或者把const属性去掉。 reinterpret_cast: ** 有着和C风格的强制转换同样的能力。它可以转化任何内置的数据类型为其他任何的数据类型，也可以转化任何指针类型为其他的类型**。它甚至可以转化内置的数据类型为指针，无须考虑类型安全或者常量的情形。不到万不得已绝对不用。 dynamic_cast: ** （1）其他三种都是编译时完成的，dynamic_cast是运行时处理的，运行时要进行类型检查。 （2）不能用于内置的基本数据类型的强制转换。 （3）dynamic_cast转换如果成功的话返回的是指向类的指针或引用，转换失败的话则会返回NULL**。 （4）使用dynamic_cast进行转换的，**基类中一定要有虚函数，否则编译不通过**。 B中需要检测有虚函数的原因：类中存在虚函数，就说明它有想要让基类指针或引用指向派生类对象的情况，此时转换才有意义。 这是由于运行时类型检查需要运行时类型信息，而这个信息存储在类的虚函数表（关于虚函数表的概念，详细可见\u003cInside c++ object model\u003e）中，只有定义了虚函数的类才有虚函数表。 （5）在类的转换时，在类层次间进行上行转换时，**dynamic_cast和static_cast的效果是一样的**。在进行下行转换时，dynamic_cast具有类型检查的功能，比static_cast更安全。向上转换即为指向子类对象的向下转换，即将父类指针转化子类指针。向下转换的成功与否还与将要转换的类型有关，即要转换的指针指向的对象的实际类型与转换以后的对象类型一定要相同，否则转换失败。 参考例子: #include\u003ciostream\u003e #include\u003ccstring\u003e using namespace std; class A { public: virtual void f() { cout\u003c\u003c\"hello\"\u003c\u003cendl; }; }; class B:public A { public: void f() { cout\u003c\u003c\"hello2\"\u003c\u003cendl; }; }; class C { void pp() { return; } }; int fun() { return 1; } int main() { A* a1=new B;//a1是A类型的指针指向一个B类型的对象 A* a2=new A;//a2是A类型的指针指向一个A类型的对象 B* b; C* c; b=dynamic_cast\u003cB*\u003e(a1);//结果为not null，向下转换成功，a1之前指向的就是B类型的对象，所以可以转换成B类型的指针。 if(b==NULL) { cout\u003c\u003c\"null\"\u003c\u003cendl; } else { cout\u003c\u003c\"not null\"\u003c\u003cendl; } b=dynamic_cast\u003cB*\u003e(a2);//结果为null，向下转换失败 if(b==NULL) { cout\u003c\u003c\"null\"\u003c\u003cendl; } else { cout\u003c\u003c\"not null\"\u003c\u003cendl; } c=dynamic_cast\u003cC*\u003e(a);//结果为null，向下转换失败 if(c==NULL) { cout\u003c\u003c\"null\"\u003c\u003cendl; } else { cout\u003c\u003c\"not null\"\u003c\u003cendl; } delete(a); return 0; } ","date":"2021-05-03","objectID":"/cs_interview_eight_part_questions/:3:19","tags":["互聯網","大廠","面試題","計算機網路","操作系統","Database","數據結構","演算法","MySQL","C","C++","LeetCode","CS","計算機科學","軟件工程"],"title":"互聯網公司大廠 – 面試八股文彙整","uri":"/cs_interview_eight_part_questions/"},{"categories":["Moment"],"content":"virtual关键字有哪些用法 1.可以表明該函數方法是虛函數，也可以不寫，也可以將析構函數定義為虛函數。 2.纯虚函数表明，加前綴 3.虚拟继承（virtual public） 在多继承下，虚继承就是为了解决菱形继承中，B,C都继承了A，D继承了B,C，那么D关于 A的引用只有一次，而不是 普通继承的 对于A引用了两次…… 格式：可以采用public、protected、private三种不同的继承关键字进行修饰，只要确保包含virtual就可以了。 class A { void f1(){}; }; class B : public virtual A{ void f2(){}; }; 虚继承：在继承定义中包含了virtual关键字的继承关系； 虚基类：在虚继承体系中的通过virtual继承而来的基类， #include using namespace std;class Person{ public: Person(){ cout\u003c\u003c\"Person构造\"\u003c\u003cENDL; } ~Person(){ cout\u003c\u003c\"Person析构\"\u003c\u003cENDL; } }; class Teacher : virtual public Person{ public: Teacher(){ cout\u003c\u003c\"Teacher构造\"\u003c\u003cENDL; } ~Teacher(){ out\u003c\u003c\"Teacher析构\"\u003c\u003cENDL; } }; class Student : virtual public Person{ public: Student(){ cout\u003c\u003c\"Student构造\"\u003c\u003cENDL; } ~Student(){ cout\u003c\u003c\"Student析构\"\u003c\u003cENDL; } }; class TS : public Teacher, public Student{ public: TS(){ cout\u003c\u003c\"TS构造\"\u003c\u003cENDL; } ~TS(){ cout\u003c\u003c\"TS析构\"\u003c\u003cENDL; } }; int main(int argc,char* argv[]) { TS ts; return 0; } 這問題感覺有點玄，看下面的文章 https://zhuanlan.zhihu.com/p/147601339 ","date":"2021-05-03","objectID":"/cs_interview_eight_part_questions/:3:20","tags":["互聯網","大廠","面試題","計算機網路","操作系統","Database","數據結構","演算法","MySQL","C","C++","LeetCode","CS","計算機科學","軟件工程"],"title":"互聯網公司大廠 – 面試八股文彙整","uri":"/cs_interview_eight_part_questions/"},{"categories":["Moment"],"content":"继承时的访问权限控制符有啥区别 public、protected、private 訪問權限 public protected private 对本类 可见 可见 可见 对子类 可见 可见 不可见 对外部(调用方) 可见 不可见 不可见 ","date":"2021-05-03","objectID":"/cs_interview_eight_part_questions/:3:21","tags":["互聯網","大廠","面試題","計算機網路","操作系統","Database","數據結構","演算法","MySQL","C","C++","LeetCode","CS","計算機科學","軟件工程"],"title":"互聯網公司大廠 – 面試八股文彙整","uri":"/cs_interview_eight_part_questions/"},{"categories":["Moment"],"content":"什么是右值引用 右值引用可以从字面意思上理解，指的是以引用传递（而非值传递）的方式使用 C++ 右值。 左值的英文简写为“lvalue”，右值的英文简写为“rvalue”。很多人认为它们分别是\"left value\"、“right value” 的缩写，其实不然。lvalue 是“loactor value”的缩写，可意为存储在内存中、有明确存储地址（可寻址）的数据，而 rvalue 译为 “read value”，指的是那些可以提供数据值的数据（不一定可以寻址，例如存储于寄存器中的数据）。 可位于赋值号（=）左侧的表达式就是左值；反之，只能位于赋值号右侧的表达式就是右值。举个例子: int a = 5; 5 = a; //错误，5 不能为左值 其中，变量 a 就是一个左值，而字面量 5 就是一个右值。值得一提的是，C++ 中的左值也可以当做右值使用，例如： int b = 10; // b 是一个左值 a = b; // a、b 都是左值，只不过将 b 可以当做右值使用 ","date":"2021-05-03","objectID":"/cs_interview_eight_part_questions/:3:22","tags":["互聯網","大廠","面試題","計算機網路","操作系統","Database","數據結構","演算法","MySQL","C","C++","LeetCode","CS","計算機科學","軟件工程"],"title":"互聯網公司大廠 – 面試八股文彙整","uri":"/cs_interview_eight_part_questions/"},{"categories":["Moment"],"content":"std::move 的使用 std::move函数可以以非常简单的方式将左值引用转换为右值引用 用法: 原lvalue值被moved from之后值被转移,所以为空字符串. //摘自https://zh.cppreference.com/w/cpp/utility/move #include \u003ciostream\u003e#include \u003cutility\u003e#include \u003cvector\u003e#include \u003cstring\u003eint main() { std::string str = \"Hello\"; std::vector\u003cstd::string\u003e v; //调用常规的拷贝构造函数，新建字符数组，拷贝数据 v.push_back(str); std::cout \u003c\u003c \"After copy, str is \\\"\" \u003c\u003c str \u003c\u003c \"\\\"\\n\"; //调用移动构造函数，掏空str，掏空后，最好不要使用str v.push_back(std::move(str)); std::cout \u003c\u003c \"After move, str is \\\"\" \u003c\u003c str \u003c\u003c \"\\\"\\n\"; std::cout \u003c\u003c \"The contents of the vector are \\\"\" \u003c\u003c v[0] \u003c\u003c \"\\\", \\\"\" \u003c\u003c v[1] \u003c\u003c \"\\\"\\n\"; } 輸出: After copy, str is \"Hello\" After move, str is \"\" The contents of the vector are \"Hello\", \"Hello\" ","date":"2021-05-03","objectID":"/cs_interview_eight_part_questions/:3:23","tags":["互聯網","大廠","面試題","計算機網路","操作系統","Database","數據結構","演算法","MySQL","C","C++","LeetCode","CS","計算機科學","軟件工程"],"title":"互聯網公司大廠 – 面試八股文彙整","uri":"/cs_interview_eight_part_questions/"},{"categories":["Moment"],"content":"const 关键字的使用 const修饰符可以把对象转变成常数对象，意思就是说利用const进行修饰的变量的值在程序的任意位置将不能再被修改，就如同常数一样使用！任何修改该变量的尝试都会导致编译错误 這題感覺簡單 但又覺得有點陷阱，看下面長文章 https://www.cnblogs.com/jiabei521/p/3335676.html ","date":"2021-05-03","objectID":"/cs_interview_eight_part_questions/:3:24","tags":["互聯網","大廠","面試題","計算機網路","操作系統","Database","數據結構","演算法","MySQL","C","C++","LeetCode","CS","計算機科學","軟件工程"],"title":"互聯網公司大廠 – 面試八股文彙整","uri":"/cs_interview_eight_part_questions/"},{"categories":["Moment"],"content":"sort()底层是怎么实现的 数据量大时采用快速排序 Quick Sort，分段递归排序。一旦分段后的数据量小于某个阈值，为避免Quick Sort的递归调用带来过大的额外开销，就改用插入排序 Insertion Sort。如果递归层次过深，还会改用堆排序 Heap Sort。 ","date":"2021-05-03","objectID":"/cs_interview_eight_part_questions/:3:25","tags":["互聯網","大廠","面試題","計算機網路","操作系統","Database","數據結構","演算法","MySQL","C","C++","LeetCode","CS","計算機科學","軟件工程"],"title":"互聯網公司大廠 – 面試八股文彙整","uri":"/cs_interview_eight_part_questions/"},{"categories":["Moment"],"content":"java,python,C++的区别？ python:适合小工具小程序快速开发，无论是网站还是小游戏都非常方便。但python的脚本的运行效率较低，不适合对运行效率要求较高的程序; JAVA：采用严格的面向对象编程方法，同时有很多大型的开发框架，比较适合企业级应用; C++：C++是多范式编程语言。它不仅支持传统的面向过程编程，也支持面向对象编程，而且引入范形编程，C++运行效率较高，同时能够比较容易地建立大型软件，适合对效率要求高的软件，比如机器学习中的神经网络，大型游戏内核编程等等。 从语言特性来说： Python是一种脚本语言，是解释执行的，不需要经过编译，所以很方便快捷，且能够很好地跨平台，写一些小工具小程序特别合适。 而C++则是一种需要编译后运行语言，在特定的机器上编译后在特定的机上运行，运行效率高，安全稳定。但编译后的程序一般是不跨平台的。 而java既可以是解释执行也可以是编译执行。 从垃圾回收机制： C++需要程序员收到回收，而JAVA和Python都有自己的垃圾回收机制GC。具体两者又有不同，Python的垃圾收集机制主要使用的引用计数方式 ","date":"2021-05-03","objectID":"/cs_interview_eight_part_questions/:3:26","tags":["互聯網","大廠","面試題","計算機網路","操作系統","Database","數據結構","演算法","MySQL","C","C++","LeetCode","CS","計算機科學","軟件工程"],"title":"互聯網公司大廠 – 面試八股文彙整","uri":"/cs_interview_eight_part_questions/"},{"categories":["Moment"],"content":"inline 的作用 在 c/c++ 中，为了解决一些频繁调用的小函数大量消耗栈空间（栈内存）的问题，特别的引入了 inline 修饰符，表示为内联函数。 栈空间就是指放置程序的局部数据（也就是函数内数据）的内存空间。 在系统下，栈空间是有限的，假如频繁大量的使用就会造成因栈空间不足而导致程序出错的问题，如，函数的死循环递归调用的最终结果就是导致栈内存空间枯竭。 C++ 内联函数是通常与类一起使用。如果一个函数是内联的，那么在编译时，编译器会把该函数的代码副本放置在每个调用该函数的地方。 对内联函数进行任何修改，都需要重新编译函数的所有客户端，因为编译器需要重新更换一次所有的代码，否则将会继续使用旧的函数。 如果想把一个函数定义为内联函数，则需要在函数名前面放置关键字 inline，在调用函数之前需要对函数进行定义。如果已定义的函数多于一行，编译器会忽略 inline 限定符。 在类定义中的定义的函数都是内联函数，即使没有使用 inline 说明符。 用法: #include \u003ciostream\u003e using namespace std; inline int Max(int x, int y) { return (x \u003e y)? x : y; } // 程序的主函数 int main( ) { cout \u003c\u003c \"Max (20,10): \" \u003c\u003c Max(20,10) \u003c\u003c endl; cout \u003c\u003c \"Max (0,200): \" \u003c\u003c Max(0,200) \u003c\u003c endl; cout \u003c\u003c \"Max (100,1010): \" \u003c\u003c Max(100,1010) \u003c\u003c endl; return 0; } 輸出 Max (20,10): 20 Max (0,200): 200 Max (100,1010): 1010 慎用 inline 内联是以代码膨胀（复制）为代价，仅仅省去了函数调用的开销，从而提高函数的执行效率。 如果执行函数体内代码的时间，相比于函数调用的开销较大，那么效率的收获会很少。另一方面，每一处内联函数的调用都要复制代码，将使程序的总代码量增大，消耗更多的内存空间。 以下情况不宜使用内联： （1）如果函数体内的代码比较长，使用内联将导致内存消耗代价较高。 （2）如果函数体内出现循环，那么执行函数体内代码的时间要比函数调用的开销大。 \u003e 下面為後續追加延伸 ","date":"2021-05-03","objectID":"/cs_interview_eight_part_questions/:3:27","tags":["互聯網","大廠","面試題","計算機網路","操作系統","Database","數據結構","演算法","MySQL","C","C++","LeetCode","CS","計算機科學","軟件工程"],"title":"互聯網公司大廠 – 面試八股文彙整","uri":"/cs_interview_eight_part_questions/"},{"categories":["Moment"],"content":"数组与指针的区别 数组和指针本质上都代表一块内存，数组比较”直接“，数组名即代表这块内存的地址，而指针比较”含蓄“，其本身不代表任何有意义的内容，只有给它赋值后，它才真正的表示一块有意义的内存地址。 这就引出了指针和数组的一个区别：定义的时机不同；数组在编译时就已经被确定下来，而指针直到运行时才能被真正的确定到底指向何方。 ","date":"2021-05-03","objectID":"/cs_interview_eight_part_questions/:3:28","tags":["互聯網","大廠","面試題","計算機網路","操作系統","Database","數據結構","演算法","MySQL","C","C++","LeetCode","CS","計算機科學","軟件工程"],"title":"互聯網公司大廠 – 面試八股文彙整","uri":"/cs_interview_eight_part_questions/"},{"categories":["Moment"],"content":"-1在内存中的表示 這題太難了，連 Google 都沒有答案…被問到只能回答不知道 問群裡大老是說 無法判斷 程序員想怎麼定義就怎麼定義 ","date":"2021-05-03","objectID":"/cs_interview_eight_part_questions/:3:29","tags":["互聯網","大廠","面試題","計算機網路","操作系統","Database","數據結構","演算法","MySQL","C","C++","LeetCode","CS","計算機科學","軟件工程"],"title":"互聯網公司大廠 – 面試八股文彙整","uri":"/cs_interview_eight_part_questions/"},{"categories":["Moment"],"content":"如何判断float类型变量是否等于0 看到一篇好文章:https://www.cnblogs.com/kubixuesheng/p/4107309.html fabs () 是 浮點數取絕對值，abs() 是取整數絕對值 double dd = sin(3.141592653589793 / 6); /*if (dd == 0.5) {取决于不同的编译器或者机器平台……这样写，即使有时候是对的，但是就怕习惯，很容易出错。 }*/ if (fabs(dd - 0.5) \u003c DBL_EPSILON) { //满足这个条件，我们就认为dd和0.5相等，否则不等 puts(\"ok\");//打印了ok } ","date":"2021-05-03","objectID":"/cs_interview_eight_part_questions/:3:30","tags":["互聯網","大廠","面試題","計算機網路","操作系統","Database","數據結構","演算法","MySQL","C","C++","LeetCode","CS","計算機科學","軟件工程"],"title":"互聯網公司大廠 – 面試八股文彙整","uri":"/cs_interview_eight_part_questions/"},{"categories":["Moment"],"content":"虚函数的实现细节 這裡大概率延伸考 vTable，接著考 vTable 存儲項，難度有點高 对C++ 了解的人都应该知道虚函数（Virtual Function）是通过一张虚函数表（Virtual Table）来实现的。简称为V-Table。在这个表中，主是要一个类的虚函数的地址表，这张表解决了继承、覆盖的问题，保证其容真实反应实际的函数。这样，在有虚函数的类的实例中这个表被分配在了这个实例的内存中，所以，当我们用父类的指针来操作一个子类的时候，这张虚函数表就显得由为重要了，它就像一个地图一样，指明了实际所应该调用的函数。因此有必要知道虚函数在内存中的分布。 https://jacktang816.github.io/post/virtualfunction/ ","date":"2021-05-03","objectID":"/cs_interview_eight_part_questions/:3:31","tags":["互聯網","大廠","面試題","計算機網路","操作系統","Database","數據結構","演算法","MySQL","C","C++","LeetCode","CS","計算機科學","軟件工程"],"title":"互聯網公司大廠 – 面試八股文彙整","uri":"/cs_interview_eight_part_questions/"},{"categories":["Moment"],"content":"智能指针有哪些，auto_ptr讲一下 auto_ptr, shared_ptr, weak_ptr, unique_ptr 其中后三个是c++11支持，并且第一个已经被c++11弃用 auto_ptr是C++标准库中(utility)为了解决资源泄漏的问题提供的一个智能指针类模板（注意：这只是一种简单的智能指针） auto_ptr的实现原理其实就是RAII（Resource Application Immediately Initialize），在构造的时候获取资源，在析构的时候释放资源，并进行相关指针操作的重载，使用起来就像普通的指针。 使用auto_ptr作为成员变量，以避免资源泄漏。 1、auto_ptr存储的指针应该为NULL或者指向动态分配的内存块。 2、auto_ptr存储的指针应该指向单一物件（是new出来的，而不是new[]出来的）。 3、两个auto_ptr对象不会同时指向同一块内存块。要明白2个auto_ptr对象赋值会发生什么。 4、千万不要把auto_ptr对象放在容器中。 5、当将auto_ptr作为函数参数时，最好声明为const auto_ptr\u0026(by const ref).当函数返回值可以简单的传值（by value). auto_ptr 被 unique_ptr 取代原因: auto_ptr采用copy语义来转移指针资源，转移指针资源的所有权的同时将原指针置为NULL，这跟通常理解的copy行为是不一致的(不会修改原数据)，而这样的行为在有些场合下不是我们希望看到的。 例如参考《Effective STL》第8条，sort的快排实现中有将元素复制到某个局部临时对象中，但对于auto_ptr，却将原元素置为null，这就导致最后的排序结果中可能有大量的null。而现在C++11的对move语义的支持，使得这样的资源转移通常只会在必要的场合发生，例如转移一个临时变量（右值）给某个named variable（左值），或者一个函数的返回（右值）这也就是用unique_ptr代替auto_ptr的原因，本质上来说，就是unique_ptr禁用了copy，而用move替代。之所以说通常，是因为，也可以用std:move来实现左值move给左值。 ","date":"2021-05-03","objectID":"/cs_interview_eight_part_questions/:3:32","tags":["互聯網","大廠","面試題","計算機網路","操作系統","Database","數據結構","演算法","MySQL","C","C++","LeetCode","CS","計算機科學","軟件工程"],"title":"互聯網公司大廠 – 面試八股文彙整","uri":"/cs_interview_eight_part_questions/"},{"categories":["Moment"],"content":"shared_ptr的原理？为什么引用智能指针? (1) 刚才说到，当多个shared_ptr管理同一个指针，仅当最后一个shared_ptr析构时，指针才被delete。这是怎么实现的呢？答案是：引用计数（reference counting）。引用计数指的是，所有管理同一个裸指针（raw pointer）的shared_ptr，都共享一个引用计数器，每当一个shared_ptr被赋值（或拷贝构造）给其它shared_ptr时，这个共享的引用计数器就加1，当一个shared_ptr析构或者被用于管理其它裸指针时，这个引用计数器就减1，如果此时发现引用计数器为0，那么说明它是管理这个指针的最后一个shared_ptr了，于是我们释放指针指向的资源。 在底层实现中，这个引用计数器保存在某个内部类型里（这个类型中还包含了deleter，它控制了指针的释放策略，默认情况下就是普通的delete操作），而这个内部类型对象在shared_ptr第一次构造时以指针的形式保存在shared_ptr中。shared_ptr重载了赋值运算符，在赋值和拷贝构造另一个shared_ptr时，这个指针被另一个shared_ptr共享。在引用计数归零时，这个内部类型指针与shared_ptr管理的资源一起被释放。此外，为了保证线程安全性，引用计数器的加1，减1操作都是原子操作，它保证shared_ptr由多个线程共享时不会爆掉。 簡要回答版本 shared_ptr的原理：是通过引用计数的方式来实现多个shared_ptr对象之间共享资源。 1.shared_ptr在其内部，给每个资源都维护了着一份计数，用来记录该份资源被几个对象共享。 2.在对象被销毁时(也就是析构函数调用)，就说明自己不使用该资源了，对象的引用计数减一。 3.如果引用计数是0，就说明自己是最后一个使用该资源的对象，必须释放该资源； 4.如果不是0，就说明除了自己还有其他对象在使用该份资源，不能释放该资源，否则其他对象就成野指针了。 (2) 我们知道c++的内存管理是让很多人头疼的事，当我们写一个new语句时，一般就会立即把delete语句直接也写了，但是我们不能避免程序还未执行到delete时就跳转了或者在函数中没有执行到最后的delete语句就返回了，如果我们不在每一个可能跳转或者返回的语句前释放资源，就会造成内存泄露。使用智能指针可以很大程度上的避免这个问题，因为智能指针就是一个类，当超出了类的作用域是，类会自动调用析构函数，析构函数会自动释放资源。 ","date":"2021-05-03","objectID":"/cs_interview_eight_part_questions/:3:33","tags":["互聯網","大廠","面試題","計算機網路","操作系統","Database","數據結構","演算法","MySQL","C","C++","LeetCode","CS","計算機科學","軟件工程"],"title":"互聯網公司大廠 – 面試八股文彙整","uri":"/cs_interview_eight_part_questions/"},{"categories":["Moment"],"content":"用shared_ptr会造成什么问题？怎么解决？ (1) std::shared_ptr的线程安全问题 1.智能指针对象中引用计数是多个智能指针对象共享的，两个线程中智能指针的引用计数同时++或–，这个操作不是原子的，引用计数原来是1，++了两次，可能还是2.这样引用计数就错乱了。会导致资源未释放或者程序崩溃的问题。所以只能指针中引用计数++、–是需要加锁的，也就是说引用计数的操作是线程安全的。 2.智能指针管理的对象存放在堆上，两个线程中同时去访问，会导致线程安全问题。 std::shared_ptr的循环引用 #include\u003cmemory\u003estruct ListNode { int _data; shared_ptr\u003cListNode\u003e _prev; shared_ptr\u003cListNode\u003e _next; ~ListNode(){ cout \u003c\u003c \"~ListNode()\" \u003c\u003c endl; } }; int main() { shared_ptr\u003cListNode\u003e node1(new ListNode); shared_ptr\u003cListNode\u003e node2(new ListNode); cout \u003c\u003c node1.use_count() \u003c\u003c endl; cout \u003c\u003c node2.use_count() \u003c\u003c endl; node1-\u003e_next = node2; node2-\u003e_prev = node1; cout \u003c\u003c node1.use_count() \u003c\u003c endl; cout \u003c\u003c node2.use_count() \u003c\u003c endl; system(\"pause\"); return 0; } 輸出 1 1 2 2 循环引用分析： 1.node1和node2两个智能指针对象指向两个节点，引用计数变成1，我们不需要手动delete。 2.node1的_next指向node2，node2的_prev指向node1，引用计数变成2。 3.node1和node2析构，引用计数减到1，但是_next还指向下一个节点。但是_prev还指向上一个节点。 4.也就是说_next析构了，node2就释放了。 5.也就是说_prev析构了，node1就释放了。 6.但是_next属于node的成员，node1释放了，_next才会析构，而node1由_prev管理，_prev属于node2成员，所以这就叫循环引用，谁也不会释放 如果不是new出来的对象如何通过智能指针管理呢？其实shared_ptr设计了一个删除器来解决这个问题 // 仿函数的删除器 template\u003cclass T\u003e struct FreeFunc { void operator()(T* ptr) { cout \u003c\u003c \"free:\" \u003c\u003c ptr \u003c\u003c endl; free(ptr); } }; template\u003cclass T\u003e struct DeleteArrayFunc { void operator()(T* ptr) { cout \u003c\u003c \"delete[]\" \u003c\u003c ptr \u003c\u003c endl; delete[] ptr; } }; int main() { FreeFunc\u003cint\u003e freeFunc; shared_ptr\u003cint\u003e sp1((int*)malloc(4), freeFunc); DeleteArrayFunc\u003cint\u003e deleteArrayFunc; shared_ptr\u003cint\u003e sp2((int*)malloc(4), deleteArrayFunc); return 0; } ","date":"2021-05-03","objectID":"/cs_interview_eight_part_questions/:3:34","tags":["互聯網","大廠","面試題","計算機網路","操作系統","Database","數據結構","演算法","MySQL","C","C++","LeetCode","CS","計算機科學","軟件工程"],"title":"互聯網公司大廠 – 面試八股文彙整","uri":"/cs_interview_eight_part_questions/"},{"categories":["Moment"],"content":"怎样用会造成循环引用？简单说一下 shared_ptr的一个最大的缺点，或者说，引用计数策略最大的缺点，就是循环引用（cyclic reference），下面是一个典型的事故现场： class Observer; // 前向声明 class Subject { private: std::vector\u003cshared_ptr\u003cObserver\u003e\u003e observers; public: Subject() {} addObserver(shared_ptr\u003cObserver\u003e ob) { observers.push_back(ob); } // 其它代码 .......... }; class Observer { private: shared_ptr\u003cSubject\u003e object; public: Observer(shared_ptr\u003cObject\u003e obj) : object(obj) {} // 其它代码 ........... }; 目标（Subject）类连接着多个观察者（Observer）类，当某个事件发生时，目标类可以遍历观察者数组observers，对每个观察者进行\"通知\"，而观察者类中，也保存着目标类的shared_ptr，这样多个观察者之间可以以目标类为桥梁进行沟通，除了会发生内存泄漏以外，这是很不错的设计模式嘛！等等，不是说用了shared_ptr管理资源后就不会内存泄漏了吗？怎么又漏了？ 这就是引用计数模型失效的唯一的情况：循环引用。循环引用指的是，一个引用通过一系列的引用链，竟然引用回自身，上面的例子中，Subject-\u003eObserver-\u003eSubject就是这么一条环形的引用链。假设我们的程序中只有一个变量shared_ptr p，此时，p指向的对象不仅通过该shared_ptr引用自己，还通过它包含的Observer中的object成员变量引用回自己，于是它的引用计数是2，每个Observer的引用计数都是1。当p析构时，它的引用计数减1，变成2-1=1（大于0!），p指向对象的析构函数将不会被调用，于是p和它包含的每个Observer对象在程序结束时依然驻留在内存中没被delete，形成内存泄漏。 weak_ptr解決循環引用: 为了解决这一问题，标准库提供了std::weak_ptr（弱引用），它也位于中。 weak_ptr是shared_ptr的\"观察者\"，它与一个shared_ptr绑定，但却不参与引用计数的计算，在需要时，它还能摇身一变，生成一个与它所\"观察\"的shared_ptr共享引用计数器的新shared_ptr。总而言之，weak_ptr的作用就是：在需要时变出一个shared_ptr，在其它时候不干扰shared_ptr的引用计数。 在上面的例子中，我们只需简单地将Observer中object成员的类型换成std::weak_ptr即可解决内存泄漏的问题，此刻（接着上面的例子），p指向对象的引用计数为1，所以在p析构时，Subject指针将被delete，其中包含的observers数组在析构时，内部的Observer对象的引用计数也将变为0，故它们也被delete了，资源释放得干干净净。 下面，是weak_ptr的使用方法： std::shared_ptr\u003cint\u003e sh = std::make_shared\u003cint\u003e(); // 用一个shared_ptr初始化 std::weak_ptr\u003cint\u003e w(sh); // 变出shared_ptr std::shared_ptr\u003cint\u003e another = w.lock(); // 判断weak_ptr所观察的shared_ptr的资源是否已经释放 bool isDeleted = w.expired(); ","date":"2021-05-03","objectID":"/cs_interview_eight_part_questions/:3:35","tags":["互聯網","大廠","面試題","計算機網路","操作系統","Database","數據結構","演算法","MySQL","C","C++","LeetCode","CS","計算機科學","軟件工程"],"title":"互聯網公司大廠 – 面試八股文彙整","uri":"/cs_interview_eight_part_questions/"},{"categories":["Moment"],"content":"如何判断机器是大端存储还是小端存储，如何将大端转换成小端？ (1) 第一次看這題感覺有點迷 看這篇文章 https://blog.csdn.net/lwfcgz/article/details/50476051 计算机有little endian（小端）和big endian（大端）之分，两张从 维基百科盗来的图就可以说明它们的区别： 对于32位的整数，大端机器会在内存的低地址存储高位，在高地址存储低位。 小端机器恰好相反，内存的低地址存储低位，在高地址存储高位。 大端表示法和人的直观比较相符，从低地址向高地址看过去，就是原先的数；小端表示法更便于计算机的操作，地址增加和个十百千万的增加是一致的。 如何判断自己的计算机是little endian还是big endian呢？intel的机器基本全是little endian，也可以运行简单的代码判断。 方法一 python -c \"import sys; print(sys.byteorder)\" 终端运行上述代码，我的本本上输出little就表示是小端机器。 方法二 写一个简单的C程序，下面这个是从nginx源码抄来的： #include \u003cstdio.h\u003eint main() { int i = 0x11223344; char *p; p = (char *) \u0026i; if (*p == 0x44) { printf(\"Little endian\\n\"); } else { printf(\"Big endian\\n\"); } return 0; } (2) https://blog.csdn.net/szchtx/article/details/42834391 判断大端模式和小端模式 使用联合，通过判断首个成员的值，确定是大端还是小端模式： bool IsBigEndian(){ union NUM{ int a; char b; }num; num.a = 0x1234; if( num.b == 0x12 ){ return true; } return false; } 大端模式和小端模式转换 对32位的数，即4个字节，大端转换成小端： 方法1：使用移位运算。 uint32_t reversebytes_uint32t(uint32_t value){ return (value \u0026 0x000000FFU) \u003c\u003c 24 | (value \u0026 0x0000FF00U) \u003c\u003c 8 | (value \u0026 0x00FF0000U) \u003e\u003e 8 | (value \u0026 0xFF000000U) \u003e\u003e 24; } 上述代码中，将低8位（0~8位）左移24位，变成了高8位（24~32位），8~16位左移8位变成了（16~24位）。将原高8位和高16位右移，变成了新的低8位和低16位。 这种方法效率采用了移位运算，效率很高。而且该方法亦可用于小端模式转成大端模式。 有了32位的转换方法，对64位，即8个字节的转换同理。不过直接写移位运算未免麻烦，可以直接使用上述函数： // 先将64位的低32位转成小端模式，再将64位的高32位转成小端模式 // 在将原来的低32位放置到高32位，原来的高32位放置到低32位 uint64_t reversebytes_uint64t(uint64_t value){ uint32_t high_uint64 = uint64_t(reversebytes_uint32t(uint32_t(value))); // 低32位转成小端 uint64_t low_uint64 = (uint64_t)reversebytes_uint32t(uint32_t(value \u003e\u003e 32)); // 高32位转成小端 return (high_uint64 \u003c\u003c 32) + low_uint64; } **方法2：对每个字节依次处理。 ** 比如0x12345678，小端模式下可认为是12*(2^32) + 34*(2^16) + 56*(2^8) + 78*(2^0)。在大端模式下，排列顺序发生了变化。 uint32_t changeEndian_uint32t(uint32_t value){ char* ptr = (char*)(\u0026value); uint64_t base[4]; // 设置基 base[0] = 1; for(int i = 1; i \u003c 4; ++i){ base[i] = base[i-1] * 256; } uint32_t res = 0; for(int i = 0; i \u003c sizeof(value); ++ i){ res += uint8_t(ptr[i]) * base[4-i-1]; } return res; } 上述代码中，第一句将输入的uint32_t的变量强制转换成字符类型数组，以便一个字节一个字节的处理。 ","date":"2021-05-03","objectID":"/cs_interview_eight_part_questions/:3:36","tags":["互聯網","大廠","面試題","計算機網路","操作系統","Database","數據結構","演算法","MySQL","C","C++","LeetCode","CS","計算機科學","軟件工程"],"title":"互聯網公司大廠 – 面試八股文彙整","uri":"/cs_interview_eight_part_questions/"},{"categories":["Moment"],"content":"C++内存分配堆栈在内存中的大小,使用malloc函数，在32位机器上1G的物理内存能获取到的内存大小。 受限於 Lib C库的实现 操作系统 硬件 扣去內核的使用，你可以分超過系統剩下的記憶體 Linux 下由 vm.overcommit_memory* 控制 https://en.wikipedia.org/wiki/Virtual_address_space ","date":"2021-05-03","objectID":"/cs_interview_eight_part_questions/:3:37","tags":["互聯網","大廠","面試題","計算機網路","操作系統","Database","數據結構","演算法","MySQL","C","C++","LeetCode","CS","計算機科學","軟件工程"],"title":"互聯網公司大廠 – 面試八股文彙整","uri":"/cs_interview_eight_part_questions/"},{"categories":["Moment"],"content":"构造和析构中可以调用虚函数么？调用虚函数的话，执行的是父类还是子类的虚函数呢？ C++面试题1：构造函数和虚构函数中能否调用虚函数？ CSDN 1.构造函数跟虚构函数里面都可以调用虚函数，编译器不会报错。 2.C++ primer中说到最好别用 3.由于类的构造次序是由基类到派生类，所以在构造函数中调用虚函数，虚函数是不会呈现出多态的 4.类的析构是从派生类到基类，当调用继承层次中某一层次的类的析构函数时意味着其派生类部分已经析构掉，所以也不会呈现多态 5.因此如果在基类中声明的纯虚函数并且在基类的析构函数中调用之，编译器会发生错误。 派生类对象构造期间进入基类的构造函数时，对象类型变成了基类类型，而不是派生类类型。 同样，进入基类析构函数时，对象也是基类类型。 ","date":"2021-05-03","objectID":"/cs_interview_eight_part_questions/:3:38","tags":["互聯網","大廠","面試題","計算機網路","操作系統","Database","數據結構","演算法","MySQL","C","C++","LeetCode","CS","計算機科學","軟件工程"],"title":"互聯網公司大廠 – 面試八股文彙整","uri":"/cs_interview_eight_part_questions/"},{"categories":["Moment"],"content":"在有继承关系的父子类中，构建和析构一个子类对象时，父子构造函数和析构函数的执行顺序分别是怎样的？ 经测试，继承下构造函数与析构函数顺序（包括虚析构函数），结果如下： 普通继承或虚函数继承，子类指针指向子类实例： 父类构造函数»\u003e子类构造函数 子类析构函数»\u003e父类析构函数 普通继承，父类指针指向子类实例： 父类构造函数»\u003e子类构造函数 父类析构函数 虚函数继承，父类指针指向子类实例： 父类构造函数»\u003e子类构造函数 子类析构函数»\u003e父类析构函数 由以上结果及测试情况得出以下结论： 无论如何继承，指针如何指向，构造函数都以最终实例化为准，顺序始终是先父类后子类 析构函数遵从类的多态性，非虚析构函数则以指针类型为准，虚析构函数则以最终实例为准，存在继承关系时顺序是先子类后父类 虚析构函数与普通虚函数还是有不同的，普通虚函数仅按最终实例执行一次，而虚析构函数按最终实例执行后仍会依次向上逐个执行其父类析构函数 可以通过\"父类::函数名\"来在子类中访问父类的函数，此时不论该函数是否虚函数，都会直接调用父类对应的函数 ","date":"2021-05-03","objectID":"/cs_interview_eight_part_questions/:3:39","tags":["互聯網","大廠","面試題","計算機網路","操作系統","Database","數據結構","演算法","MySQL","C","C++","LeetCode","CS","計算機科學","軟件工程"],"title":"互聯網公司大廠 – 面試八股文彙整","uri":"/cs_interview_eight_part_questions/"},{"categories":["Moment"],"content":"在有继承关系的类体系中，父类的构造函数和析构函数一定要申明为 virtual 吗？如果不申明为 virtual 会怎样？ C++类有继承时，析构函数必须为虚函数 - CSDN 虚函数与多态一文中讲了虚函数的用法和要点，但少讲了一点，就是虚函数在析构中的用法，本文就是修复一bug的。 C++类有继承时，析构函数必须为虚函数。如果不是虚函数，则使用时可能存在内在泄漏的问题。 假设我们有这样一种继承关系： class BaseClass {}; class SubClass : public BaseClass {}; 如果我们以这种方式创建对象： SubClass* pObj = new SubClass(); delete pObj; 不管析构函数是否是虚函数(即是否加virtual关键词)，delete时基类和子类都会被释放； 如果我们以这种方式创建对象： BaseClass* pObj = new SubClass(); delete pObj; 1.若析构函数是虚函数(即加上virtual关键词)，delete时基类和子类都会被释放； 2.若析构函数不是虚函数(即不加virtual关键词)，delete时只释放基类，不释放子类； ","date":"2021-05-03","objectID":"/cs_interview_eight_part_questions/:3:40","tags":["互聯網","大廠","面試題","計算機網路","操作系統","Database","數據結構","演算法","MySQL","C","C++","LeetCode","CS","計算機科學","軟件工程"],"title":"互聯網公司大廠 – 面試八股文彙整","uri":"/cs_interview_eight_part_questions/"},{"categories":["Moment"],"content":"什么是虚表？虚表的内存结构布局如何？虚表的第一项（或第二项）是什么？ https://blog.csdn.net/lihao21/article/details/50688337 ","date":"2021-05-03","objectID":"/cs_interview_eight_part_questions/:3:41","tags":["互聯網","大廠","面試題","計算機網路","操作系統","Database","數據結構","演算法","MySQL","C","C++","LeetCode","CS","計算機科學","軟件工程"],"title":"互聯網公司大廠 – 面試八股文彙整","uri":"/cs_interview_eight_part_questions/"},{"categories":["Moment"],"content":"菱形继承（类D同时继承B和C，B和C又继承自A）体系下，虚表在各个类中的布局如何？如果类B和类C同时有一个成员变了m，m如何在D对象的内存地址上分布的？是否会相互覆盖？ 菱形繼承是考虛表的情況下可能會問 ","date":"2021-05-03","objectID":"/cs_interview_eight_part_questions/:3:42","tags":["互聯網","大廠","面試題","計算機網路","操作系統","Database","數據結構","演算法","MySQL","C","C++","LeetCode","CS","計算機科學","軟件工程"],"title":"互聯網公司大廠 – 面試八股文彙整","uri":"/cs_interview_eight_part_questions/"},{"categories":["Moment"],"content":"如何解决菱形继承问题 两个派生类继承同一个基类，又有某个类同时继承者两个派生类，这种继承被称为菱形继承。采用虚继承可以解决这个问题。 ","date":"2021-05-03","objectID":"/cs_interview_eight_part_questions/:3:43","tags":["互聯網","大廠","面試題","計算機網路","操作系統","Database","數據結構","演算法","MySQL","C","C++","LeetCode","CS","計算機科學","軟件工程"],"title":"互聯網公司大廠 – 面試八股文彙整","uri":"/cs_interview_eight_part_questions/"},{"categories":["Moment"],"content":"什么是右值引用？为什么引进右值引用？好处？与左值引用的区别是什么？ (1) 右值引用可以从字面意思上理解，指的是以引用传递（而非值传递）的方式使用 C++ 右值。 c++11为什么要引入右值引用 - CSDN (2)(3) c++11之前，有一些让人们蛋疼的地方。 需求1：需要转递引用来提高效率，那么我们函数定义是这样的$void foo(Test \u0026t){…}$。 需求2：现在我们想这样调用函数，foo(Test())。what？编译不过。稍微解释一下，将引用绑定到一个匿名对象，完全没有意义，因为它可能很快就不在了。访问一个不在的对象，是多么恐怖的事情。 我们又想出了其他的办法，重载函数void foo(Test t){…}。what？还编译不过。因为这样重载又二义性，编译器不知道你到底要调用哪个。 最后没辙了，我们只能放大招了，void foo(const Test\u0026 t){…}只能这样了。const不是只读的意思吗，怎么还可以这样用。对的const干的活比较多，const Test\u0026 t{Test()};这种用法就退化回const Test t{Test()};,这两种写法都会创建一个新的对象，所以const干了一个不属于它的活，这样即保障了传引用的高效又可以传入匿名对象。 需求3：但是我们又需要改变它的值，那好吧，我们只能用const_cast\u003cTest\u0026\u003e(t)强转后来改变他的值。 c++11引入了右值引用来帮助const分担工作。 现在完全可以用void foo(Test\u0026\u0026 t)和void foo(Test\u0026 t)两个函数来区分传入值是否是将亡值，并且可以重载，无二义性。 注意下面情况： #include \u003ciostream\u003eusing namespace std; class Test { public: Test() : x(0) {cout \u003c\u003c \"构造函数 this = \" \u003c\u003c this \u003c\u003c endl;} Test(int x) : x(x) {cout \u003c\u003c \"构造函数 this = \" \u003c\u003c this \u003c\u003c endl;} Test(const Test\u0026 another) : x(another.x) {cout \u003c\u003c \"拷贝构造 this = \" \u003c\u003c this \u003c\u003c \" from \" \u003c\u003c \u0026another \u003c\u003c endl;} Test(const Test\u0026\u0026 another) noexcept : x(another.x) {cout \u003c\u003c \"移动构造 this = \" \u003c\u003c this \u003c\u003c \" from \" \u003c\u003c \u0026another \u003c\u003c endl;} ~Test() {cout \u003c\u003c \"析构函数 this = \" \u003c\u003c this \u003c\u003c endl;} int x; }; ostream\u0026 operator\u003c\u003c(ostream\u0026 out, const Test\u0026 t) { out \u003c\u003c \"\u0026t = \" \u003c\u003c \u0026t \u003c\u003c \", x = \" \u003c\u003c t.x; return out; } class Aa { public: Aa(const Test\u0026 t) : t(t) { cout \u003c\u003c t \u003c\u003c endl; cout \u003c\u003c this-\u003et \u003c\u003c endl;} //Aa(const Test\u0026\u0026 t) = delete; //这行就可以禁止将亡值来赋值，使编译时报错。 void foo() {cout \u003c\u003c t \u003c\u003c endl;} private: const Test \u0026t; }; int main() { Aa a{Test()}; a.foo(); return 0; } 輸出: 构造函数 this = 0x61fe0c \u0026t = 0x61fe0c, x = 0 \u0026t = 0x61fe0c, x = 0 析构函数 this = 0x61fe0c \u0026t = 0x61fe0c, x = 0 解释： 第一步：入参$const Test\u0026 t{Test()};$产生了一个临时的匿名只读对象，还是将亡值。 第二步：初始化列表t(t)相当于将刚刚产生的匿名对象，赋值给成员对象\u0026t。 第三步：构造函数结束，匿名对象析构，之后再使用Aa时很危险的。 将移动构造函数显视删除，可以避免这一点。 移动构造函数当然不只是这一点功能，它主要是在stl中和std::move配合提高效率。 簡要 右值引用的好处，直接寄存器读取值 要用双\u0026\u0026,传递的实参是计算,这样才是寄存器的值 (4) 左值引用是起别名，如果这个对象已经析构，那么这个别名也应该一起失效。言外之意就是左值引用一定要保证它的生命周期小于等于它被引用的对象。 当将亡值出现的时候，左值引用表示无能为力，所以右值引用出现了。 右值引用也可以看作起名，只是它起名的对象是一个将亡值。然后延续这个将亡值的生命，直到这个的右值的生命也结束了。 除了入参时可以用到右值引用外，其他右值引用都显得多余。 比如Test\u0026\u0026 t{Test()};它和Test t{Test()}是一样的，甚至可以这样Test\u0026\u0026 t{}它们都只一个普通对象，只调用一次构造函数。 總結 1.左值引用只能起别名，但不能给匿名对象起名。 2.右值引用其实就是给匿名（天生匿名或者通过std::move将名字失效，这样的对象即将被析构）对象重新起名字。 3.我们一直所说的将亡值其实就是所谓的右值，其它有名字的都是左值，左值引用与左值配合，右值引用与右值配合。 ","date":"2021-05-03","objectID":"/cs_interview_eight_part_questions/:3:44","tags":["互聯網","大廠","面試題","計算機網路","操作系統","Database","數據結構","演算法","MySQL","C","C++","LeetCode","CS","計算機科學","軟件工程"],"title":"互聯網公司大廠 – 面試八股文彙整","uri":"/cs_interview_eight_part_questions/"},{"categories":["Moment"],"content":"看下面的代码，说一下输出： std::string str = \"Hello\"; std::vector\u003cstd::string\u003e vec; vec.push_back(std::move(str)); std::cout \u003c\u003c \"String: \" \u003c\u003c str \u003c\u003c std::endl; std::cout \u003c\u003c \"Vector: \" \u003c\u003c vec[0] \u003c\u003c std::endl; 這是右值引入的範例，輸出應該如下: String: Vecter: \"Hello\" ","date":"2021-05-03","objectID":"/cs_interview_eight_part_questions/:3:45","tags":["互聯網","大廠","面試題","計算機網路","操作系統","Database","數據結構","演算法","MySQL","C","C++","LeetCode","CS","計算機科學","軟件工程"],"title":"互聯網公司大廠 – 面試八股文彙整","uri":"/cs_interview_eight_part_questions/"},{"categories":["Moment"],"content":"说一下push_back和emplace_back的区别 在引入右值引用，转移构造函数，转移复制运算符之前，通常使用push_back()向容器中加入一个右值元素（临时对象）的时候，首先会调用构造函数构造这个临时对象，然后需要调用拷贝构造函数将这个临时对象放入容器中。原来的临时变量释放。这样造成的问题是临时变量申请的资源就浪费。 引入了右值引用，转移构造函数（请看这里）后，push_back()右值时就会调用构造函数和转移构造函数。在这上面有进一步优化的空间就是使用emplace_back，在容器尾部添加一个元素，这个元素原地构造，不需要触发拷贝构造和转移构造。而且调用形式更加简洁，直接根据参数初始化临时对象的成员。 #include \u003cvector\u003e #include \u003cstring\u003e #include \u003ciostream\u003e struct President { std::string name; std::string country; int year; //构造函数 President(std::string p_name, std::string p_country, int p_year) : name(std::move(p_name)), country(std::move(p_country)), year(p_year) { std::cout \u003c\u003c \"I am being constructed.\\n\"; } //复制构造函数 President(const President\u0026 other) : name(std::move(other.name)), country(std::move(other.country)), year(other.year) { std::cout \u003c\u003c \"I am being copy constructed.\\n\"; } //转移构造函数 President(President\u0026\u0026 other) : name(std::move(other.name)), country(std::move(other.country)), year(other.year) { std::cout \u003c\u003c \"I am being moved.\\n\"; } //赋值运算符函数 President\u0026 operator=(const President\u0026 other); }; int main() { std::vector\u003cPresident\u003e elections; std::cout \u003c\u003c \"emplace_back:\\n\"; elections.emplace_back(\"Nelson Mandela\", \"South Africa\", 1994); //没有类的创建 std::vector\u003cPresident\u003e reElections; std::cout \u003c\u003c \"\\npush_back:\\n\"; reElections.push_back(President(\"Franklin Delano Roosevelt\", \"the USA\", 1936)); std::cout \u003c\u003c \"\\nContents:\\n\"; for (President const\u0026 president: elections) { std::cout \u003c\u003c president.name \u003c\u003c \" was elected president of \" \u003c\u003c president.country \u003c\u003c \" in \" \u003c\u003c president.year \u003c\u003c \".\\n\"; } for (President const\u0026 president: reElections) { std::cout \u003c\u003c president.name \u003c\u003c \" was re-elected president of \" \u003c\u003c president.country \u003c\u003c \" in \" \u003c\u003c president.year \u003c\u003c \".\\n\"; } } 輸出: emplace_back: I am being constructed. push_back: I am being constructed. I am being moved. Contents: Nelson Mandela was elected president of South Africa in 1994. ","date":"2021-05-03","objectID":"/cs_interview_eight_part_questions/:3:46","tags":["互聯網","大廠","面試題","計算機網路","操作系統","Database","數據結構","演算法","MySQL","C","C++","LeetCode","CS","計算機科學","軟件工程"],"title":"互聯網公司大廠 – 面試八股文彙整","uri":"/cs_interview_eight_part_questions/"},{"categories":["Moment"],"content":"計算機網路 ","date":"2021-05-03","objectID":"/cs_interview_eight_part_questions/:4:0","tags":["互聯網","大廠","面試題","計算機網路","操作系統","Database","數據結構","演算法","MySQL","C","C++","LeetCode","CS","計算機科學","軟件工程"],"title":"互聯網公司大廠 – 面試八股文彙整","uri":"/cs_interview_eight_part_questions/"},{"categories":["Moment"],"content":"OSI 七层模型 https://baike.baidu.com/item/%E4%B8%83%E5%B1%82%E6%A8%A1%E5%9E%8B 应用层 网络服务与最终用户的一个接口。 协议有：HTTP FTP TFTP SMTP SNMP DNS TELNET HTTPS POP3 DHCP 表示层 数据的表示、安全、压缩。（在五层模型里面已经合并到了应用层） 格式有，JPEG、ASCll、EBCDIC、加密格式等 会话层 建立、管理、终止会话。（在五层模型里面已经合并到了应用层） 对应主机进程，指本地主机与远程主机正在进行的会话 传输层 定义传输数据的协议端口号，以及流控和差错校验。 协议有：TCP UDP，数据包一旦离开网卡即进入网络传输层 网络层 进行逻辑地址寻址，实现不同网络之间的路径选择。 协议有：ICMP IGMP IP（IPV4 IPV6） 数据链路层 建立逻辑连接、进行硬件地址寻址、差错校验 等功能。（由底层网络定义协议） 将比特组合成字节进而组合成帧，用MAC地址访问介质，错误发现但不能纠正。 物理层 建立、维护、断开物理连接。（由底层网络定义协议） ","date":"2021-05-03","objectID":"/cs_interview_eight_part_questions/:4:1","tags":["互聯網","大廠","面試題","計算機網路","操作系統","Database","數據結構","演算法","MySQL","C","C++","LeetCode","CS","計算機科學","軟件工程"],"title":"互聯網公司大廠 – 面試八股文彙整","uri":"/cs_interview_eight_part_questions/"},{"categories":["Moment"],"content":"三次握手和四次挥手 TCP連接6種標識 SYN（synchronous）:建立連接 ACK(acknowledgement):確認 PSH(push)：傳送 FIN(finish):結束 RST(reset):重置 URG(urgent):緊急 Sequence number：順序號碼 數據是被拆成多個數據包來發送，序列號就是對每個數據包進行編號，這樣接受方才能對數據包進行再次拼接。 Acknowledge number：確認號碼，代表下一個數據包編號 原文網址：https://kknews.cc/code/b83bma9.html 三次握手 所谓三次握手(Three-way Handshake)，是指建立一个 TCP 连接时，需要客户端和服务器总共发送3个包。 三次握手的目的是连接服务器指定端口，建立 TCP 连接，并同步连接双方的序列号和确认号，交换 TCP 窗口大小信息。在 socket 编程中，客户端执行 connect() 时。将触发三次握手。 1.第一次握手(SYN=1, seq=x): 客户端发送一个 TCP 的 SYN 标志位置1的包，指明客户端打算连接的服务器的端口，以及初始序号 X,保存在包头的序列号(Sequence Number)字段里。 发送完毕后，客户端进入 SYN_SEND 状态。 2.第二次握手(SYN=1, ACK=1, seq=y, ACKnum=x+1): 服务器发回确认包(ACK)应答。即 SYN 标志位和 ACK 标志位均为1。服务器端选择自己 ISN 序列号，放到 Seq 域里，同时将确认序号(Acknowledgement Number)设置为客户的 ISN 加1，即X+1。 发送完毕后，服务器端进入 SYN_RCVD 状态。 3.第三次握手(ACK=1，ACKnum=y+1) 客户端再次发送确认包(ACK)，SYN 标志位为0，ACK 标志位为1，并且把服务器发来 ACK 的序号字段+1，放在确定字段中发送给对方，并且在数据段放写ISN的+1 发送完毕后，客户端进入 ESTABLISHED 状态，当服务器端接收到这个包时，也进入 ESTABLISHED 状态，TCP 握手结束。 三次握手簡要理解 三次握手 三次握手的本质是确认通信双方收发数据的能力 首先，我让信使运输一份信件给对方，对方收到了，那么他就知道了我的发件能力和他的收件能力是可以的。 于是他给我回信，我若收到了，我便知我的发件能力和他的收件能力是可以的，并且他的发件能力和我的收件能力是可以。 然而此时他还不知道他的发件能力和我的收件能力到底可不可以，于是我最后回馈一次，他若收到了，他便清楚了他的发件能力和我的收件能力是可以的。 四次揮手 TCP 的连接的拆除需要发送四个包，因此称为四次挥手(Four-way handshake)，也叫做改进的三次握手。客户端或服务器均可主动发起挥手动作，在 socket 编程中，任何一方执行 close() 操作即可产生挥手操作。 1.第一次挥手(FIN=1，seq=x) 假设客户端想要关闭连接，客户端发送一个 FIN 标志位置为1的包，表示自己已经没有数据可以发送了，但是仍然可以接受数据。 发送完毕后，客户端进入 FIN_WAIT_1 状态。 2.第二次挥手(ACK=1，ACKnum=x+1) 服务器端确认客户端的 FIN 包，发送一个确认包，表明自己接受到了客户端关闭连接的请求，但还没有准备好关闭连接。 发送完毕后，服务器端进入 CLOSE_WAIT 状态，客户端接收到这个确认包之后，进入 FIN_WAIT_2 状态，等待服务器端关闭连接。 3.第三次挥手(FIN=1，seq=y) 服务器端准备好关闭连接时，向客户端发送结束连接请求，FIN 置为1。 发送完毕后，服务器端进入 LAST_ACK 状态，等待来自客户端的最后一个ACK。 4.第四次挥手(ACK=1，ACKnum=y+1) 客户端接收到来自服务器端的关闭请求，发送一个确认包，并进入 TIME_WAIT状态，等待可能出现的要求重传的 ACK 包。 服务器端接收到这个确认包之后，关闭连接，进入 CLOSED 状态。 客户端等待了某个固定时间（两个最大段生命周期，2MSL，2 Maximum Segment Lifetime）之后，没有收到服务器端的 ACK ，认为服务器端已经正常关闭连接，于是自己也关闭连接，进入 CLOSED 状态。 ","date":"2021-05-03","objectID":"/cs_interview_eight_part_questions/:4:2","tags":["互聯網","大廠","面試題","計算機網路","操作系統","Database","數據結構","演算法","MySQL","C","C++","LeetCode","CS","計算機科學","軟件工程"],"title":"互聯網公司大廠 – 面試八股文彙整","uri":"/cs_interview_eight_part_questions/"},{"categories":["Moment"],"content":"可以两次握手吗 不行。 三次握手（A three way handshake）是必须的，** 因为 sequence numbers（序列号）没有绑定到整个网络的全局时钟**（全部统一使用一个时钟，就可以确定这个包是不是延迟到的）以及 TCPs 可能有不同的机制来选择 ISN（初始序列号）。**接收方接收到第一个 SYN 时，没有办法知道这个 SYN 是是否延迟了很久了**，除非他有办法记住在这条连接中，最后接收到的那个sequence numbers（然而这不总是可行的）。这句话的意思是：一个 seq 过来了，跟现在记住的 seq 不一样，我怎么知道他是上条延迟的，还是上上条延迟的呢？所以，接收方一定需要跟发送方确认 SYN。 ","date":"2021-05-03","objectID":"/cs_interview_eight_part_questions/:4:3","tags":["互聯網","大廠","面試題","計算機網路","操作系統","Database","數據結構","演算法","MySQL","C","C++","LeetCode","CS","計算機科學","軟件工程"],"title":"互聯網公司大廠 – 面試八股文彙整","uri":"/cs_interview_eight_part_questions/"},{"categories":["Moment"],"content":"TCP 里 time close 和 time wait状态有什么意义 TIME WAIT 主动关闭方在收到被关闭方的FIN后会处于并长期（2个MSL时间，建议值是2min）的状态，大约是1-4分钟。然后由操作系统回头连接并将TCP连接设为CLOSED初始状态。 CLOSE WAIT 是被动关闭连接形成的，被动端收到主动端的FIN时候，发送ACK确认，并进入CLOSE_WAIT的状态，如果不指定close()方法，那么就不能从 CLOSE_WAIT 迁移到LAST_ACK，则系统中会有很多的CLOSE_WAIT状态的链接。 FAQ 1.为什么建立连接协议是三次握手，而关闭连接却是四次握手呢？ 因为建立连接的时候，对方可以把ACK和SYN放在一个报文里发送。 2.为什么 TIME_WAIT 状态还需要等 2MSL 后才能返回到 CLOSED 状态？ 因为不确定最后发送的 ACK 被对方收到了，所以先进入 TIME_WAIT 状态，作用是用来重发可能丢失的 ACK 报文。 如何排查 可以通过 netstat -n 结合 awk 打印这两个数值 意义 如果这两种状态过多，将会出现较高的负载，导致新的连接无法建立，或者导致socket资源耗尽。可以修改内核 TIME_WAIT 的值一定程度解决。 ","date":"2021-05-03","objectID":"/cs_interview_eight_part_questions/:4:4","tags":["互聯網","大廠","面試題","計算機網路","操作系統","Database","數據結構","演算法","MySQL","C","C++","LeetCode","CS","計算機科學","軟件工程"],"title":"互聯網公司大廠 – 面試八股文彙整","uri":"/cs_interview_eight_part_questions/"},{"categories":["Moment"],"content":"TCP 和 UDP 的区别 https://zhuanlan.zhihu.com/p/24860273 首先咱们弄清楚，TCP协议和UDP协议与TCP/IP协议的联系，很多人犯糊涂了， 一直都是说TCP协议与UDP协议的区别，我觉得这是没有从本质上弄清楚网络通信！ TCP/IP协议是一个协议簇。里面包括很多协议的，UDP只是其中的一个， 之所以命名为TCP/IP协议，因为TCP、IP协议是两个很重要的协议，就用他两命名了。 TCP/IP协议集包括应用层,传输层，网络层，网络访问层。 TCP/IP 可以看前面問題 UDP（User Data Protocol，用户数据报协议） 1、UDP是一个非连接的协议，传输数据之前源端和终端不建立连接， 当它想传送时就简单地去抓取来自应用程序的数据，并尽可能快地把它扔到网络上。 在发送端，UDP传送数据的速度仅仅是受应用程序生成数据的速度、 计算机的能力和传输带宽的限制； 在接收端，UDP把每个消息段放在队列中，应用程序每次从队列中读一个消息段。 2、 由于传输数据不建立连接，因此也就不需要维护连接状态，包括收发状态等， 因此一台服务机可同时向多个客户机传输相同的消息。 3、UDP信息包的标题很短，只有8个字节，相对于TCP的20个字节信息包的额外开销很小。 4、吞吐量不受拥挤控制算法的调节，只受应用软件生成数据的速率、传输带宽、 源端和终端主机性能的限制。 5、UDP使用尽最大努力交付，即不保证可靠交付， 因此主机不需要维持复杂的链接状态表（这里面有许多参数）。 6、UDP是面向报文的。发送方的UDP对应用程序交下来的报文， 在添加首部后就向下交付给IP层。既不拆分，也不合并，而是保留这些报文的边界， 因此，应用程序需要选择合适的报文大小。 我们经常使用**“ping”命令来测试两台主机之间TCP/IP通信是否正常**， 其实“ping”命令的原理就是**向对方主机发送UDP数据包**，然后对方主机确认收到数据包， 如果数据包是否到达的消息及时反馈回来，那么网络就是通的。 小结TCP与UDP的区别： 1、基于连接与无连接； 2、对系统资源的要求（TCP较多，UDP少）； 3、UDP程序结构较简单； 4、流模式与数据报模式 ； 5、TCP保证数据正确性，UDP可能丢包； 6、TCP保证数据顺序，UDP不保证。 ","date":"2021-05-03","objectID":"/cs_interview_eight_part_questions/:4:5","tags":["互聯網","大廠","面試題","計算機網路","操作系統","Database","數據結構","演算法","MySQL","C","C++","LeetCode","CS","計算機科學","軟件工程"],"title":"互聯網公司大廠 – 面試八股文彙整","uri":"/cs_interview_eight_part_questions/"},{"categories":["Moment"],"content":"UDP 的优点，有哪些基于UDP的协议 TCP 的优点： 可靠，稳定。 TCP 的可靠体现在 TCP 在传递数据之前，会有三次握手来建立连接，而且在数据传递时，有确认、窗口、重传、拥塞控制机制，在数据传完后，还会断开连接用来节约系统资源。 TCP 的缺点： 慢，效率低，占用系统资源高，易被攻击。 TCP 在传递数据之前，要先建连接，这会消耗时间，而且在数据传递时，确认机制、重传机制、拥塞控制机制等都会消耗大量的时间，而且要在每台设备上维护所有的传输连接，事实上，每个连接都会占用系统的 CPU、内存等硬件资源。 而且，因为 TCP 有确认机制、三次握手机制，这些也导致 TCP 容易被人利用，实现 DOS、DDOS、CC 等攻击。 UDP 的优点： 快，比 TCP 稍安全。 UDP 没有 TCP 的握手、确认、窗口、重传、拥塞控制等机制，UDP 是一个无状态的传输协议，所以它在传递数据时非常快。没有 TCP 的这些机制，UDP 较 TCP 被攻击者利用的漏洞就要少一些。但 UDP 也是无法避免攻击的，比如：UDP Flood 攻击。 UDP 的缺点： 不可靠，不稳定。 因为 UDP 没有 TCP 那些可靠的机制，在数据传递时，如果网络质量不好，就会很容易丢包。 基于上面的优缺点，那么，TCP 和 UDP 的应用场景都有哪些呢？ TCP 应用场景： 当对网络通讯质量有要求的时候，比如：整个数据要准确无误的传递给对方，这往往用于一些要求可靠的应用，比如 HTTP、HTTPS、FTP 等传输文件的协议，POP、SMTP 等邮件传输的协议。 在日常生活中，常见使用 TCP 协议的应用如下： 浏览器用的 HTTP， FlashFXP 用的 FTP，Outlook 用的 POP、SMTP，Putty 用的 Telnet、SSH，QQ 文件传输。 UDP 应用场景： 当对网络通讯质量要求不高的时候，要求网络通讯速度能尽量的快，这时就可以使用 UDP。 比如，日常生活中，常见使用 UDP 协议的应用如下：QQ 语音，QQ 视频，TFTP 等。有些应用场景对可靠性要求不高会用到 UPD，比如长视频，要求速率。 TCP 与 UDP 区别总结： 1、TCP 面向连接（如打电话要先拨号建立连接）; UDP 是无连接的，即发送数据之前不需要建立连接。 2、TCP 提供可靠的服务。也就是说，通过 TCP 连接传送的数据，无差错，不丢失，不重复，且按序到达；UDP 尽最大努力交付，即不保证可靠交付。 3、TCP 面向字节流，实际上是 TCP 把数据看成一连串无结构的字节流；UDP 是面向报文的。UDP 没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低（对实时应用很有用，如IP电话，实时视频会议等） 4、每一条 TCP 连接只能是点到点的；UDP支持一对一，一对多，多对一和多对多的交互通信。 5、TCP 首部开销 20 字节；UDP 的首部开销小，只有 8 个字节。 6、TCP 的逻辑通信信道是全双工的可靠信道，UDP 则是不可靠信道。 TCP 实现可靠的机制 https://zhuanlan.zhihu.com/p/112317245 **保证数据安全的方法: ** TCP主要提供了检验和、序列号/确认应答、超时重传、最大消息长度、滑动窗口控制等方法实现了可靠性传输。 检验和 通过检验和的方式，接收端可以检测出来数据是否有差错和异常，假如有差错就会直接丢弃TCP段，重新发送。TCP在计算检验和时，会在TCP首部加上一个12字节的伪首部。检验和总共计算3部分：TCP首部、TCP数据、TCP伪首部。 序列号/确认应答 这个机制类似于问答的形式。比如在课堂上老师会问你“明白了吗？”，假如你没有隔一段时间没有回应或者你说不明白，那么老师就会重新讲一遍。其实计算机的确认应答机制也是一样的，发送端发送信息给接收端，接收端会回应一个包，这个包就是应答包。 只要发送端有一个包传输，接收端没有回应确认包（ACK包），都会重发。或者接收端的应答包，发送端没有收到也会重发数据。这就可以保证数据的完整性。 超时重传 超时重传是指发送出去的数据包到接收到确认包之间的时间，如果超过了这个时间会被认为是丢包了，需要重传。那么我们该如何确认这个时间值呢？ 我们知道，一来一回的时间总是差不多的，都会有一个类似于平均值的概念。比如发送一个包到接收端收到这个包一共是0.5s，然后接收端回发一个确认包给发送端也要0.5s，这样的两个时间就是RTT（往返时间）。然后可能由于网络原因的问题，时间会有偏差，称为抖动（方差）。 从上面的介绍来看，超时重传的时间大概是比往返时间+抖动值还要稍大的时间。 但是在重发的过程中，假如一个包经过多次的重发也没有收到对端的确认包，那么就会认为接收端异常，强制关闭连接。并且通知应用通信异常强行终止。 最大消息长度 在建立TCP连接的时候，双方约定一个最大的长度（MSS）作为发送的单位，重传的时候也是以这个单位来进行重传。理想的情况下是该长度的数据刚好不被网络层分块。 滑动窗口控制 我们上面提到的超时重传的机制存在效率低下的问题，发送一个包到发送下一个包要经过一段时间才可以。所以我们就想着**能不能不用等待确认包就发送下一个数据包呢？**这就提出了一个滑动窗口的概念。 窗口的大小就是在无需等待确认包的情况下，发送端还能发送的最大数据量。这个机制的实现就是使用了大量的缓冲区，通过对多个段进行确认应答的功能。通过下一次的确认包可以判断接收端是否已经接收到了数据，如果已经接收了就从缓冲区里面删除数据。 在窗口之外的数据就是还未发送的和对端已经收到的数据。那么发送端是怎么样判断接收端有没有接收到数据呢？或者怎么知道需要重发的数据有哪些呢？通过下面这个图就知道了。 如上图，接收端在没有收到自己所期望的序列号数据之前，会对之前的数据进行重复确认。发送端在收到某个应答包之后，又连续3次收到同样的应答包，则数据已经丢失了，需要重发。 拥塞控制 窗口控制解决了 两台主机之间因传送速率而可能引起的丢包问题，在一方面保证了TCP数据传送的可靠性。然而如果网络非常拥堵，此时再发送数据就会加重网络负担，那么发送的数据段很可能超过了最大生存时间也没有到达接收方，就会产生丢包问题。为此TCP引入慢启动机制，先发出少量数据，就像探路一样，先摸清当前的网络拥堵状态后，再决定按照多大的速度传送数据。 此处引入一个拥塞窗口： 发送开始时定义拥塞窗口大小为1；每次收到一个ACK应答，拥塞窗口加1；而在每次发送数据时，发送窗口取拥塞窗口与接送段接收窗口最小者。 慢启动：在启动初期以指数增长方式增长；设置一个慢启动的阈值，当以指数增长达到阈值时就停止指数增长，按照线性增长方式增加至拥塞窗口；线性增长达到网络拥塞时立即把拥塞窗口置回1，进行新一轮的“慢启动”，同时新一轮的阈值变为原来的一半。 ","date":"2021-05-03","objectID":"/cs_interview_eight_part_questions/:4:6","tags":["互聯網","大廠","面試題","計算機網路","操作系統","Database","數據結構","演算法","MySQL","C","C++","LeetCode","CS","計算機科學","軟件工程"],"title":"互聯網公司大廠 – 面試八股文彙整","uri":"/cs_interview_eight_part_questions/"},{"categories":["Moment"],"content":"TCP 的有序性是什么来保证的 TCP是一种面向连接的、可靠的基于字节流服务。“面向连接”意味着使用TCP协议的应用在建立联系之前，彼此需要先建立TCP联系；而TCP协议确保传输过程中数据的顺序性则体现其“可靠”的特性，具体如下： TCP协议将数据切分为多个小片段（数据被划分为合理长度），小片段由头部（header）和数据（payload）组成，为了确保抵达数据的顺序，TCP协议给每个片段的头部（header）都分配了 序列号 ，方便后期按照序列号排序。 当某个片段按照顺序发送后，发送方会将已发送的数据片段暂时保存在 缓冲区 内，并为每个已发送的数据设置一个 时间区间 。 当接收方收到正确的符合顺序的数据片段后，会优先对数据片段做完整检验，如确认无误，再把数据片段交给上层协议，并给发送方一个 TCP片段反馈信息用来告知（ACK acknowledge）发送方：我已经接收到这个片段了。这个TCP片段被称为 ACK回复 。举个例子：发送的第一个片段序列号为 T，其对应的ACK回复则为T+1，也就是接收方要接收的下一个发送片段的序列号。 假设在规定的时间区间之内发送方收到接收方的 TCP片段反馈信息，则发送方可以释放缓冲区的数据，如若超时未收到应答，发送方则重新发送数据，直到收到应答，或者重发数据次数达到上限为止。 TCP协议的种种机制保证了数据传输的顺序，然而TCP报文段作为IP数据来传输，在IP数据报的到达可能会失序，因此TCP报文段的到达也存在失序的可能。特殊情况下，TCP将对收到的数据进行重新排列，确保顺序正确后再交给应用层。 ","date":"2021-05-03","objectID":"/cs_interview_eight_part_questions/:4:7","tags":["互聯網","大廠","面試題","計算機網路","操作系統","Database","數據結構","演算法","MySQL","C","C++","LeetCode","CS","計算機科學","軟件工程"],"title":"互聯網公司大廠 – 面試八股文彙整","uri":"/cs_interview_eight_part_questions/"},{"categories":["Moment"],"content":"UDP 如何实现可靠性 https://www.jianshu.com/p/6c73a4585eba 概述 UDP不属于连接协议，具有资源消耗少，处理速度快的优点，所以通常音频，视频和普通数据在传送时，使用UDP较多，因为即使丢失少量的包，也不会对接受结果产生较大的影响。 传输层无法保证数据的可靠传输，只能通过应用层来实现了。实现的方式可以参照tcp可靠性传输的方式，只是实现不在传输层，实现转移到了应用层。 **最简单的方式是在应用层模仿传输层TCP的可靠性传输。**下面不考虑拥塞处理，可靠UDP的简单设计。 1、添加seq/ack机制，确保数据发送到对端 2、添加发送和接收缓冲区，主要是用户超时重传。 3、添加超时重传机制。 详细说明：送端发送数据时，生成一个随机seq=x，然后每一片按照数据大小分配seq。数据到达接收端后接收端放入缓存，并发送一个ack=x的包，表示对方已经收到了数据。发送端收到了ack包后，删除缓冲区对应的数据。时间到后，定时任务检查是否需要重传数据。 目前有如下开源程序利用udp实现了可靠的数据传输。分别为RUDP、RTP、UDT。 开源程序 1、RUDP（Reliable User Datagram Protocol） RUDP 提供一组数据服务质量增强机制，如拥塞控制的改进、重发机制及淡化服务器算法等，从而在包丢失和网络拥塞的情况下， RTP 客户机（实时位置）面前呈现的就是一个高质量的 RTP 流。在不干扰协议的实时特性的同时，可靠 UDP 的拥塞控制机制允许 TCP 方式下的流控制行为。 2、RTP（Real Time Protocol） RTP为数据提供了具有实时特征的端对端传送服务，如在组播或单播网络服务下的交互式视频音频或模拟数据。 应用程序通常在 UDP 上运行 RTP 以便使用其多路结点和校验服务；这两种协议都提供了传输层协议的功能。但是 RTP 可以与其它适合的底层网络或传输协议一起使用。如果底层网络提供组播方式，那么 RTP 可以使用该组播表传输数据到多个目的地。 RTP 本身并没有提供按时发送机制或其它服务质量（QoS）保证，它依赖于底层服务去实现这一过程。 RTP 并不保证传送或防止无序传送，也不确定底层网络的可靠性。 RTP 实行有序传送， RTP 中的序列号允许接收方重组发送方的包序列，同时序列号也能用于决定适当的包位置，例如：在视频解码中，就不需要顺序解码。 3、UDT（UDP-based Data Transfer Protocol） 基于UDP的数据传输协议（UDP-basedData Transfer Protocol，简称UDT）是一种互联网数据传输协议。UDT的主要目的是支持高速广域网上的海量数据传输，而互联网上的标准数据传输协议TCP在高带宽长距离网络上性能很差。 顾名思义，UDT建于UDP之上，并引入新的拥塞控制和数据可靠性控制机制。UDT是面向连接的双向的应用层协议。它同时支持可靠的数据流传输和部分可靠的数据报传输。由于UDT完全在UDP上实现，它也可以应用在除了高速数据传输之外的其它应用领域，例如点到点技术（P2P），防火墙穿透，多媒体数据传输等等。 ","date":"2021-05-03","objectID":"/cs_interview_eight_part_questions/:4:8","tags":["互聯網","大廠","面試題","計算機網路","操作系統","Database","數據結構","演算法","MySQL","C","C++","LeetCode","CS","計算機科學","軟件工程"],"title":"互聯網公司大廠 – 面試八股文彙整","uri":"/cs_interview_eight_part_questions/"},{"categories":["Moment"],"content":"TCP 如何实现端口复用 有難度 FreeBSD 上 SO_REUSEPORT https://blog.csdn.net/ctthuangcheng/article/details/39014675 Nginx 中配置端口複用 https://blog.csdn.net/yang1018679/article/details/106819681 ","date":"2021-05-03","objectID":"/cs_interview_eight_part_questions/:4:9","tags":["互聯網","大廠","面試題","計算機網路","操作系統","Database","數據結構","演算法","MySQL","C","C++","LeetCode","CS","計算機科學","軟件工程"],"title":"互聯網公司大廠 – 面試八股文彙整","uri":"/cs_interview_eight_part_questions/"},{"categories":["Moment"],"content":"http 1.0 和 1.1 的区别 https://www.jianshu.com/p/95a521b006a8 长连接（PersistentConnection） HTTP 1.1支持长连接（PersistentConnection） HTTP 1.0规定浏览器与服务器只保持短暂的连接，浏览器的每次请求都需要与服务器建立一个TCP连接，服务器完成请求处理后立即断开TCP连接，服务器不跟踪每个客户也不记录过去的请求。 HTTP 1.1则支持持久连接Persistent Connection, 并且默认使用persistent connection.在同一个tcp的连接中可以传送多个HTTP请求和响应. 多个请求和响应可以重叠，多个请求和响应可以同时进行. 更加多的请求头和响应头(比如HTTP1.0没有host的字段). 在1.0时的会话方式： 1.建立连接 2.发出请求信息 3.回送响应信息 4.关掉连接 HTTP 1.1的持续连接，也需要增加新的请求头来帮助实现，例如，Connection请求头的值为Keep-Alive时，客户端通知服务器返回本次请求结果后保持连接；Connection请求头的值为close时，客户端通知服务器返回本次请求结果后关闭连接。HTTP 1.1还提供了与身份认证、状态管理和Cache缓存等机制相关的请求头和响应头。 流水线（Pipelining） 请求的流水线（Pipelining）处理，在一个TCP连接上可以传送多个HTTP请求和响应，减少了建立和关闭连接的消耗和延迟。例如：一个包含有许多图像的网页文件的多个请求和应答可以在一个连接中传输，但每个单独的网页文件的请求和应答仍然需要使用各自的连接。 HTTP 1.1还允许客户端不用等待上一次请求结果返回，就可以发出下一次请求，但服务器端必须按照接收到客户端请求的先后顺序依次回送响应结果，以保证客户端能够区分出每次请求的响应内容。 host字段 在HTTP1.0中认为每台服务器都绑定一个唯一的IP地址，因此，请求消息中的URL并没有传递主机名（hostname）。但随着虚拟主机技术的发展，在一台物理服务器上可以存在多个虚拟主机（Multi-homed Web Servers），并且它们共享一个IP地址。 HTTP1.1的请求消息和响应消息都应支持Host头域，且请求消息中如果没有Host头域会报告一个错误（400 Bad Request）。此外，服务器应该接受以绝对路径标记的资源请求。 100(Continue) Status HTTP/1.1加入了一个新的状态码100（Continue）。客户端事先发送一个只带头域的请求，如果服务器因为权限拒绝了请求，就回送响应码401（Unauthorized）；如果服务器接收此请求就回送响应码100，客户端就可以继续发送带实体的完整请求了。100 (Continue) 状态代码的使用，允许客户端在发request消息body之前先用request header试探一下server，看server要不要接收request body，再决定要不要发request body。 Chunked transfer-coding HTTP/1.1中引入了Chunked transfer-coding来解决上面这个问题，发送方将消息分割成若干个任意大小的数据块，每个数据块在发送时都会附上块的长度，最后用一个零长度的块作为消息结束的标志。这种方法允许发送方只缓冲消息的一个片段，避免缓冲整个消息带来的过载。 cache HTTP/1.1在1.0的基础上加入了一些cache的新特性，当缓存对象的Age超过Expire时变为stale对象，cache不需要直接抛弃stale对象，而是与源服务器进行重新激活（revalidation）。 ","date":"2021-05-03","objectID":"/cs_interview_eight_part_questions/:4:10","tags":["互聯網","大廠","面試題","計算機網路","操作系統","Database","數據結構","演算法","MySQL","C","C++","LeetCode","CS","計算機科學","軟件工程"],"title":"互聯網公司大廠 – 面試八股文彙整","uri":"/cs_interview_eight_part_questions/"},{"categories":["Moment"],"content":"拥塞控制 前面的問題[TCP 实现可靠的机制]有回答到 超时重传的时间怎么确定 https://blog.csdn.net/qq_35733751/article/details/80173022 ","date":"2021-05-03","objectID":"/cs_interview_eight_part_questions/:4:11","tags":["互聯網","大廠","面試題","計算機網路","操作系統","Database","數據結構","演算法","MySQL","C","C++","LeetCode","CS","計算機科學","軟件工程"],"title":"互聯網公司大廠 – 面試八股文彙整","uri":"/cs_interview_eight_part_questions/"},{"categories":["Moment"],"content":"流量控制 感覺內容有點多 https://notfalse.net/24/tcp-flow-control https://zhuanlan.zhihu.com/p/37379780 什么是流量控制？流量控制的目的？ 如果发送者发送数据过快，接收者来不及接收，那么就会有分组丢失。为了避免分组丢失，控制发送者的发送速度，使得接收者来得及接收，这就是流量控制。流量控制根本目的是防止分组丢失，它是构成TCP可靠性的一方面。 如何实现流量控制？ 由滑动窗口协议（连续ARQ协议）实现。滑动窗口协议既保证了分组无差错、有序接收，也实现了流量控制。主要的方式就是接收方返回的 ACK 中会包含自己的接收窗口的大小，并且利用大小来控制发送方的数据发送。 流量控制引发的死锁？怎么避免死锁的发生？ 当发送者收到了一个窗口为0的应答，发送者便停止发送，等待接收者的下一个应答。但是如果这个窗口不为0的应答在传输过程丢失，发送者一直等待下去，而接收者以为发送者已经收到该应答，等待接收新数据，这样双方就相互等待，从而产生死锁。 为了避免流量控制引发的死锁，TCP使用了持续计时器。每当发送者收到一个零窗口的应答后就启动该计时器。时间一到便主动发送报文询问接收者的窗口大小。若接收者仍然返回零窗口，则重置该计时器继续等待；若窗口不为0，则表示应答报文丢失了，此时重置发送窗口后开始发送，这样就避免了死锁的产生。 ","date":"2021-05-03","objectID":"/cs_interview_eight_part_questions/:4:12","tags":["互聯網","大廠","面試題","計算機網路","操作系統","Database","數據結構","演算法","MySQL","C","C++","LeetCode","CS","計算機科學","軟件工程"],"title":"互聯網公司大廠 – 面試八股文彙整","uri":"/cs_interview_eight_part_questions/"},{"categories":["Moment"],"content":"拥塞控制和流量控制的区别 拥塞控制：拥塞控制是作用于网络的，它是防止过多的数据注入到网络中，避免出现网络负载过大的情况；常用的方法就是：（ 1 ）慢开始、拥塞避免（ 2 ）快重传、快恢复。 流量控制：流量控制是作用于接收者的，它是控制发送者的发送速度从而使接收者来得及接收，防止分组丢失的。 ","date":"2021-05-03","objectID":"/cs_interview_eight_part_questions/:4:13","tags":["互聯網","大廠","面試題","計算機網路","操作系統","Database","數據結構","演算法","MySQL","C","C++","LeetCode","CS","計算機科學","軟件工程"],"title":"互聯網公司大廠 – 面試八股文彙整","uri":"/cs_interview_eight_part_questions/"},{"categories":["Moment"],"content":"输入一个 url 到显示网页的过程 1、输入地址 2、浏览器查找域名的 IP 地址 3、浏览器向 web 服务器发送一个 HTTP 请求 4、服务器的永久重定向响应 6、服务器处理请求 7、服务器返回一个 HTTP 响应 8、浏览器显示 HTML 9、浏览器发送请求获取嵌入在 HTML 中的资源（如图片、音频、视频、CSS、JS等等） ","date":"2021-05-03","objectID":"/cs_interview_eight_part_questions/:4:14","tags":["互聯網","大廠","面試題","計算機網路","操作系統","Database","數據結構","演算法","MySQL","C","C++","LeetCode","CS","計算機科學","軟件工程"],"title":"互聯網公司大廠 – 面試八股文彙整","uri":"/cs_interview_eight_part_questions/"},{"categories":["Moment"],"content":"NAT 的原理 https://www.itread01.com/content/1541919215.html 介紹 NAT英文全稱是“Network Address Translation”，中文意思是“網路地址轉換”，它是一個IETF(Internet Engineering Task Force, Internet工程任務組)標準，允許一個整體機構以一個公用IP（Internet Protocol）地址出現在Internet上。顧名思義，它是一種把內部私有網路地址（IP地址）翻譯成合法網路IP地址的技術。因此我們可以認為，NAT在一定程度上，能夠有效的解決公網地址不足的問題。 NAT有三種類型：靜態NAT(Static NAT)、動態地址NAT(Pooled NAT)、網路地址埠轉換NAPT（Port-Level NAT）。 原理 1.地址轉換 NAT的基本工作原理是，當私有網主機和公共網主機通訊的IP包經過NAT閘道器時，將IP包中的源IP或目的IP在私有IP和NAT的公共IP之間進行轉換。 如下圖所示，NAT閘道器有2個網路埠，其中公共網路埠的IP地址是統一分配的公共 IP，為202.20.65.5；私有網路埠的IP地址是保留地址，為192.168.1.1。私有網中的主機192.168.1.2向公共網中的主機202.20.65.4傳送了1個IP包(Dst=202.20.65.4,Src=192.168.1.2)。 當IP包經過NAT閘道器時，NAT Gateway會將IP包的源IP轉換為NAT Gateway的公共IP並轉發到公共網，此時IP包（Dst=202.20.65.4，Src=202.20.65.5）中已經不含任何私有網IP的資訊。由於IP包的源IP已經被轉換成NAT Gateway的公共IP，Web Server發出的響應IP包（Dst= 202.20.65.5,Src=202.20.65.4）將被髮送到NAT Gateway。 這時，NAT Gateway會將IP包的目的IP轉換成私有網中主機的IP，然後將IP包（Des=192.168.1.2，Src=202.20.65.4）轉發到私有網。對於通訊雙方而言，這種地址的轉換過程是完全透明的。轉換示意圖如下。 如果內網主機發出的請求包未經過NAT，那麼當Web Server收到請求包，回覆的響應包中的目的地址就是私網IP地址，在Internet上無法正確送達，導致連線失敗。 2.連線跟蹤 在上述過程中，NAT Gateway在收到響應包後，就需要判斷將資料包轉發給誰。此時如果子網內僅有少量客戶機，可以用靜態NAT手工指定；但如果內網有多臺客戶機，並且各自訪問不同網站，這時候就需要連線跟蹤（connection track）。如下圖所示： 在NAT Gateway收到客戶機發來的請求包後，做源地址轉換，並且將該連線記錄儲存下來，當NAT Gateway收到伺服器來的響應包後，查詢Track Table，確定轉發目標，做目的地址轉換，轉發給客戶機。 3.埠轉換 以上述客戶機訪問伺服器為例，當僅有一臺客戶機訪問伺服器時，NAT Gateway只須更改資料包的源IP或目的IP即可正常通訊。但是如果Client A和Client B同時訪問Web Server，那麼當NAT Gateway收到響應包的時候，就無法判斷將資料包轉發給哪臺客戶機，如下圖所示。 NAT協議的應用 NAT主要可以實現以下幾個功能：資料包偽裝、平衡負載、埠轉發和透明代理。 資料偽裝: 可以將內網資料包中的地址資訊更改成統一的對外地址資訊，不讓內網主機直接暴露在因特網上，保證內網主機的安全。同時，該功能也常用來實現共享上網。 埠轉發: 當內網主機對外提供服務時，由於使用的是內部私有IP地址，外網無法直接訪問。因此，需要在閘道器上進行埠轉發，將特定服務的資料包轉發給內網主機。 負載平衡: 目的地址轉換NAT可以重定向一些伺服器的連線到其他隨機選定的伺服器。（不是很明白） 失效終結: 目的地址轉換NAT可以用來提供高可靠性的服務。如果一個系統有一臺通過路由器訪問的關鍵伺服器，一旦路由器檢測到該伺服器當機，它可以使用目的地址轉換NAT透明的把連線轉移到一個備份伺服器上。（如何轉移的?） 透明代理: NAT可以把連線到因特網的HTTP連線重定向到一個指定的HTTP代理伺服器以快取資料和過濾請求。一些因特網服務提供商就使用這種技術來減少頻寬的使用而不用讓他們的客戶配置他們的瀏覽器支援代理連線。（如何重定向的?） ","date":"2021-05-03","objectID":"/cs_interview_eight_part_questions/:4:15","tags":["互聯網","大廠","面試題","計算機網路","操作系統","Database","數據結構","演算法","MySQL","C","C++","LeetCode","CS","計算機科學","軟件工程"],"title":"互聯網公司大廠 – 面試八股文彙整","uri":"/cs_interview_eight_part_questions/"},{"categories":["Moment"],"content":"长连接和短连接的区别，各自使用场景 Http长连接和短连接 长连接： 客户端和服务端建立连接后不进行断开，之后客户端再次访问这个服务器上的内容时，继续使用这一条连接通道。 短连接： 客户端和服务端建立连接，发送完数据后立马断开连接。下次要取数据，需要再次建立连接。 在HTTP/1.0中，默认使用的是短连接。但从 HTTP/1.1起，默认使用长连接。 Http长连接和TCP长连接的区别 Http长连接 和 TCP长连接的区别在于:** TCP 的长连接需要自己去维护一套心跳策略**。，而Http只需要**在请求头加入keep-alive:true即可实现长连接**。 ","date":"2021-05-03","objectID":"/cs_interview_eight_part_questions/:4:16","tags":["互聯網","大廠","面試題","計算機網路","操作系統","Database","數據結構","演算法","MySQL","C","C++","LeetCode","CS","計算機科學","軟件工程"],"title":"互聯網公司大廠 – 面試八股文彙整","uri":"/cs_interview_eight_part_questions/"},{"categories":["Moment"],"content":"了解哪些http状态码 状态代码由三位数字组成，第一个数字定义了响应的类别，且有五种可能取值，如下： 1xx：信息性状态码，表示服务器已接收了客户端请求，客户端可继续发送请求。 1.100 Continue 2.101 Switching Protocols 2xx：成功状态码，表示服务器已成功接收到请求并进行处理。 1.200 OK 表示客户端请求成功 2.204 No Content 成功，但不返回任何实体的主体部分 3.206 Partial Content 成功执行了一个范围（Range）请求 3xx：重定向状态码，表示服务器要求客户端重定向。 1.301 Moved Permanently 永久性重定向，响应报文的Location首部应该有该资源的新URL 2.302 Found 临时性重定向，响应报文的Location首部给出的URL用来临时定位资源 3.303 See Other 请求的资源存在着另一个URI，客户端应使用GET方法定向获取请求的资源 4.304 Not Modified 服务器内容没有更新，可以直接读取浏览器缓存 5.307 Temporary Redirect 临时重定向。与302 Found含义一样。302禁止POST变换为GET，但实际使用时并不一定，307则更多浏览器可能会遵循这一标准，但也依赖于浏览器具体实现 4xx：客户端错误状态码，表示客户端的请求有非法内容。 1.400 Bad Request 表示客户端请求有语法错误，不能被服务器所理解 2.401 Unauthonzed 表示请求未经授权，该状态代码必须与 WWW-Authenticate 报头域一起使用 3.403 Forbidden 表示服务器收到请求，但是拒绝提供服务，通常会在响应正文中给出不提供服务的原因 4.404 Not Found 请求的资源不存在，例如，输入了错误的URL 5xx：服务器错误状态码，表示服务器未能正常处理客户端的请求而出现意外错误。 1.500 Internel Server Error 表示服务器发生不可预期的错误，导致无法完成客户端的请求 2.503 Service Unavailable 表示服务器当前不能够处理客户端的请求，在一段时间之后，服务器可能会恢复正常 301 和 302 的区别。 301和302状态码都表示重定向，就是说浏览器在拿到服务器返回的这个状态码后会自动跳转到一个新的URL地址，这个地址可以从响应的Location首部中获取（用户看到的效果就是他输入的地址A瞬间变成了另一个地址B）——这是它们的共同点。 他们的不同在于。301表示旧地址A的资源已经被永久地移除了（这个资源不可访问了），搜索引擎在抓取新内容的同时也将旧的网址交换为重定向之后的网址； 302表示旧地址A的资源还在（仍然可以访问），这个重定向只是临时地从旧地址A跳转到地址B，搜索引擎会抓取新的内容而保存旧的网址。SEO302好于301 重定向原因： 1.网站调整（如改变网页目录结构）； 2.网页被移到一个新地址； 3.网页扩展名改变(如应用需要把.php改成.Html或.shtml)。 这种情况下，如果不做重定向，则用户收藏夹或搜索引擎数据库中旧地址只能让访问客户得到一个404页面错误信息，访问流量白白丧失；再者某些注册了多个域名的网站，也需要通过重定向让访问这些域名的用户自动跳转到主站点等。 什么时候进行301或者302跳转呢？ 当一个网站或者网页24—48小时内临时移动到一个新的位置，这时候就要进行302跳转，而使用301跳转的场景就是之前的网站因为某种原因需要移除掉，然后要到新的地址访问，是永久性的。 清晰明确而言：使用301跳转的大概场景如下： **域名到期不想续费（或者发现了更适合网站的域名），想换个域名。**在搜索引擎的搜索结果中出现了不带www的域名，而带www的域名却没有收录，这个时候可以用301重定向来告诉搜索引擎我们目标的域名是哪一个。空间服务器不稳定，换空间的时候。 ","date":"2021-05-03","objectID":"/cs_interview_eight_part_questions/:4:17","tags":["互聯網","大廠","面試題","計算機網路","操作系統","Database","數據結構","演算法","MySQL","C","C++","LeetCode","CS","計算機科學","軟件工程"],"title":"互聯網公司大廠 – 面試八股文彙整","uri":"/cs_interview_eight_part_questions/"},{"categories":["Moment"],"content":"get与 post的区别 （本标准答案参考自w3schools） 1.GET在浏览器回退时是无害的，而POST会再次提交请求。 2.GET产生的URL地址可以被Bookmark，而POST不可以。 3.GET请求会被浏览器主动cache，而POST不会，除非手动设置。 4.GET请求只能进行url编码，而POST支持多种编码方式。 5.GET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留。 6.GET请求在URL中传送的参数是有长度限制的，而POST么有。 7.对参数的数据类型，GET只接受ASCII字符，而POST没有限制。 8.GET比POST更不安全，因为参数直接暴露在URL上，所以不能用来传递敏感信息。 9.GET参数通过URL传递，POST放在Request body中 https://www.oschina.net/news/77354/http-get-post-different GET和POST还有一个重大区别，简单的说： GET产生一个TCP数据包；POST产生两个TCP数据包。 对于GET方式的请求，浏览器会把http header和data一并发送出去，服务器响应200（返回数据）； 而对于POST，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok（返回数据）。 也就是说，GET只需要汽车跑一趟就把货送到了，而POST得跑两趟，第一趟，先去和服务器打个招呼“嗨，我等下要送一批货来，你们打开门迎接我”，然后再回头把货送过去。 因为POST需要两步，时间上消耗的要多一点，看起来GET比POST更有效。因此Yahoo团队有推荐用GET替换POST来优化网站性能。但这是一个坑！跳入需谨慎。为什么？ GET与POST都有自己的语义，不能随便混用。 据研究，在网络环境好的情况下，发一次包的时间和发两次包的时间差别基本可以无视。而在网络环境差的情况下，两次包的TCP在验证数据包完整性上，有非常大的优点。 并不是所有浏览器都会在POST中发送两次包，Firefox就只发送一次。 ","date":"2021-05-03","objectID":"/cs_interview_eight_part_questions/:4:18","tags":["互聯網","大廠","面試題","計算機網路","操作系統","Database","數據結構","演算法","MySQL","C","C++","LeetCode","CS","計算機科學","軟件工程"],"title":"互聯網公司大廠 – 面試八股文彙整","uri":"/cs_interview_eight_part_questions/"},{"categories":["Moment"],"content":"DNS 的解析过程 第一步：检查浏览器缓存中是否缓存过该域名对应的IP地址 第二步：如果在浏览器缓存中没有找到IP，那么将继续查找本机系统是否缓存过IP 第三步：向本地域名解析服务系统发起域名解析的请求 第四步：向根域名解析服务器发起域名解析请求 第五步：根域名服务器返回gTLD域名解析服务器地址 第六步：向gTLD服务器发起解析请求 第七步：gTLD服务器接收请求并返回Name Server服务器 第八步：Name Server服务器返回IP地址给本地服务器 第九步：本地域名服务器缓存解析结果 第十步：返回解析结果给用户 ","date":"2021-05-03","objectID":"/cs_interview_eight_part_questions/:4:19","tags":["互聯網","大廠","面試題","計算機網路","操作系統","Database","數據結構","演算法","MySQL","C","C++","LeetCode","CS","計算機科學","軟件工程"],"title":"互聯網公司大廠 – 面試八股文彙整","uri":"/cs_interview_eight_part_questions/"},{"categories":["Moment"],"content":"ping 的过程 我们发起一个了从开发板到百度www.baidu.com 的ping 请求。（这里路由1作为局域网的默认网关） 1.首先开发板要解析百度的域名，获取到百度主机的IP 地址，涉及到DNS协议，传输层用的是UDP协议。 2.DNS 主机利用UDP 协议，回复百度的IP 给开发板（这里也涉及了ARP 协议暂时不讲） 3.现在开发板要发送Ping 请求包给百度主机，但是发现百度主机IP 与自己不在同一网段，因此要发送Ping 请求包给默认网关。 4.要发送给默认网关的时候，如果发现并没有默认网关对应的MAC 地址，因此发送一个ARP 广播包，如果交换机存储了默认网关的MAC 地址，就直接告诉开发板默认网关的MAC 地址，否则向所有端口发送ARP 广播。 5.路由1收到了ARP请求报文后，单播自己的MAC 地址给开发板。 6.这样开发板就可以把Ping 包发送给默认网关（路由1）了。 7.然后路由1 通过路由协议，经过一个个路由的转发，最后发送到了百度的主机上。百度主机检测到IP 是自己的IP，接收并处理Ping 请求，接着百度主机发送一个Ping 回应报文给开发板。 ICMP协议 ICMP是“Internet Control Message Ptotocol”的缩写。它是TCP/IP协议族的一个子协议，用于在IP主机、路由器之间传递控制消息。 控制消息是指网络通不通、主机是否可达、路由是否可用等网络本身的消息。这些控制消息虽然并不传输用户数据，但是对于用户数据的传递起着重要的作用。在网络中经常会使用到ICMP协议。例如经常用于检查网络不通的ping命令，这个ping的过程实际上就是ICMP协议工作的过程。还有跟踪路由的trancert命令也是基于ICMP协议的。 ARP协议 网络层以上的协议用IP地址来标识网络接口，但以太数据帧传输时，以物理地址来标识网络接口。因此我们需要进行IP地址与物理地址之间的转化。对于IPv4来说，我们使用ARP地址解析协议来完成IP地址与物理地址的转化（IPv6使用邻居发现协议进行IP地址与物理地址的转化，它包含在ICMPv6中）.ARP协议提供了网络层地址（IP地址）到物理地址（mac地址）之间的动态映射。ARP协议 是地址解析的通用协议。 MAC 地址 什麼是MAC Address ? 每一個網路介面卡都有一個獨一無二的識別碼，這個識別碼是由六組16進位數字組成的物理位置，也稱為MAC（Media Access Control）位址。 這個位址分為兩個部分，前三組數字是廠商ID；後三組數字則是網路卡的卡號，理論上全世界沒有兩張網路卡的MAC位址是相同的。 以下為延伸面試題 ","date":"2021-05-03","objectID":"/cs_interview_eight_part_questions/:4:20","tags":["互聯網","大廠","面試題","計算機網路","操作系統","Database","數據結構","演算法","MySQL","C","C++","LeetCode","CS","計算機科學","軟件工程"],"title":"互聯網公司大廠 – 面試八股文彙整","uri":"/cs_interview_eight_part_questions/"},{"categories":["Moment"],"content":"socket 基础 API 的使用 https://blog.csdn.net/zh13544539220/article/details/44832639 创建套接字──socket() 应用程序在使用套接字前，首先必须拥有一个套接字，系统调用socket()向应用程序提供创建套接字的手段，其调用格式如下： SOCKET PASCAL FAR socket( int af, int type, int protocol); 指定本地地址──bind() 当一个套接字用socket()创建后，存在一个名字空间(地址族),但它没有被命名。bind()将套接字地址（包括本地主机地址和本地端口地址）与所创建的套接字号联系起来，即将名字赋予套接字，以指定本地半相关。其调用格式如下： int PASCAL FAR bind( SOCKET s, const struct sockaddr FAR * nam e, int namelen); 参数s是由socket()调用返回的并且未作连接的套接字描述符(套接字号)。 参数name 是赋给套接字s的本地地址（名字），其长度可变，结构随通信域的不同而不同。 namelen表明了name的长度.如果没有错误发生，bind()返回 0。否则返回SOCKET_ERROR。 建立套接字连接──connect()与accept() 这两个系统调用用于完成一个完整相关的建立，其中connect()用于建立连接。无连接的套接字进程也可以调用connect()，但这时在进程之间没有实际的报文交换，调用将从本地操作系统直接返回。这样做的优点是程序员不必为每一数据指定目的地址，而且如果收到的一个数据报，其目的端口未与任何套接 字建立“连接”，便能判断该端靠纪纪可操作。而accept()用于使服务器等待来自某客户进程的实际连接。 connect()的调用格式如下： int PASCAL FAR connect( SOCKET s, const struct sockaddr FAR * name, int namelen); 参数s是欲建立连接的本地套接字描述符。 参数name指出说明对方套接字地址结构的指针。对方套接字地址长度由namelen说明。 accept()的调用格式如下： SOCKET PASCAL FAR accept( SOCKET s, struct sockaddr FAR* addr, int FAR* addrlen); 参数s为本地套接字描述符，在用做accept()调用的参数前应该先调用过listen()。 addr 指向客户方套接字地址结构的指针，用来接收连接实体的地址。addr的确切格式由套接字创建时建立的地址族决定。addrlen 为客户方套接字地址的长度（字节数）。如果没有错误发生，accept()返回一个SOCKET类型的值，表示接收到的套接字的描述符。否则返回值 INVALID_SOCKET。 四个套接字系统调用，socket()、bind()、 connect()、accept()，可以完成一个完全五元相关的建立。 socket()指定五元组中的协议元，它的用法与是否为客户或服务器、是否面 向连接无关。 bind()指定五元组中的本地二元，即本地主机地址和端口号，其用法与是否面向连接有关：在服务器方，无论是否面向连接，均要调用 bind()，若采用面向连接，则可以不调用bind()， 而通过connect()自动完成。若采用无连接，客户方必须使用bind()以获得一个唯一 的地址。 监听连接──listen() 此调用用于面向连接服务器，表明它愿意接收连接。listen()需在accept()之前调用，其调用格式如下： int PASCAL FAR listen( SOCKET s, int backlog); 参数s标识一个本地已建立、尚未连接的套接字号，服务器愿意从它上面接收请求。 backlog表示请求连接队列的最大长度，用于限制排队请求的个数，目前允许的最大值为5。如果没有错误发生，listen()返回0。否则它返回SOCKET_ERROR。 数据传输──send()与recv() 重點 send()调用用于钥纪纪数s指定的已连接的数据报或流套接字上发送输出数据，格式如下： int PASCAL FAR send( SOCKET s, const char FAR *buf, int len, int flags); 参数s为已连接的本地套接字描述符。 buf 指向存有发送数据的缓冲区的指针，其长度由len 指定。 flags 指定传输控制方式，如是否发送带外数据等。 如果没有错误发生，send()返回总共发送的字节数。否则它返回SOCKET_ERROR。 recv()调用用于s指定的已连接的数据报或流套接字上接收输入数据，格式如下： int PASCAL FAR recv( SOCKET s, char FAR *buf, int len, int flags); 参数s 为已连接的套接字描述符。 buf指向接收输入数据缓冲区的指针，其长度由len 指定。F lags 指定传输控制方式，如是否接收带外数据等。 如果没有错误发生，recv()返回总共接收的字节数。如果连接被关闭，返回0。否则它返回 SOCKET_ERROR。 输入/输出多路复用──select() select() 调用用来检测一个或多个套接字的状态。对每一个套接字来说，这个调用可以请求读、写或错误状态方面的信息。请求给定状态的套接字集合由一个fd_set结 构指示。在返回时，此结构被更新，以反映那些满足特定条件的套接字的子集，同时， select()调用返回满足条件的套接字的数目，其调用格式如下： int PASCAL FAR select( int nfds, fd_set FAR * readfds, fd_set FAR * writefds, fd_set FAR * exceptfds, const struct timeval FAR * timeout); 参数nfds指明被检查的套接字描述符的值域，此变量一般被忽略。 参数readfds指向要做读检测的套接字描述符集合的指针，调用者希望从中读取数据。 参数writefds 指向要做写检测的套接字描述符集合的指针。 exceptfds指向要检测是否出错的套接字描述符集合的指针。 timeout指向select()函数等待的最大时间，如果设为NULL则为阻塞操 作。 select()返回包含在fd_set结构中已准备好的套接字描述符的总数目，或者是发生错误则返回SOCKET_ERROR。 关闭套接字──closesocket() closesocket()关闭套接字s，并释放分配给该套接字的资源；如果s涉及一个打开的TCP连接，则该连接被释放。closesocket()的调用格式如下： BOOL PASCAL FAR closesocket(SOCKET s); 参数s待关闭的套接字描述符。如果没有错误发生，closesocket()返回0。否则返回值SOCKET_ERROR。 以下是实现一个简单的客户端服务端链接的例子： server端： #include \u003cWINSOCK2.H\u003e #include \u003cstdio.h\u003e #pragma comment(lib,\"ws2_32.lib\") void main() { //创建套接字 WORD myVersionRequest; WSADATA wsaData; myVersionRequest=MAKEWORD(1,1); int err; err=WSAStartup(myVersionRequest,\u0026wsaData); if (!err) { printf(\"已打开套接字\\n\"); } else { //进一步绑定套接字 printf(\"嵌套字未打开!\"); return; } SOCKET serSocket=socket(AF_INET,SOCK_STREAM,0);//创建了可识别套接字 //需要绑定的参数 SOCKADDR_IN addr; addr.sin_family=AF_INET; addr.sin_addr.S_un.S_addr=htonl(INADDR_ANY);//ip地址 addr.sin_port=htons(6000);//绑定端口 bind(serSocket,(SOCKADDR*)\u0026addr,sizeof(SOCKADDR));//绑定完成 listen(serSocket,5);//其中第二个参数代表能够接收的最多的连接数 // //开始进行监听 // SOCKADDR_IN clientsocket; int len=sizeof(SOCKADDR); while (1) { SOCKET serConn=accept(serSocket,(SOCKADDR*)\u0026clientsocket,\u0026len);//如果这里不是accept而是conection的话。。就会不断的监听 char sendBuf[100]; sprintf(sendBuf,\"welcome %s to bejing\",inet_ntoa(clientsocket.sin_addr));//找对对应的IP并且将这行字打印到那里 send(serConn,sendBuf,strlen(sendBuf)+1,0); char receiveBuf[100];//接收 recv(serConn,rec","date":"2021-05-03","objectID":"/cs_interview_eight_part_questions/:4:21","tags":["互聯網","大廠","面試題","計算機網路","操作系統","Database","數據結構","演算法","MySQL","C","C++","LeetCode","CS","計算機科學","軟件工程"],"title":"互聯網公司大廠 – 面試八股文彙整","uri":"/cs_interview_eight_part_questions/"},{"categories":["Moment"],"content":"Tcp连接主动关闭与被动关闭的区别。 TIME_WAIT TIME_WAIT 是主动关闭链接时形成的，等待2MSL时间，约4分钟。主要是防止最后一个ACK丢失。 由于TIME_WAIT 的时间会非常长，因此server端应尽量减少主动关闭连接 CLOSE_WAIT CLOSE_WAIT是被动关闭连接是形成的。根据TCP状态机，服务器端收到客户端发送的FIN，则按照TCP实现发送ACK，因此进入CLOSE_WAIT状态。但如果服务器端不执行close()，就不能由CLOSE_WAIT迁移到LAST_ACK，则系统中会存在很多CLOSE_WAIT状态的连接。此时，可能是系统忙于处理读、写操作，而未将已收到FIN的连接，进行close。此时，recv/read已收到FIN的连接socket，会返回0。 ","date":"2021-05-03","objectID":"/cs_interview_eight_part_questions/:4:22","tags":["互聯網","大廠","面試題","計算機網路","操作系統","Database","數據結構","演算法","MySQL","C","C++","LeetCode","CS","計算機科學","軟件工程"],"title":"互聯網公司大廠 – 面試八股文彙整","uri":"/cs_interview_eight_part_questions/"},{"categories":["Moment"],"content":"服务端可以建立连接的最大数目由什么决定 根據 客戶端和服務器端的 ip : port 可以有 (2^128x65536)^2 然后还有些目前没在用但是也可以用来区分连接的，那就更能塞了，ipv6还可以自己塞一堆header 那基本就是infinite 但還受限於服務器內存 https://www.sohu.com/a/221661481_216613 client最大tcp连接数 client每次发起tcp连接请求时，除非绑定端口，通常会让系统选取一个空闲的本地端口（local port），该端口是独占的，不能和其他tcp连接共享。tcp端口的数据类型是unsigned short，因此本地端口个数最大只有65536，端口0有特殊含义，不能使用，这样可用端口最多只有65535，所以在全部作为client端的情况下，一个client最大tcp连接数为65535，这些连接可以连到不同的serverip。 server最大tcp连接数 server通常固定在某个本地端口上监听，等待client的连接请求。不考虑地址重用（unix的SO_REUSEADDR选项）的情况下，即使server端有多个ip，本地监听端口也是独占的，因此server端tcp连接4元组中只有remoteip（也就是clientip）和remote port（客户端port）是可变的，因此最大tcp连接为客户端ip数×客户端port数，对IPV4，不考虑ip地址分类等因素，最大tcp连接数约为2的32次方（ip数）×2的16次方（port数），也就是server端单机最大tcp连接数约为2的48次方。 实际的tcp连接数 上面给出的是理论上的单机最大连接数，在实际环境中，受到机器资源、操作系统等的限制，特别是sever端，其最大并发tcp连接数远不能达到理论上限。在unix/linux下限制连接数的主要因素是内存和允许的文件描述符个数（每个tcp连接都要占用一定内存，每个socket就是一个文件描述符），另外1024以下的端口通常为保留端口。 对server端，通过增加内存、修改最大文件描述符个数等参数，单机最大并发TCP连接数超过10万,甚至上百万是没问题的 ","date":"2021-05-03","objectID":"/cs_interview_eight_part_questions/:4:23","tags":["互聯網","大廠","面試題","計算機網路","操作系統","Database","數據結構","演算法","MySQL","C","C++","LeetCode","CS","計算機科學","軟件工程"],"title":"互聯網公司大廠 – 面試八股文彙整","uri":"/cs_interview_eight_part_questions/"},{"categories":["Moment"],"content":"端口在传输过程中会变么 這裡要分情境，從傳輸到接收過程端口對外不會變，除非段開重新連接。 如果是应用层协议的传输的话那随便怎么乱搞了。。 NAT 的情況是端口映射 只會對外不變 在裏面隨便變都沒所謂 ","date":"2021-05-03","objectID":"/cs_interview_eight_part_questions/:4:24","tags":["互聯網","大廠","面試題","計算機網路","操作系統","Database","數據結構","演算法","MySQL","C","C++","LeetCode","CS","計算機科學","軟件工程"],"title":"互聯網公司大廠 – 面試八股文彙整","uri":"/cs_interview_eight_part_questions/"},{"categories":["Moment"],"content":"TCP四次挥手中，如果第三次丢失了会怎么办 不確定性很高 重新傳輸? 重传也不是一定能到嘛 xmppbot 就遇到过中间丢了一个数据包，然后卡在那里的情况 所以网络程序都要有超时设置。曾经 rsync 忘记写超时也是卡在那不动弹 有些卡住的状态一定时间之后会被清除，有些不会 ","date":"2021-05-03","objectID":"/cs_interview_eight_part_questions/:4:25","tags":["互聯網","大廠","面試題","計算機網路","操作系統","Database","數據結構","演算法","MySQL","C","C++","LeetCode","CS","計算機科學","軟件工程"],"title":"互聯網公司大廠 – 面試八股文彙整","uri":"/cs_interview_eight_part_questions/"},{"categories":["Moment"],"content":"TCP两次握手可以不？第三次握手可以传输数据吗？ TCP 不可以兩次握手，前面有同樣這個面試問題。 第一次和第二次是不可以携带数据的，但是第三次是可以携带数据的。 假如第一次握手可以携带数据的话，那对于服务器是不是太危险了，有人如果恶意攻击服务器，每次都在第一次握手中的SYN报文中放入大量数据。 **第三次握手，此时客户端已经处于ESTABLISHED状态。**对于客户端来说，他已经建立起连接了，并且已经知道服务器的接收和发送能力是正常的。所以也就可以携带数据了。 ","date":"2021-05-03","objectID":"/cs_interview_eight_part_questions/:4:26","tags":["互聯網","大廠","面試題","計算機網路","操作系統","Database","數據結構","演算法","MySQL","C","C++","LeetCode","CS","計算機科學","軟件工程"],"title":"互聯網公司大廠 – 面試八股文彙整","uri":"/cs_interview_eight_part_questions/"},{"categories":["Moment"],"content":"TCP缺点？慢启动如何优化 (1) TCP的缺點：** 慢，效率低，占用系統資源高**，易被攻擊TCP在傳遞數據之前，要先建連接，這會消耗時間，而且在數據傳遞時，確認機制、重傳機制、擁塞控制機制等都會消耗大量的時間，而且要在每台設備上維護所有的傳輸連接，事實上，每個連接都會占用系統的CPU、內存等硬體資源。 (2) https://blog.csdn.net/yusiguyuan/article/details/21458135 什么是慢启动 最初的TCP的实现方式是， 在连接建立成功后便会向网络中发送大尺寸的数据包，假如网络出现问题，很多这样的大包会积攒在路由器上， 很容易导致网络中路由器缓存空间耗尽，从而发生拥塞。因此现在的TCP协议规定了， 新建立的连接不能够一开始就发送大尺寸的 数据包，而只能从一个小尺寸的包开始发送，在发送和数据被对方确认的过程中去计算对方的接收速度，来 逐步增加每次发送的数据量（最后到达一个稳定的值，进入高速传输阶段。相应的，慢启动过程中，TCP通道处在低速传输阶段 ），以避免上述现象的发生。这个策略就是慢启动。 画个简单的图从原理上粗略描述一下 慢启动引起的性能问题 在海量用户高并发访问的大型网站后台，有一些基本的系统维护需求。比如迁移海量小文件，就是从一些机器拷贝海量小碎文件到另一些机器，来完成一些系统维护的基本需求。 请不要小看这样的需求，这是服务器领域乃至云计算领域几个最复杂的问题之一，量变到质变，由量大引起的难题。今天在我这篇文章中，我只说这个如何避免慢启动来提升TCP层的传输加速问题。 言归正传，慢启动为什么会对拷贝海量小文件的需求造成重大性能损失？ 举个简单的例子，我们对每个文件都采用独立的TCP连接来传输（循环使用scp拷贝就是这个例子的实际场景，很常见的用法）。那么工作过程应该是，每传输一个文件建立一个连接，然后连接处于慢启动阶段，传输小文件，每个小文件几乎都处于独立连接的慢启动阶段被传输，这样传输过程所用的TCP包的总量就会增多。更细致的说一说这个事，如果在慢启动过程中传输一个小文件，我们可能需要2至3个小包，而在一个已经完成慢启动的TCP通道中（TCP通道已进入在高速传输阶段），我们传输这个文件可能只需要1个大包。网络拷贝文件的时间基本上全部消耗都在网络传输的过程中（发数据过去等对端ACK，ACK确认归来继续再发，这样的数据来回交互相比较本机的文件读写非常耗时间），撇开三次握手和四次握手那些包，粗略来说，慢启动阶段传输这些文件所用的包的数目是高速通道传输这些文件的包的数目的2-3倍！那么时间上应该也是2-3倍的关系！如果文件的量足够大，这个总时间就会被放大到需求难以忍受的地步。 因此，在迁移海量小文件的需求下，我们不能使用“对每个文件都采用独立的TCP连接来传输（循环使用scp拷贝）“这样的策略，它会使每个文件的传输都处于在一个独立TCP的慢启动阶段。 如何避免慢启动，进而提升性能 很简单，尽量把大量小文件放在一个TCP连接中排队传输。起初的一两个文件处于慢启动过程传输，后续的文件传输全部处于高速通道中传输，用这样的方式来减少发包的数目，进而降低时间消耗。 题外话，实际上这种传输策略带来的性能提升的功劳不仅仅归于避免慢启动，事实上也避免了大量的3次握手和四次握手，这个对海量小文件传输的性能消耗也非常致命，但是这是另一个问题，本篇不多加介绍。 随着多核服务器的兴起，以及现代网卡的多通道技术的迅猛发展，现在我们解决这一问题的通常做法是绑定多CPU的多核到网卡的多个通道，然后由CPU的核来均分传输这些小文件，每个核用一个TCP连接来排队发送分到的小文件。 讲到这儿，我想大家对于大文件的传输策略应该也心里有数了，（不考虑网卡带宽的前提下）就是分块传输，在目标机器合并。 以下題目偏難，中級面試者，面試官會問到，暫時不整理 select 函数的用法 非阻塞 connect 函数的写法 epoll 的水平和边缘模式 阻塞socket与非阻塞socket的区别 send/recv函数的返回值情形 reuse_addr选项 ","date":"2021-05-03","objectID":"/cs_interview_eight_part_questions/:4:27","tags":["互聯網","大廠","面試題","計算機網路","操作系統","Database","數據結構","演算法","MySQL","C","C++","LeetCode","CS","計算機科學","軟件工程"],"title":"互聯網公司大廠 – 面試八股文彙整","uri":"/cs_interview_eight_part_questions/"},{"categories":["Moment"],"content":"數據結構 ","date":"2021-05-03","objectID":"/cs_interview_eight_part_questions/:5:0","tags":["互聯網","大廠","面試題","計算機網路","操作系統","Database","數據結構","演算法","MySQL","C","C++","LeetCode","CS","計算機科學","軟件工程"],"title":"互聯網公司大廠 – 面試八股文彙整","uri":"/cs_interview_eight_part_questions/"},{"categories":["Moment"],"content":"堆和栈的区别 队列、堆、栈、堆栈的区别 堆栈：先进后出（就像放在箱子的衣服，先放进去的后拿出来） 队列：先进先出（就像一条路，有一个入口和一个出口，先进去的就可以先出去） 进程中每个线程都有自己的堆栈，这是一段线程创建时保留下的地址区域。我们的“栈内存”即在此。 至于“堆”内存，我个人认为在未用new定义时，堆应该就是未“保留”未“提交”的自由空间，new的功能是在这些自由空间中保留（并提交）出一个地址范围。 栈(Stack)是操作系统在建立某个进程时或者线程（在支持多线程的操作系统中是线程）为这个线程建立的存储区域，该区域具有FIFO的特性，在编译的时候可以指定需要的Stack的大小。在编程中，例如C/C++中，所有的局部变量都是从栈中分配内存空间，实际上也不是什么分配，只是从栈顶向上用就行，在退出函数的时候，只是修改栈指针就可以把栈中的内容销毁，所以速度最快。 堆（Heap)是应用程序在运行的时候请求操作系统分配给自己内存，一般是申请/给予的过程，C/C++分别用malloc/New请求分配Heap，用free/delete销毁内存。由于从操作系统管理的内存分配所以在分配和销毁时都要占用时间，所以用堆的效率低的多！但是堆的好处是可以做的很大，C/C++对分配的Heap是不初始化的。 在Java中除了简单类型（int,char等）都是在堆中分配内存，这也是程序慢的一个主要原因。但是跟C/C++不同，Java中分配Heap内存是自动初始化的。在Java中所有的对象（包括int的wrapper Integer）都是在堆中分配的，但是这个对象的引用却是在Stack中分配。也就是说在建立一个对象时从两个地方都分配内存，在Heap中分配的内存实际建立这个对象，而在Stack中分配的内存只是一个指向这个堆对象的指针（引用）而已。 堆是在程序运行时，而不是在程序编译时，申请某个大小的内存空间。即动态分配内存，对其访问和对一般内存的访问没有区别。{堆是指程序运行是申请的动态内存，而栈只是指一种使用堆的方法(即先进后出)。} 栈是先进后出的，但是于堆而言却没有这个特性，两者都是存放临时数据的地方。 对于堆，我们可以随心所欲的进行增加变量和删除变量，不要遵循什么次序，只要你喜欢。 ","date":"2021-05-03","objectID":"/cs_interview_eight_part_questions/:5:1","tags":["互聯網","大廠","面試題","計算機網路","操作系統","Database","數據結構","演算法","MySQL","C","C++","LeetCode","CS","計算機科學","軟件工程"],"title":"互聯網公司大廠 – 面試八股文彙整","uri":"/cs_interview_eight_part_questions/"},{"categories":["Moment"],"content":"栈为什么比堆快一些 https://blog.csdn.net/AlbenXie/article/details/103824830 在栈上分配的内存系统会自动地为其释放，例如在函数结束时，局部变量将不复存在，就是系统自动清除栈内存的结果。但堆中分配的内存则不然：一切由你负责，即使你退出了new表达式的所处的函数或者作用域，那块内存还处于被使用状态而不能再利用。好处就是如果你想在不同模块中共享内存，那么这一点正合你意，坏处是如果你不打算再利用这块内存又忘了把它释放掉，那么它就会霸占你宝贵的内存资源直到你的程序退出为止。 栈是机器系统提供的数据结构，计算机会在底层对栈提供支持：分配专门的寄存器存放栈的地址，压栈出栈都有专门的指令执行，这就决定了栈的效率比较高。堆则是C/C++函数库提供的，它的机制是很复杂的，例如为了分配一块内存，库函数会按照一定的算法（具体的算法可以参考数据结构/操作系统）在堆内存中搜索可用的足够大小的空间，如果没有足够大小的空间（可能是由于内存碎片太多），就有可能调用系统功能去增加程序数据段的内存空间，这样就有机会分到足够大小的内存，然后进行返回。显然，堆的效率比栈要低得多。 C/C++中，所有的方法调用都是通过栈来进行的,所有的局部变量,形式参数都是从栈中分配内存空间的。实际上也不是什么分配,只是从栈顶向上用就行,就好像工厂中的传送带(conveyorbelt)一样,StackPointer会自动指引你到放东西的位置,你所要做的只是把东西放下来就行.退出函数的时候，修改栈指针就可以把栈中的内容销毁.这样的模式速度最快,当然要用来运行程序了.需要注意的是,在分配的时候,比如为一个即将要调用的程序模块分配数据区时,应事先知道这个数据区的大小,也就说是虽然分配是在程序运行时进行的,但是分配的大小多少是确定的,不变的,而这个\"大小多少\"是在编译时确定的,不是在运行时. 看看LINUX内核源代码的存储管理部分，就知道操作系统是如何管理内存资源的。每个进程都有独立的地址空间，不过这只是虚地址，这也是我们通常所看到的地址，所以我们现在写程序时不会像早期的程序员担心内存不够用，对于LINUX用户进程最大可用3G的地址空间，另外的1G留给内核。这里讨论的堆或栈都是在虚拟地址空间上，各个进程都有自己独立堆、栈空间，否则，就象楼上一些哥们说的，一个进程飞了，那所有进程都得死。 至于堆和栈哪个更快，从两方面来考虑： 栈由系统自动分配，速度较快。但程序员是无法控制的。 堆是由new分配的内存，一般速度比较慢，而且容易产生内存碎片,不过用起来最方便。 而且 栈使用的是一级缓存， 他们通常都是被调用时处于存储空间中，调用完毕立即释放 堆则是存放在二级缓存中，生命周期由虚拟机的垃圾回收算法来决定 1.分配和释放，堆在分配和释放时都要调用函数（MALLOC,FREE)，比如分配时会到堆空间去寻找足够大小的空间（因为多次分配释放后会造成空洞），这些都会花费一定的时间，具体可以看看MALLOC和FREE的源代码，他们做了很多额外的工作，而栈却不需要这些。 2.访问时间，访问堆的一个具体单元，需要两次访问内存，第一次得取得指针，第二次才是真正得数据，而栈只需访问一次。另外，堆的内容被操作系统交换到外存的概率比栈大，栈一般是不会被交换出去的。 综上所述，站在操作系统以上的层面来看，栈的效率比堆高，对于应用程序员，这些都是透明的，操作系统做了很多我们看不到的东西。 ","date":"2021-05-03","objectID":"/cs_interview_eight_part_questions/:5:2","tags":["互聯網","大廠","面試題","計算機網路","操作系統","Database","數據結構","演算法","MySQL","C","C++","LeetCode","CS","計算機科學","軟件工程"],"title":"互聯網公司大廠 – 面試八股文彙整","uri":"/cs_interview_eight_part_questions/"},{"categories":["Moment"],"content":"多线程和堆和栈 很多现代操作系统中，一个进程的（虚）地址空间大小为4G，分为系统空间和用户空间两部分，系统空间为所有进程共享，而用户空间是独立的，一般WINDOWS进程的用户空间为2G。 一个进程中的所有线程共享该进程的地址空间，但它们有各自独立的（私有的）栈(stack)，Windows线程的缺省堆栈大小为1M。堆(heap)的分配与栈有所不同，一般是一个进程有一个C运行时堆，这个堆为本进程中所有线程共享，Windows进程还有所谓进程默认堆，用户也可以创建自己的堆。 堆：是大家共有的空间，分全局堆和局部堆。全局堆就是所有没有分配的空间，局部堆就是用户分配的空间。堆在操作系统对进程初始化的时候分配，运行过程中也可以向系统要额外的堆，但是记得用完了要还给操作系统，要不然就是内存泄漏。 栈：是个线程独有的，保存其运行状态和局部自动变量的。栈在线程开始的时候初始化，每个线程的栈互相独立，因此，栈是　thread safe的。操作系统在切换线程的时候会自动的切换栈，就是切换　ＳＳ／ＥＳＰ寄存器。栈空间不需要在高级语言里面显式的分配和释放。 ","date":"2021-05-03","objectID":"/cs_interview_eight_part_questions/:5:3","tags":["互聯網","大廠","面試題","計算機網路","操作系統","Database","數據結構","演算法","MySQL","C","C++","LeetCode","CS","計算機科學","軟件工程"],"title":"互聯網公司大廠 – 面試八股文彙整","uri":"/cs_interview_eight_part_questions/"},{"categories":["Moment"],"content":"map 的底层原理 Map数据结构 Map也是容器的一种，那么我们以前看到的每一种容器，都有响应的数据结构，例如数组是一组连续的存储空间，链表是无序的，包含指针域和值域的容器。 Map的每一个元素叫做键值对，所谓键值对其实就是 “键” 和 “值” 组成的一对。 map的主要实现类是hashmap和treemap,在java开发过程中主要用到的是hashmap。下面简单介绍一下hashmap原理 数组 数组存储区间是连续的，占用内存严重，故空间复杂的很大。但数组的二分查找时间复杂度小，为O(1)；数组的特点是：寻址容易，插入和删除困难； 链表 链表存储区间离散，占用内存比较宽松，故空间复杂度很小，但时间复杂度很大，达O（N）。链表的特点是：寻址困难，插入和删除容易。 哈希表 那么我们能不能综合两者的特性，做出一种寻址容易，插入删除也容易的数据结构？答案是肯定的，这就是我们要提起的哈希表。哈希表（(Hash table）既满足了数据的查找方便，同时不占用太多的内容空间，使用也十分方便。 哈希表有多种不同的实现方法，我接下来解释的是最常用的一种方法—— 拉链法，我们可以理解为“链表的数组” hashmap底层原理 HashMap保存数据的过程为：首先判断key是否为null，若为null，则直接调用putForNullKey方法。若不为空则先计算key的hash值，然后根据hash值搜索在table数组中的索引位置，如果table数组在该位置处有元素，则通过比较是否存在相同的key，若存在则覆盖原来key的value，否则将该元素保存在链头（最先保存的元素放在链尾）。若table在该处没有元素，则直接保存。 hashmap什么时候进行扩容呢？当hashmap中的元素个数超过数组大小×loadFactor时，就会进行数组扩容，loadFactor的默认值为0.75，也就是说，默认情况下，数组大小为16，那么当hashmap中元素个数超过16×0.75=12的 时候，就把数组的大小扩展为2×16=32，即扩大一倍，然后重新计算每个元素在数组中的位置。 ","date":"2021-05-03","objectID":"/cs_interview_eight_part_questions/:5:4","tags":["互聯網","大廠","面試題","計算機網路","操作系統","Database","數據結構","演算法","MySQL","C","C++","LeetCode","CS","計算機科學","軟件工程"],"title":"互聯網公司大廠 – 面試八股文彙整","uri":"/cs_interview_eight_part_questions/"},{"categories":["Moment"],"content":"map的内存分配策略 https://blog.csdn.net/weixin_30740581/article/details/97633011 代碼內容過長…. 功能说明： map的内存分配机制分析。 代码说明： map所管理的内存地址可以是不连续的。如果key是可以通过\u003c排序的，那么，map最后的结果是有序的。它是通过一个平衡二叉树来保存数据。所以，其查找效率极高。 实现方式： 限制条件或者存在的问题： 无 ","date":"2021-05-03","objectID":"/cs_interview_eight_part_questions/:5:5","tags":["互聯網","大廠","面試題","計算機網路","操作系統","Database","數據結構","演算法","MySQL","C","C++","LeetCode","CS","計算機科學","軟件工程"],"title":"互聯網公司大廠 – 面試八股文彙整","uri":"/cs_interview_eight_part_questions/"},{"categories":["Moment"],"content":"B树和B+树的区别 https://segmentfault.com/a/1190000020416577 自閉中 B+树相对于B树有一些自己的优势，可以归结为下面几点。 1.单一节点存储的元素更多，使得查询的IO次数更少，所以也就使得它更适合做为数据库MySQL的底层数据结构了。 2.所有的查询都要查找到叶子节点，查询性能是稳定的，而B树，每个节点都可以查找到数据，所以不稳定。 3.所有的叶子节点形成了一个有序链表，更加便于查找。 ","date":"2021-05-03","objectID":"/cs_interview_eight_part_questions/:5:6","tags":["互聯網","大廠","面試題","計算機網路","操作系統","Database","數據結構","演算法","MySQL","C","C++","LeetCode","CS","計算機科學","軟件工程"],"title":"互聯網公司大廠 – 面試八股文彙整","uri":"/cs_interview_eight_part_questions/"},{"categories":["Moment"],"content":"什么是平衡二叉树 https://zhuanlan.zhihu.com/p/56066942 ","date":"2021-05-03","objectID":"/cs_interview_eight_part_questions/:5:7","tags":["互聯網","大廠","面試題","計算機網路","操作系統","Database","數據結構","演算法","MySQL","C","C++","LeetCode","CS","計算機科學","軟件工程"],"title":"互聯網公司大廠 – 面試八股文彙整","uri":"/cs_interview_eight_part_questions/"},{"categories":["Moment"],"content":"二叉搜索树，平衡二叉树，红黑树的区别 https://blog.csdn.net/Hansry/article/details/100537495 ","date":"2021-05-03","objectID":"/cs_interview_eight_part_questions/:5:8","tags":["互聯網","大廠","面試題","計算機網路","操作系統","Database","數據結構","演算法","MySQL","C","C++","LeetCode","CS","計算機科學","軟件工程"],"title":"互聯網公司大廠 – 面試八股文彙整","uri":"/cs_interview_eight_part_questions/"},{"categories":["Moment"],"content":"什么是哈希表，哈希函数，怎么解决冲突 哈希表是根据关键码值(Key value)而直接进行访问的数据结构。也就是说，它通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度。这个映射函数叫做散列函数，存放记录的数组叫做散列表。 什么是hash冲突？ 假设hash表的大小为9（即有9个槽），现在要把一串数据存到表里：5,28,19,15,20,33,12,17,10 简单计算一下：hash(5)=5, 所以数据5应该放在hash表的第5个槽里；hash(28)=1，所以数据28应该放在hash表的第1个槽里；hash(19)=1，也就是说，数据19也应该放在hash表的第1个槽里——于是就造成了碰撞（也称为冲突，collision）。 常用的Hash冲突解决方法有以下几种： 1.开放定址法 这种方法也称再散列法，其基本思想是：当关键字key的哈希地址p=H（key）出现冲突时，以p为基础，产生另一个哈希地址p1，如果p1仍然冲突，再以p为基础，产生另一个哈希地址p2，…，直到找出一个不冲突的哈希地址pi ，将相应元素存入其中。这种方法有一个通用的再散列函数形式： Hi=（H（key）+di）% m i=1，2，…，n 其中H（key）为哈希函数，m 为表长，di称为增量序列。增量序列的取值方式不同，相应的再散列方式也不同。主要有以下三种： 线性探测再散列 dii=1，2，3，…，m-1 这种方法的特点是：冲突发生时，顺序查看表中下一单元，直到找出一个空单元或查遍全表。 次探测再散列 di=12，-12，22，-22，…，k2，-k2 ( k\u003c=m/2 ) 这种方法的特点是：冲突发生时，在表的左右进行跳跃式探测，比较灵活。 机探测再散列 di=伪随机数序列。 具体实现时，应建立一个伪随机数发生器，（如i=(i+p) % m），并给定一个随机数做起点。 例如，已知哈希表长度m=11，哈希函数为：H（key）= key % 11，则H（47）=3，H（26）=4，H（60）=5，假设下一个关键字为69，则H（69）=3，与47冲突。 如果用线性探测再散列处理冲突，下一个哈希地址为H1=（3 + 1）% 11 = 4，仍然冲突，再找下一个哈希地址为H2=（3 + 2）% 11 = 5，还是冲突，继续找下一个哈希地址为H3=（3 + 3）% 11 = 6，此时不再冲突，将69填入5号单元。 如果用二次探测再散列处理冲突，下一个哈希地址为H1=（3 + 12）% 11 = 4，仍然冲突，再找下一个哈希地址为H2=（3 - 12）% 11 = 2，此时不再冲突，将69填入2号单元。 如果用伪随机探测再散列处理冲突，且伪随机数序列为：2，5，9，……..，则下一个哈希地址为H1=（3 + 2）% 11 = 5，仍然冲突，再找下一个哈希地址为H2=（3 + 5）% 11 = 8，此时不再冲突，将69填入8号单元。 再哈希法 这种方法是同时构造多个不同的哈希函数： Hi=RH1（key） i=1，2，…，k 当哈希地址Hi=RH1（key）发生冲突时，再计算Hi=RH2（key）……，直到冲突不再产生。这种方法不易产生聚集，但增加了计算时间。 3.链地址法 这种方法的基本思想是将所有哈希地址为i的元素构成一个称为同义词链的单链表，并将单链表的头指针存在哈希表的第i个单元中，因而查找、插入和删除主要在同义词链中进行。链地址法适用于经常进行插入和删除的情况。 4.建立公共溢出区 这种方法的基本思想是：将哈希表分为基本表和溢出表两部分，凡是和基本表发生冲突的元素，一律填入溢出表。 拉链法与开放地址法相比的缺点： 拉链法的优点 与开放定址法相比，拉链法有如下几个优点： ①拉链法处理冲突简单，且无堆积现象，即非同义词决不会发生冲突，因此平均查找长度较短； ②由于拉链法中各链表上的结点空间是动态申请的，故它更适合于造表前无法确定表长的情况； ③开放定址法为减少冲突，要求装填因子α较小，故当结点规模较大时会浪费很多空间。而拉链法中可取α≥1，且结点较大时，拉链法中增加的指针域可忽略不计，因此节省空间； ④在用拉链法构造的散列表中，删除结点的操作易于实现。只要简单地删去链表上相应的结点即可。而对开放地址法构造的散列表，删除结点不能简单地将被删结 点的空间置为空，否则将截断在它之后填人散列表的同义词结点的查找路径。这是因为各种开放地址法中，空地址单元(即开放地址)都是查找失败的条件。因此在 用开放地址法处理冲突的散列表上执行删除操作，只能在被删结点上做删除标记，而不能真正删除结点。 拉链法的缺点 拉链法的缺点是：指针需要额外的空间，故当结点规模较小时，开放定址法较为节省空间，而若将节省的指针空间用来扩大散列表的规模，可使装填因子变小，这又减少了开放定址法中的冲突，从而提高平均查找速度。 ","date":"2021-05-03","objectID":"/cs_interview_eight_part_questions/:5:9","tags":["互聯網","大廠","面試題","計算機網路","操作系統","Database","數據結構","演算法","MySQL","C","C++","LeetCode","CS","計算機科學","軟件工程"],"title":"互聯網公司大廠 – 面試八股文彙整","uri":"/cs_interview_eight_part_questions/"},{"categories":["Moment"],"content":"哈希表構造方式 1.直接寻址法：取关键字或关键字的某个线性函数值为散列地址。即H(key)=key或H(key) = a·key + b，其中a和b为常数（这种散列函数叫做自身函数）。若其中H(key）中已经有值了，就往下一个找，直到H(key）中没有值了，就放进去。 数字分析法：分析一组数据，比如一组员工的出生年月日，这时我们发现出生年月日的前几位数字大体相同，这样的话，出现冲突的几率就会很大，但是我们发现年月日的后几位表示月份和具体日期的数字差别很大，如果用后面的数字来构成散列地址，则冲突的几率会明显降低。因此数字分析法就是找出数字的规律，尽可能利用这些数据来构造冲突几率较低的散列地址。 平方取中法：当无法确定关键字中哪几位分布较均匀时，可以先求出关键字的平方值，然后按需要取平方值的中间几位作为哈希地址。这是因为：平方后中间几位和关键字中每一位都相关，故不同关键字会以较高的概率产生不同的哈希地址。 折叠法：将关键字分割成位数相同的几部分，最后一部分位数可以不同，然后取这几部分的叠加和（去除进位）作为散列地址。数位叠加可以有移位叠加和间界叠加两种方法。移位叠加是将分割后的每一部分的最低位对齐，然后相加；间界叠加是从一端向另一端沿分割界来回折叠，然后对齐相加。 随机数法：选择一随机函数，取关键字的随机值作为散列地址，即H(key)=random(key)其中random为随机函数,通常用于关键字长度不等的场合。 除留余数法：取关键字被某个不大于散列表表长m的数p除后所得的余数为散列地址。即 H(key) = key MOD p,p\u003c=m。不仅可以对关键字直接取模，也可在折叠、平方取中等运算之后取模。对p的选择很重要，一般取素数或m，若p选的不好，容易产生同义词。 ","date":"2021-05-03","objectID":"/cs_interview_eight_part_questions/:5:10","tags":["互聯網","大廠","面試題","計算機網路","操作系統","Database","數據結構","演算法","MySQL","C","C++","LeetCode","CS","計算機科學","軟件工程"],"title":"互聯網公司大廠 – 面試八股文彙整","uri":"/cs_interview_eight_part_questions/"},{"categories":["Moment"],"content":"順序表 顺序表是采用顺序存储结构的线性表，顺序表可理解为采用一维数组存储的线性结构（数组也是一种数据结构）顺序表的存储结果如下图所示： # include \u003cstdio.h\u003e # include \u003cstdlib.h\u003e # include \u003cmalloc.h\u003e # include \u003cstring.h\u003e # define TRUE 1 # define FALSE 0 # define OK 1 # define ERROR 0 # define INFEASIBLE -1 # define OVERFLOW -2 # define LIST_INIT_SIZE 100 # define LISTINCREMENT 10 typedef int ElemType; typedef int Status; typedef struct { ElemType *elem; int length; int listsize; }SqList; void InitList(SqList \u0026L) { L.elem = (ElemType *)malloc(LIST_INIT_SIZE * sizeof(ElemType)); memset(L.elem,0,sizeof(ElemType)*LIST_INIT_SIZE); //初始化为0 L.length = 0; L.listsize = LIST_INIT_SIZE; } void DestroyList(SqList \u0026L) { free (L.elem); } void ClearList(SqList \u0026L) { L.length = 0; } Status ListEmpty(SqList L) { if (L.length == 0) return TRUE; else return FALSE; } int ListLength(SqList L) { return L.length; } Status GetElem(SqList L,int i,ElemType \u0026e) { //判断元素位置是否合法 if(i \u003e L.length-1 || i \u003c 0){ printf(\"查找的位置不正确 \\n\"); return ERROR; } //判断线性表是否为空 if(ListEmpty(L)){ return ERROR; } e = L.elem[i]; return OK; } Status LocateElem(SqList L,ElemType e) { int i = 0; ElemType *p = L.elem; while(i\u003cL.length) { if (*p != e) { p++; i++; } else break; } if (i\u003cL.length) return i; else return -1; } Status PriorElem(SqList L,ElemType cur_e,ElemType \u0026pre_e) { if (LocateElem(L,cur_e)!=-1\u0026\u0026LocateElem(L,cur_e)!=0) { pre_e = L.elem[LocateElem(L,cur_e)-1]; return OK; } else return ERROR; } Status NextElem(SqList L,ElemType cur_e,ElemType \u0026next_e) { if (LocateElem(L,cur_e)!=-1\u0026\u0026LocateElem(L,cur_e)!=L.length-1) { next_e = L.elem[LocateElem(L,cur_e)+1]; return OK; } else return ERROR; } Status ListInsert(SqList \u0026L,int i,ElemType e) { if (i\u003e0\u0026\u0026i\u003cL.length+1) { if (L.length == L.listsize) { ElemType *newbase = (ElemType *)realloc(L.elem,(L.listsize+LISTINCREMENT)*sizeof (ElemType)); if (!newbase) exit(OVERFLOW); // 存储分配失败 L.elem = newbase; // 新基址 L.listsize += LISTINCREMENT; // 增加存储容量 } ElemType *q = \u0026(L.elem[i]); for (ElemType *p = \u0026(L.elem[L.length-1]);p\u003e=q;p--) { *(p+1)=*p; } *q=e; L.length++; return OK; } else return ERROR; } Status ListInsert(SqList \u0026L,ElemType e) { int i,j; for (j = 0; j \u003c L.length; ++j) { if(L.elem[j]\u003e=e) { i=j; break; } } if (L.length == L.listsize) { ElemType *newbase = (ElemType *)realloc(L.elem,(L.listsize+LISTINCREMENT)*sizeof (ElemType)); if (!newbase) exit(OVERFLOW); // 存储分配失败 L.elem = newbase; // 新基址 L.listsize += LISTINCREMENT; // 增加存储容量 } ElemType *q = \u0026(L.elem[i]); for (ElemType *p = \u0026(L.elem[L.length-1]);p\u003e=q;p--) { *(p+1)=*p; } *q=e; L.length++; return OK; } Status ListDelete(SqList \u0026L,int i,ElemType \u0026e) { if (i\u003e0\u0026\u0026i\u003cL.length) { ElemType *q = \u0026(L.elem[i]); e = *q; ElemType *p = \u0026(L.elem[L.length-1]); for(;q\u003cp;q++) { *q=*(q+1); } L.length--; return OK; } else return ERROR; } void ListTraverse(SqList L) { for (int i = 0; i \u003cL.length;i++) printf(\"%d \",L.elem[i]); } Status createList(SqList \u0026L) { int i; InitList(L); for(i = 0; i \u003c 10; i++){ L.elem[i] = i; } L.length = 10; return OK; } void reverse(SqList \u0026L) { int i,j; int temp; for (int i = 0,j = L.length - 1; i \u003c j; i++,j--) { temp = L.elem[i]; L.elem[i] = L.elem[j]; L.elem[j] = temp; } } Status DeleteK(SqList \u0026a,int i,int k) { if(i\u003c1||k\u003c0||i+k-1\u003ea.length) return INFEASIBLE; int count; for ( count= 0; count \u003c a.length-k; ++count) { a.elem[i-1+count] = a.elem[i-1+k+count]; } a.length-=k; } void InsertSort(SqList \u0026L) { int i,j; ElemType temp; for(i=1; i\u003cL.length; ++i) { if(L.elem[i]\u003cL.elem[i-1]) { temp = L.elem[i]; for(j=i-1;L.elem[j]\u003e=temp\u0026\u0026j\u003e=0;--j) L.elem[j+1]=L.elem[j]; L.elem[j+1] = temp; } } } Status MergeList(SqList \u0026A,SqList \u0026B) { int i,j,flag; ElemType e; for (int i = 0; i \u003c B.length; ++i) { e = B.elem[i]; for (j = 0; j \u003c A.length; ++j) { if(A.elem[j]\u003ee) //寻找插入点 { flag = j; ListInsert(A,flag,e); break; } if (A.elem[j] == e) //剔除重复元素 break; } if(j == A.length) ListInsert(A,A.length,e); } return OK; } ","date":"2021-05-03","objectID":"/cs_interview_eight_part_questions/:5:11","tags":["互聯網","大廠","面試題","計算機網路","操作系統","Database","數據結構","演算法","MySQL","C","C++","LeetCode","CS","計算機科學","軟件工程"],"title":"互聯網公司大廠 – 面試八股文彙整","uri":"/cs_interview_eight_part_questions/"},{"categories":["Moment"],"content":"順序棧 栈是一种先进后出的线性结构。只允许在栈的一端进行插入和删除操作，称为栈顶，栈的另一端称为栈底。栈顶的当前位置是动态变化的，由栈顶指针的位置指示，栈底指向栈的末尾。顺序栈使用顺序表实现，亦或者说是采用数组实现。顺序栈的示意图如下： 图示top==0 表示栈空的顺序栈，每次，入栈时先使元素入栈，然后栈顶指针+1，出栈时，先将栈顶指针top–,然后元素出栈。还可以用top==-1表示栈空，入栈时先使栈顶指针top++，然后元素入栈；出栈时先将栈顶指针top–，然后元素出栈。 #include \u003cstdio.h\u003e#include \u003cstdlib.h\u003e#define TRUE 1 #define FALSE 0 #define OK 1 #define ERROR 0 # define INFEASIBLE -1 # define OVERFLOW -2 #define STACK_INIT_SIZE 100 #define STACKINCREMENT 10 typedef int SElemType; typedef int Status; typedef struct { SElemType *base; SElemType *top; int stacksize; }SqStack; Status InitStack(SqStack \u0026S) { S.base = (SElemType *)malloc(STACK_INIT_SIZE * sizeof(SElemType)); if (!S.base) exit(OVERFLOW); S.top = S.base; S.stacksize = STACK_INIT_SIZE; return OK; } Status DestroyStack(SqStack \u0026S) { if (!S.base) return ERROR; else { free(S.base); return OK; } } Status ClearStack(SqStack \u0026S) { if (!S.base) return ERROR; else { S.top = S.base; return OK; } } Status StackEmpty(SqStack S) { if (S.base\u0026\u0026S.top == S.base) return TRUE; else return FALSE; } Status StackLength(SqStack S) { if (S.base) return S.top-S.base; else return ERROR; } Status GetTop(SqStack S, SElemType \u0026e) { if (S.top == S.base) return ERROR; else { e = *(S.top-1); return OK; } } Status Push(SqStack \u0026S, SElemType e) { if (S.top - S.base \u003e= S.stacksize) { S.base = (SElemType *)realloc(S.base, (S.stacksize + STACKINCREMENT)*sizeof(SElemType)); if (!S.base) exit(OVERFLOW); S.top = S.base + S.stacksize; S.stacksize += STACKINCREMENT; } *S.top = e; S.top++; return OK; } Status Pop(SqStack \u0026S, SElemType \u0026e) { if (S.top == S.base) return ERROR; else { S.top--; e = *(S.top); return OK; } } Status StackTraverse(SqStack S) { SElemType *p; p = S.base; for (;p \u003c S.top; p++) printf(\"%d \",*p); } ","date":"2021-05-03","objectID":"/cs_interview_eight_part_questions/:5:12","tags":["互聯網","大廠","面試題","計算機網路","操作系統","Database","數據結構","演算法","MySQL","C","C++","LeetCode","CS","計算機科學","軟件工程"],"title":"互聯網公司大廠 – 面試八股文彙整","uri":"/cs_interview_eight_part_questions/"},{"categories":["Moment"],"content":"鏈表 单链表是采用链式存储结构的线性表。数据元素存储在非连续的内存单元中，通过指针将各个内存单元链接在一起，最有一个节点的指针指向 NULL 。单链表不需要提前分配固定大小存储空间，当需要存储数据的时候分配一块内存并将这块内存插入链表中。 单链表是由一系列结点组成的，通过指针域把结点按照线性表中的逻辑元素连接在一起。为了能正确表示结点间的逻辑关系，在存储每个结点值的同时，还必须存储指示其后继结点的地址（或位置）信息，这个信息称为指针(pointer)或链(link)。这两部分组成了链表中的结点结构，单链表的结点结结构如下图： 使用箭头表示链表中的指针，单链表的可以表示成用箭头连接起来的结点序列，如下图所示： 图示为带头结点的单链表，实际上单链表是没有头结点的，头结点只是为了操作方便，在单链表的第一个结点前附设的一个结点使用头指针指向头结点。不带头结点的单链表，头指针指向第一个结点，判空条件为pHead == NULL； # include \u003cstdio.h\u003e # include \u003cstdlib.h\u003e # include \u003cmalloc.h\u003e # include \u003cstring.h\u003e # define TRUE 1 # define FALSE 0 # define OK 1 # define ERROR 0 # define INFEASIBLE -1 # define OVERFLOW -2 typedef int ElemType; typedef int Status; typedef struct Node { ElemType data; struct Node *next; }Node; typedef struct Node *LinkList; Status InitList(LinkList \u0026L) { L=(LinkList)malloc(sizeof(Node)); /* 产生头结点,并使L指向此头结点 */ if(L==NULL) /* 存储分配失败 */ return ERROR; (L)-\u003enext=NULL; /* 指针域为空 */ return OK; } void DestroyList(LinkList \u0026L) { LinkList p,q; p=L-\u003enext; /* p指向第一个结点 */ while(p) /* 没到表尾 */ { q=p-\u003enext; free(p); p=q; } free(L); /* 释放头节点的空间 */ } Status ClearList(LinkList \u0026L)/*只留下头节点，其余释放*/ { LinkList p,q; p=L-\u003enext; /* p指向第一个结点 */ while(p) /* 没到表尾 */ { q=p-\u003enext; free(p); p=q; } L-\u003enext=NULL; return OK; } Status ListEmpty(LinkList L) { if (L-\u003enext==NULL) return TRUE; else return FALSE; } int ListLength(LinkList L) { int i=0; LinkList p=L-\u003enext; while(p) { i++; p=p-\u003enext; } return i; } Status GetElem(LinkList L,int i,ElemType *e) { int j; LinkList p; /* 声明一结点p */ p = L-\u003enext; /* 让p指向链表L的第一个结点 */ j = 1; /* j为计数器 */ while (p \u0026\u0026 j\u003ci) /* p不为空或者计数器j还没有等于i时，循环继续 */ { p = p-\u003enext; /* 让p指向下一个结点 */ ++j; } if ( !p || j\u003ei ) return ERROR; /* 第i个元素不存在 */ *e = p-\u003edata; /* 取第i个元素的数据 */ return OK; } Status LocateElem(LinkList L,ElemType e) { int i = 0; LinkList p=L-\u003enext; while(p) { i++; if (p-\u003edata!=e) p=p-\u003enext; else break; } if (i\u003e0\u0026\u0026i\u003cListLength(L)) return i; else { printf(\"查找失败！\"); return FALSE; } } Status PriorElem(LinkList L,ElemType cur_e,ElemType \u0026pre_e) { LinkList p=L-\u003enext; if (cur_e==p-\u003edata) { printf(\"不存在前驱！\"); return ERROR; } else { while(p) { if (p-\u003enext-\u003edata==cur_e) { pre_e=p-\u003edata; break; } else p=p-\u003enext; } } if (!p) { printf(\"无此数据！\"); return ERROR; } } Status NextElem(LinkList L,ElemType cur_e,ElemType \u0026next_e) { LinkList p=L-\u003enext; while(p) { if (p-\u003edata==cur_e) { if (p-\u003enext!=NULL) { next_e=p-\u003enext-\u003edata; break; } else { printf(\"不存在后继！\"); return ERROR; } } else p=p-\u003enext; } if (!p) { printf(\"无此数据！\"); return ERROR; } } Status ListInsert(LinkList \u0026L,int i,ElemType e) { LinkList p,s; p = L; int j = 0; while (p \u0026\u0026 j \u003c i-1) /* 寻找第i-1个结点 */ { p = p-\u003enext; ++j; } if (!p || j \u003e i-1) return ERROR; /* 第i-1个元素不存在 */ s = (LinkList)malloc(sizeof(Node)); s-\u003edata = e; s-\u003enext = p-\u003enext; /* 将p的后继结点赋值给s的后继 */ p-\u003enext = s; /* 将s赋值给p的后继 */ return OK; } Status ListDelete(LinkList L,int i,ElemType \u0026e) { int j; LinkList p,q; p = L; j = 0; while (p-\u003enext \u0026\u0026 j \u003c i-1) /* 寻找前驱，即第i-1个元素 */ { p = p-\u003enext; ++j; } if (!(p-\u003enext) || j \u003e i) return ERROR; /* 第i个元素不存在 */ q = p-\u003enext; p-\u003enext = q-\u003enext; /* 将q的后继赋值给p的后继 */ e = q-\u003edata; /* 将q结点中的数据给e */ free(q); /* 让系统回收此结点，释放内存 */ return OK; } void creatList(LinkList \u0026L) { int i; LinkList p; InitList(L); for (i = 9; i \u003e=0; i--) { p = (LinkList)malloc(sizeof(Node)); p-\u003edata = i; p-\u003enext = L-\u003enext; L-\u003enext = p; } } void ListTraverse(LinkList L) { LinkList p=L-\u003enext; while(p) { printf(\"%d \",p-\u003edata); p=p-\u003enext; } } void reverse(LinkList \u0026L) { LinkList p,q; p = L-\u003enext;L-\u003enext = NULL; while(p) { q = p-\u003enext; p-\u003enext = L-\u003enext; L-\u003enext = p; p = q; } } void InsertSort(LinkList \u0026L) { LinkList p,q,temp,p_prior; LinkList first; first = L-\u003enext-\u003enext; L-\u003enext-\u003enext = NULL; while(first) { p_prior = L; p = p_prior-\u003enext; //重置为L的表头 temp = first; first = first-\u003enext; temp-\u003enext = NULL; while(p-\u003enext!=NULL\u0026\u0026p-\u003edata \u003c temp-\u003edata) { p_prior = p; p = p-\u003enext; } if(p-\u003edata \u003e= temp-\u003edata) { temp-\u003enext = p_prior-\u003enext; p_prior-\u003enext = temp; } else { temp-\u003enext = NULL; p-\u003enext = temp; } } } Status MergeList(LinkList \u0026A,LinkList \u0026B) {","date":"2021-05-03","objectID":"/cs_interview_eight_part_questions/:5:13","tags":["互聯網","大廠","面試題","計算機網路","操作系統","Database","數據結構","演算法","MySQL","C","C++","LeetCode","CS","計算機科學","軟件工程"],"title":"互聯網公司大廠 – 面試八股文彙整","uri":"/cs_interview_eight_part_questions/"},{"categories":["Moment"],"content":"鏈棧 #include \u003cstdio.h\u003e#include \u003cstdlib.h\u003e#define TRUE 1 #define FALSE 0 #define OK 1 #define ERROR 0 # define INFEASIBLE -1 # define OVERFLOW -2 #define STACK_INIT_SIZE 100 #define STACKINCREMENT 10 typedef int SElemType; typedef int Status; typedef struct Node { SElemType data; struct Node *next; }StackNode; typedef struct Node *LinkStack; Status InitStack(LinkStack \u0026top) { top = (LinkStack)malloc(sizeof(StackNode)); if (top == NULL) exit(OVERFLOW); else { top-\u003enext = NULL; return OK; } } Status DestroyStack(LinkStack \u0026top) { LinkStack p; if (!top) return INFEASIBLE; else { while(top) { p = top; top = top-\u003enext; free(p); } return OK; } } Status ClearStack(LinkStack \u0026top) { LinkStack p = top-\u003enext, q; if (!top) return INFEASIBLE; else { while(p) { q = p-\u003enext; free(p); p = q; } top-\u003enext = NULL; } } Status StackEmpty(LinkStack top) { if (!top) return INFEASIBLE; else if (top-\u003enext == NULL) return TRUE; else return FALSE; } Status StackLength(LinkStack top) { LinkStack p; int i = 0; if (!top) return INFEASIBLE; else { p = top-\u003enext; while(p) { i++; p = p-\u003enext; } } return i; } Status GetTop(LinkStack top, SElemType \u0026e) { if (!top) return INFEASIBLE; else { if(top-\u003enext != NULL) { e = top-\u003enext-\u003edata; return OK; } else return ERROR; } } Status Push(LinkStack \u0026top, SElemType e) { if (!top) return INFEASIBLE; else { LinkStack p = (LinkStack)malloc(sizeof(StackNode)); p-\u003edata = e; p-\u003enext = top-\u003enext; top-\u003enext = p; return OK; } } Status Pop(LinkStack \u0026top, SElemType \u0026e) { LinkStack p; if (!top||!top-\u003enext) return INFEASIBLE; else { p = top-\u003enext; top-\u003enext = p-\u003enext; e = p-\u003edata; free(p); return OK; } } Status StackTraverse(LinkStack top) { LinkStack p = top-\u003enext; while(p) { printf(\"%d \",p-\u003edata); p = p-\u003enext; } } ","date":"2021-05-03","objectID":"/cs_interview_eight_part_questions/:5:14","tags":["互聯網","大廠","面試題","計算機網路","操作系統","Database","數據結構","演算法","MySQL","C","C++","LeetCode","CS","計算機科學","軟件工程"],"title":"互聯網公司大廠 – 面試八股文彙整","uri":"/cs_interview_eight_part_questions/"},{"categories":["Moment"],"content":"單鏈隊列 队列是一种先进先出的线性结构，只允许在表的一端进行插入和删除操作，当然：双端队列除外，允许插入的一端称为队尾，允许删除的一端称为队头。 由于在入队和出队的过程中队头指针和队尾指针只增加不减小，致使被删除元素的空间无法被重新利用，因此，可能会存在这样一种情况：尽管，队列中实际元素个数远远小于数组大小（队列长度）但可能尾指针已超出数组空间的上界，而不能进行入队操作，这种现象，称之为“假溢出”。 为了充分利用存储空间，消除这种”假溢出”,可以采用的方法是：将为队列分配的空间看成为一个首尾相接的圆环，并称这种队列为循环队列。 在循环队列中当队尾指针rear 达到最大值Maxsize - 1 时，其队尾指针加1操作，使其指向队头指针，这一过程可以使用数学中的取余运算来实现。 #include\u003cstdio.h\u003e#include\u003cstdlib.h\u003e#define TRUE 1 #define FALSE 0 #define OK 1 #define ERROR 0 # define INFEASIBLE -1 # define OVERFLOW -2 typedef int ElemType; typedef int Status; typedef struct QNode { ElemType data; struct QNode *next; }QNode,* QueuePtr; typedef struct { QueuePtr front; //队头指针 QueuePtr rear; //队尾指针 }LinkQueue; Status InitQueue(LinkQueue \u0026Q) { Q.front = Q.rear = (QueuePtr)malloc(sizeof(QNode)); if (!Q.front) exit(OVERFLOW); Q.front-\u003enext = NULL; return OK; } Status DestroyQueue(LinkQueue \u0026Q) { while(Q.front) { Q.rear = Q.front-\u003enext; free (Q.front); Q.front = Q.rear; } return OK; } Status ClearQueue(LinkQueue \u0026Q) { QueuePtr p,q; p = Q.front-\u003enext; while(p) { q = p-\u003enext; free (p); p = q; } Q.rear = Q.front; } Status QueueEmpty(LinkQueue Q) { if (Q.front == Q.rear) return TRUE; else return FALSE; } int QueueLength(LinkQueue Q) { QueuePtr p; int i = 0; p = Q.front-\u003enext; while(p) { i++; p = p-\u003enext; } return i; } Status GetHead(LinkQueue Q, ElemType \u0026e) { if (!QueueEmpty(Q)) { Q.front = Q.front-\u003enext; e = Q.front-\u003edata; return OK; } else return ERROR; } Status EnQueue(LinkQueue \u0026Q, ElemType e) { QueuePtr p = (QueuePtr)malloc(sizeof(QNode)); if(!p) exit(OVERFLOW); p-\u003edata = e; p-\u003enext = NULL; Q.rear-\u003enext = p; Q.rear = p; return OK; } Status DeQueue(LinkQueue \u0026Q, ElemType \u0026e) { QueuePtr p; if (Q.front == Q.rear) return ERROR; else { p = Q.front-\u003enext; e = p-\u003edata; Q.front-\u003enext = p-\u003enext; if (Q.rear == p) //出队结点为队尾结点 Q.rear = Q.front; free (p); return OK; } } Status QueueTraverse(LinkQueue Q) { QueuePtr p; p = Q.front-\u003enext; while(p) { printf(\"%d \",p-\u003edata); p = p-\u003enext; } } ","date":"2021-05-03","objectID":"/cs_interview_eight_part_questions/:5:15","tags":["互聯網","大廠","面試題","計算機網路","操作系統","Database","數據結構","演算法","MySQL","C","C++","LeetCode","CS","計算機科學","軟件工程"],"title":"互聯網公司大廠 – 面試八股文彙整","uri":"/cs_interview_eight_part_questions/"},{"categories":["Moment"],"content":"二插樹 二叉树（Binary Tree）是包含n个节点的有限集合，该集合或者为空集（此时，二叉树称为空树），或者由一个根节点和两棵互不相交的、分别称为根节点的左子树和右子树的二叉树组成。 一棵典型的二叉树如下图所示： 由上述的定义可以看出，二叉树中的节点至多包含两棵子树，分别称为左子树和右子树，而左子树和右子树又分别至多包含两棵子树。由上述的定义，二叉树的定义是一种递归的定义。 一些常见的二叉树 满二叉树 对于一棵二叉树，如果每一个非叶子节点都存在左右子树，并且二叉树中所有的叶子节点都在同一层中，这样的二叉树称为满二叉树。 一棵满二叉树如下图所示： 完全二叉树 对于一棵具有n个节点的二叉树按照层次编号，同时，左右子树按照先左后右编号，如果编号为i的节点与同样深度的满二叉树中编号为i的节点在二叉树中的位置完全相同，则这棵二叉树称为完全二叉树。 一棵完全二叉树如下图所示： 二叉树的一些性质 对于二叉树，包含一些性质： 在二叉树中，第 i层上至多有$2^(i−1)$个节点（i≥1） 深度为k的二叉树至多有$2^(k−1)$个节点（k≥1） 对一棵二叉树，如果叶子节点的个数为$n_0$，度为2的节点个数为$n_2$，则$n_0=n_2+1$ 具有n个节点的完全二叉树的深度为$⌊log_2 n⌋+1$ #include \u003ciostream\u003e#include \u003cstdlib.h\u003e#include \u003cstack\u003e#include \u003cqueue\u003e using namespace std; #define TRUE 1 #define FALSE 0 #define OK 1 #define ERROR 0 #define OVERFLOW -2 typedef char ElemType; typedef int Status; typedef struct BiTNode { ElemType data; struct BiTNode *lchild, *rchild; }BiTNode, *BiTree; typedef struct { BiTree ptr; bool tag; //0为左子数 1为右子树 }stacknode; Status CreateBiTree(BiTree \u0026T) { char ch; scanf(\"%c\",\u0026ch); if(ch == ' ') T = NULL; else { if(!(T = (BiTNode *)malloc(sizeof(BiTNode)))) exit(OVERFLOW); T-\u003edata = ch; CreateBiTree(T-\u003elchild); CreateBiTree(T-\u003erchild); } return OK; } int BiTreeDepth(BiTree \u0026T) //求树的深度 { if(T == NULL) return 0; else { int lDepth,rDepth; lDepth = BiTreeDepth(T-\u003elchild); rDepth = BiTreeDepth(T-\u003erchild); if(lDepth \u003e rDepth) return lDepth + 1; else return rDepth + 1; } } int BiTreeWidth(BiTree \u0026T) { if(T == NULL) return 0; int nLastLevelWidth = 0;//记录上一层的宽度 int nTempLastLevelWidth = 0; int nCurLevelWidth = 0;//记录当前层的宽度 int nWidth = 1;//二叉树的宽度 BiTree cur; queue\u003cBiTree\u003e q; q.push(T); nLastLevelWidth = 1; nWidth = 1; while(!q.empty()) { nTempLastLevelWidth = nLastLevelWidth; while (nTempLastLevelWidth != 0) { cur = q.front();//取出队列头元素 q.pop(); //将队列头元素出对 if (cur-\u003elchild != NULL) { q.push(cur-\u003elchild); } if (cur-\u003erchild != NULL) { q.push(cur-\u003erchild); } nTempLastLevelWidth--; } nCurLevelWidth = q.size(); nWidth = nCurLevelWidth \u003e nWidth ? nCurLevelWidth : nWidth; nLastLevelWidth = nCurLevelWidth; } return nWidth; } void PreOrderTraverse(BiTree T) { stack\u003cBiTree\u003e s; BiTree p; p = T; while(p != NULL||!s.empty()) { while(p != NULL) { printf(\"%c \", p-\u003edata); s.push(p); p = p-\u003elchild; } if(!s.empty()) { p = s.top(); s.pop(); p = p-\u003erchild; } } } void InOrderTraverse(BiTree T) { stack\u003cBiTree\u003e s; BiTree p; p = T; while(p != NULL||!s.empty()) { while(p != NULL) { s.push(p); p = p-\u003elchild; } if(!s.empty()) { p = s.top(); s.pop(); printf(\"%c \", p-\u003edata); p = p-\u003erchild; } } } void PostOrderTraverse(BiTree T) { stacknode x; stack\u003cstacknode\u003e s; BiTree p; p = T; while(p) { x.ptr = p; x.tag = 0; s.push(x); p = p-\u003elchild; } while(!s.empty()){ x = s.top(); if(x.ptr-\u003erchild == NULL||x.tag == 1){ //没有右子树或者右子树已经访问过 s.pop(); printf(\"%c \",x.ptr-\u003edata); } else{ s.top().tag = 1; p = x.ptr-\u003erchild; while(p) { x.ptr = p; x.tag = 0; s.push(x); p = p-\u003elchild; } } } } void LevelOrderTraverse(BiTree T) //层次遍历 { BiTree p; p = T; if (!T) { return; } queue\u003cBiTree\u003e Q; Q.push(p); while (!Q.empty()) { p = Q.front(); Q.pop(); printf(\"%c \",p-\u003edata); if (p-\u003elchild) Q.push(p-\u003elchild); if (p-\u003erchild) Q.push(p-\u003erchild); } } void PreOrderTraverse_recursion(BiTree T) { if(T!=NULL) { printf(\"%c \",T-\u003edata); PreOrderTraverse_recursion(T-\u003elchild); PreOrderTraverse_recursion(T-\u003erchild); } } void InOrderTraverse_recursion(BiTree T) //递归中序遍历 { if(T!=NULL) { InOrderTraverse_recursion(T-\u003elchild); printf(\"%c \",T-\u003edata); InOrderTraverse_recursion(T-\u003erchild); } } void PostOrderTraverse_recursion(BiTree T) //递归后序遍历 { if(T!=NULL) { PostOrderTraverse_recursion(T-\u003elchild); PostOrderTraverse_recursion(T-\u003erchild); printf(\"%c \",T-\u003edata); } } int LeafNode(BiTree T) //求叶子结点个数 { if(T == NULL) return 0; if(T-\u003elchild == NULL \u0026\u0026 T-\u003erchild == NULL) return 1; return LeafNode(T-\u003elchild) + LeafNode(T-\u003erchild); } void exchange(BiTree T) //交换左右子树 { BiTree temp = NULL; if(T-\u003elchild == NULL \u0026\u0026 T-\u003erchild == NULL) return; else{ temp = T-\u003elchild; T-\u003elchild = T-\u003erchild; T-\u003erchild = temp; } if(T-\u003elchild) exchange(T-\u003elchild); i","date":"2021-05-03","objectID":"/cs_interview_eight_part_questions/:5:16","tags":["互聯網","大廠","面試題","計算機網路","操作系統","Database","數據結構","演算法","MySQL","C","C++","LeetCode","CS","計算機科學","軟件工程"],"title":"互聯網公司大廠 – 面試八股文彙整","uri":"/cs_interview_eight_part_questions/"},{"categories":["Moment"],"content":"堆 #include \u003ciostream\u003eusing namespace std; int capacity = 10; //最大堆 void insertHeap(int *heap, int newValue) { if (heap[0] \u003e= capacity) { cout \u003c\u003c \"the heap is full\" \u003c\u003c endl; exit(0); } heap[0]++; heap[heap[0]] = newValue; int index = heap[0]; int parentIndex = heap[0] / 2; while (index != 1 \u0026\u0026 heap[parentIndex] \u003c heap[index]) { int tmp = heap[parentIndex]; heap[parentIndex] = heap[index]; heap[index] = tmp; index = parentIndex; parentIndex = index / 2; } } int deleteMax(int *heap) { if (heap[0] == 0) { cout \u003c\u003c \"the heap is empty\"; exit(0); } int max = heap[1]; heap[1] = heap[heap[0]]; heap[0]--; int index = 1; int leftIndex = index * 2; int rightIndex = leftIndex + 1; int maxIndex = heap[rightIndex] \u003e heap[leftIndex] ? rightIndex : leftIndex; while (heap[index] \u003c heap[maxIndex] \u0026\u0026 index \u003c= heap[0] - (heap[0]+1) / 2) { int tmp = heap[index]; heap[index] = heap[maxIndex]; heap[maxIndex] = tmp; index = maxIndex; leftIndex = index * 2; rightIndex = leftIndex + 1; maxIndex = heap[rightIndex] \u003e heap[leftIndex] ? rightIndex : leftIndex; } return max; } void printHeap(int *heap) { for (int i = 1; i \u003c= heap[0]; i++) { cout \u003c\u003c heap[i] \u003c\u003c \" \"; } cout \u003c\u003c endl; } int main() { int *heap = new int[capacity + 1]; heap[0] = 0; insertHeap(heap, 1); insertHeap(heap, 8); insertHeap(heap, 10); insertHeap(heap, 3); printHeap(heap); cout \u003c\u003c deleteMax(heap) \u003c\u003c endl; printHeap(heap); delete[] heap; } ","date":"2021-05-03","objectID":"/cs_interview_eight_part_questions/:5:17","tags":["互聯網","大廠","面試題","計算機網路","操作系統","Database","數據結構","演算法","MySQL","C","C++","LeetCode","CS","計算機科學","軟件工程"],"title":"互聯網公司大廠 – 面試八股文彙整","uri":"/cs_interview_eight_part_questions/"},{"categories":["Moment"],"content":"數據庫 ","date":"2021-05-03","objectID":"/cs_interview_eight_part_questions/:6:0","tags":["互聯網","大廠","面試題","計算機網路","操作系統","Database","數據結構","演算法","MySQL","C","C++","LeetCode","CS","計算機科學","軟件工程"],"title":"互聯網公司大廠 – 面試八股文彙整","uri":"/cs_interview_eight_part_questions/"},{"categories":["Moment"],"content":"熟悉基本 SQL 操作 我的blog筆記 : https://huangno1.github.io/mysql_learn_note_basic/ 1.包括增删改查（insert、delete、update、select语句），排序 order，条件查询（where 子语句），限制查询结果数量（LIMIT语句）等 2.稍微高级一点的 SQL 操作（如Group by，in，join，left join，多表联合查询，别名的使用，select 子语句等） 3.索引的概念、索引的原理、索引的创建技巧 4.数据库本身的操作，建库建表，数据的导入导出 5.数据库用户权限控制（权限机制） ","date":"2021-05-03","objectID":"/cs_interview_eight_part_questions/:6:1","tags":["互聯網","大廠","面試題","計算機網路","操作系統","Database","數據結構","演算法","MySQL","C","C++","LeetCode","CS","計算機科學","軟件工程"],"title":"互聯網公司大廠 – 面試八股文彙整","uri":"/cs_interview_eight_part_questions/"},{"categories":["Moment"],"content":"SQL 优化技巧 https://www.jianshu.com/p/25c958196a0b 1、应尽量避免在 where 子句中使用!=或\u003c\u003e操作符，否则将引擎放弃使用索引而进行全表扫描。 2、对查询进行优化，应尽量避免全表扫描，首先应考虑在 where 及 order by 涉及的列上建立索引。 3、应尽量避免在 where 子句中对字段进行 null 值判断，否则将导致引擎放弃使用索引而进行全表扫描，如： select id from t where num is null 可以在num上设置默认值0，确保表中num列没有null值，然后这样查询： select id from t where num=0 4、尽量避免在 where 子句中使用 or 来连接条件，否则将导致引擎放弃使用索引而进行全表扫描，如： select id from t where num=10 or num=20 可以这样查询： select id from t where num=10 union all select id from t where num=20 5、下面的查询也将导致全表扫描：(不能前置百分号) select id from t where name like ‘�c%’ 若要提高效率，可以考虑全文检索。 6、in 和 not in 也要慎用，否则会导致全表扫描，如： select id from t where num in(1,2,3) 对于连续的数值，能用 between 就不要用 in 了： select id from t where num between 1 and 3 7、如果在 where 子句中使用参数，也会导致全表扫描。因为SQL只有在运行时才会解析局部变量，但优化程序不能将访问计划的选择推迟到运行时；它必须在编译时进行选择。然 而，如果在编译时建立访问计划，变量的值还是未知的，因而无法作为索引选择的输入项。如下面语句将进行全表扫描： select id from t where num=@num 可以改为强制查询使用索引： select id from t with(index(索引名)) where num=@num 8、应尽量避免在 where 子句中对字段进行表达式操作，这将导致引擎放弃使用索引而进行全表扫描。如： select id from t where num/2=100 应改为: select id from t where num=100*2 9、应尽量避免在where子句中对字段进行函数操作，这将导致引擎放弃使用索引而进行全表扫描。如： select id from t where substring(name,1,3)=’abc’–name以abc开头的id select id from t where datediff(day,createdate,’2005-11-30′)=0–’2005-11-30′生成的id 应改为: select id from t where name like ‘abc%’ select id from t where createdate\u003e=’2005-11-30′ and createdate\u003c’2005-12-1′ 10、不要在 where 子句中的“=”左边进行函数、算术运算或其他表达式运算，否则系统将可能无法正确使用索引。 11、在使用索引字段作为条件时，如果该索引是复合索引，那么必须使用到该索引中的第一个字段作为条件时才能保证系统使用该索引，否则该索引将不会被使 用，并且应尽可能的让字段顺序与索引顺序相一致。 12、不要写一些没有意义的查询，如需要生成一个空表结构： select col1,col2 into #t from t where 1=0 这类代码不会返回任何结果集，但是会消耗系统资源的，应改成这样： create table #t(…) 13、很多时候用 exists 代替 in 是一个好的选择： select num from a where num in(select num from b) 用下面的语句替换： select num from a where exists(select 1 from b where num=a.num) 14、并不是所有索引对查询都有效，SQL是根据表中数据来进行查询优化的，当索引列有大量数据重复时，SQL查询可能不会去利用索引，如一表中有字段 sex，male、female几乎各一半，那么即使在sex上建了索引也对查询效率起不了作用。 15、索引并不是越多越好，索引固然可以提高相应的 select 的效率，但同时也降低了 insert 及 update 的效率，因为 insert 或 update 时有可能会重建索引，所以怎样建索引需要慎重考虑，视具体情况而定。一个表的索引数最好不要超过6个，若太多则应考虑一些不常使用到的列上建的索引是否有 必要。 16.应尽可能的避免更新 clustered 索引数据列，因为 clustered 索引数据列的顺序就是表记录的物理存储顺序，一旦该列值改变将导致整个表记录的顺序的调整，会耗费相当大的资源。若应用系统需要频繁更新 clustered 索引数据列，那么需要考虑是否应将该索引建为 clustered 索引。 17、尽量使用数字型字段，若只含数值信息的字段尽量不要设计为字符型，这会降低查询和连接的性能，并会增加存储开销。这是因为引擎在处理查询和连接时会 逐个比较字符串中每一个字符，而对于数字型而言只需要比较一次就够了。 18、尽可能的使用 varchar/nvarchar 代替 char/nchar ，因为首先变长字段存储空间小，可以节省存储空间，其次对于查询来说，在一个相对较小的字段内搜索效率显然要高些。 19、任何地方都不要使用 select * from t ，用具体的字段列表代替“*”，不要返回用不到的任何字段。 20、尽量使用表变量来代替临时表。如果表变量包含大量数据，请注意索引非常有限（只有主键索引）。 21、避免频繁创建和删除临时表，以减少系统表资源的消耗。 22、临时表并不是不可使用，适当地使用它们可以使某些例程更有效，例如，当需要重复引用大型表或常用表中的某个数据集时。但是，对于一次性事件，最好使 用导出表。 23、在新建临时表时，如果一次性插入数据量很大，那么可以使用 select into 代替 create table，避免造成大量 log ，以提高速度；如果数据量不大，为了缓和系统表的资源，应先create table，然后insert。 24、如果使用到了临时表，在存储过程的最后务必将所有的临时表显式删除，先 truncate table ，然后 drop table ，这样可以避免系统表的较长时间锁定。 25、尽量避免使用游标，因为游标的效率较差，如果游标操作的数据超过1万行，那么就应该考虑改写。 26、使用基于游标的方法或临时表方法之前，应先寻找基于集的解决方案来解决问题，基于集的方法通常更有效。 27、与临时表一样，游标并不是不可使用。对小型数据集使用 FAST_FORWARD 游标通常要优于其他逐行处理方法，尤其是在必须引用几个表才能获得所需的数据时。在结果集中包括“合计”的例程通常要比使用游标执行的速度快。如果开发时 间允许，基于游标的方法和基于集的方法都可以尝试一下，看哪一种方法的效果更好。 28、在所有的存储过程和触发器的开始处设置 SET NOCOUNT ON ，在结束时设置 SET NOCOUNT OFF 。无需在执行存储过程和触发器的每个语句后向客户端发送 DONE_IN_PROC 消息。 29、尽量避免向客户端返回大数据量，若数据量过大，应该考虑相应需求是否合理。 30、尽量避免大事务操作，提高系统并发能力。 ","date":"2021-05-03","objectID":"/cs_interview_eight_part_questions/:6:2","tags":["互聯網","大廠","面試題","計算機網路","操作系統","Database","數據結構","演算法","MySQL","C","C++","LeetCode","CS","計算機科學","軟件工程"],"title":"互聯網公司大廠 – 面試八股文彙整","uri":"/cs_interview_eight_part_questions/"},{"categories":["Moment"],"content":"Mysql中有哪两种存储类型有什么区别？ https://blog.csdn.net/qq_35181209/article/details/78030110 InnoDB： （1）具有事务(commit)、回滚(rollback)和崩溃修复能力(crash recovery capabilities)的事务安全(transaction-safe (ACID compliant))型表。 （2）支持外键。 （3）InnoDB 中不保存表的具体行数，也就是说，执行select count() from table时，InnoDB要扫描一遍整个表来计算有多少行。注意的是，当count()语句包含 where条件时，两种表的操作是一样的。 （4）对于AUTO_INCREMENT类型的字段，InnoDB中必须包含只有该字段的索引。 （5）DELETE FROM table时，InnoDB不会重新建立表，而是一行一行的删除。 MyISAM： （1）不支持事务操作。 （2）不支持外键。 （3）MyISAM保存表的具体行数，执行select count(*) from table时只要简单的读出保存好的行数即可。 （4）对于AUTO_INCREMENT类型的字段，在MyISAM表中，可以和其他字段一起建立联合索引。 （5）MyISAM存储引擎的读锁和写锁是互斥的，读写操作是串行的。那么，一个进程请求某个MyISAM表的读锁，同时另一个进程也请求同一表的写锁，MySQL如何处理呢？答案是写进程先获得锁。不仅如此，即使读请求先到锁等待队列，写请求后到，写锁也会插到读锁请求之前！这是因为MySQL认为写请求一般比读请求要重要。这也正是MyISAM表不太适合于有大量更新操作和查询操作应用的原因，因为，大量的更新操作会造成查询操作很难获得读锁，从而可能永远阻塞。这种情况有时可能会变得非常糟糕！ myisam是有读锁和写锁(2个锁都是表级别锁)。 MySQL表级锁有两种模式：表共享读锁（Table Read Lock）和表独占写锁（Table Write Lock）。什么意思呢，就是说对MyISAM表进行读操作时，它不会阻塞其他用户对同一表的读请求，但会阻塞对同一表的写操作；而对MyISAM表的写操作，则会阻塞其他用户对同一表的读和写操作。 ","date":"2021-05-03","objectID":"/cs_interview_eight_part_questions/:6:3","tags":["互聯網","大廠","面試題","計算機網路","操作系統","Database","數據結構","演算法","MySQL","C","C++","LeetCode","CS","計算機科學","軟件工程"],"title":"互聯網公司大廠 – 面試八股文彙整","uri":"/cs_interview_eight_part_questions/"},{"categories":["Moment"],"content":"innodb，所以为什么使用B+树，而不用B树，在InnoDB中存储数据用什么作为主键？可不可以使用UUID，为什么？ 自閉中 为什么mysql innodb索引是B+树数据结构 https://blog.csdn.net/xuehuagongzi000/article/details/78985844?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.control\u0026dist_request_id=1328696.1340.16166728491645397\u0026depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.control 一、为什么mysql innodb索引是B+树数据结构？言简意赅，就是因为： 1.文件很大，不可能全部存储在内存中，故要存储到磁盘上 2.索引的结构组织要尽量减少查找过程中磁盘I/O的存取次数（为什么使用B-/+Tree，还跟磁盘存取原理有关。） 3、B+树所有的Data域在叶子节点，一般来说都会进行一个优化，就是将所有的叶子节点用指针串起来，这样遍历叶子节点就能获得全部数据。 二、什么是聚簇索引？ 像innodb中,主键的索引结构中,既存储了主键值,又存储了行数据,这种结构称为”聚簇索引” 三、为什么MongoDB采用B树索引，而Mysql用B+树做索引 先从数据结构的角度来答。 题主应该知道B-树和B+树最重要的一个区别就是B+树只有叶节点存放数据，其余节点用来索引，而B-树是每个索引节点都会有Data域。 这就决定了B+树更适合用来存储外部数据，也就是所谓的磁盘数据。 从Mysql（Inoodb）的角度来看，B+树是用来充当索引的，一般来说索引非常大，尤其是关系性数据库这种数据量大的索引能达到亿级别，所以为了减少内存的占用，索引也会被存储在磁盘上。 那么Mysql如何衡量查询效率呢？磁盘IO次数，B-树（B类树）的特定就是每层节点数目非常多，层数很少，目的就是为了就少磁盘IO次数，当查询数据的时候，最好的情况就是很快找到目标索引，然后读取数据，使用B+树就能很好的完成这个目的，但是B-树的每个节点都有data域（指针），这无疑增大了节点大小，说白了增加了磁盘IO次数（磁盘IO一次读出的数据量大小是固定的，单个数据变大，每次读出的就少，IO次数增多，一次IO多耗时啊！），原因1：B+树除了叶子节点其它节点并不存储数据，节点小，磁盘IO次数就少。 原因2：B+树所有的Data域在叶子节点，一般来说都会进行一个优化，就是将所有的叶子节点用指针串起来。这样遍历叶子节点就能获得全部数据。 至于MongoDB为什么使用B-树而不是B+树，可以从它的设计角度来考虑，它并不是传统的关系性数据库，而是以Json格式作为存储的nosql，目的就是高性能，高可用，易扩展。首先它摆脱了关系模型，上面所述的优点2需求就没那么强烈了，其次Mysql由于使用B+树，数据都在叶节点上，每次查询都需要访问到叶节点，而MongoDB使用B-树，所有节点都有Data域，只要找到指定索引就可以进行访问，无疑单次查询平均快于Mysql（但侧面来看Mysql至少平均查询耗时差不多）。 总体来说，Mysql选用B+树和MongoDB选用B-树还是以自己的需求来选择的。 MySQL InnoDB索引的存储结构 https://zhuanlan.zhihu.com/p/110178282 ","date":"2021-05-03","objectID":"/cs_interview_eight_part_questions/:6:4","tags":["互聯網","大廠","面試題","計算機網路","操作系統","Database","數據結構","演算法","MySQL","C","C++","LeetCode","CS","計算機科學","軟件工程"],"title":"互聯網公司大廠 – 面試八股文彙整","uri":"/cs_interview_eight_part_questions/"},{"categories":["Moment"],"content":"数据库三大范式是什么 第一范式：每个列都不可以再拆分。 第二范式：在第一范式的基础上，非主键列完全依赖于主键，而不能是依赖于主键的一部分。 第三范式：在第二范式的基础上，非主键列只依赖于主键，不依赖于其他非主键。 在设计数据库结构的时候，要尽量遵守三范式，如果不遵守，必须有足够的理由。比如性能。事实上我们经常会为了性能而妥协数据库的设计。 ","date":"2021-05-03","objectID":"/cs_interview_eight_part_questions/:6:5","tags":["互聯網","大廠","面試題","計算機網路","操作系統","Database","數據結構","演算法","MySQL","C","C++","LeetCode","CS","計算機科學","軟件工程"],"title":"互聯網公司大廠 – 面試八股文彙整","uri":"/cs_interview_eight_part_questions/"},{"categories":["Moment"],"content":"什么是索引？ 索引是一种特殊的文件(InnoDB数据表上的索引是表空间的一个组成部分)，它们包含着对数据表里所有记录的引用指针。 索引是一种数据结构。数据库索引，是数据库管理系统中一个排序的数据结构，以协助快速查询、更新数据库表中数据。索引的实现通常使用B树及其变种B+树。 更通俗的说，索引就相当于目录。为了方便查找书中的内容，通过对内容建立索引形成目录。索引是一个文件，它是要占据物理空间的。 ","date":"2021-05-03","objectID":"/cs_interview_eight_part_questions/:6:6","tags":["互聯網","大廠","面試題","計算機網路","操作系統","Database","數據結構","演算法","MySQL","C","C++","LeetCode","CS","計算機科學","軟件工程"],"title":"互聯網公司大廠 – 面試八股文彙整","uri":"/cs_interview_eight_part_questions/"},{"categories":["Moment"],"content":"索引有哪些优缺点？ 索引的优点 可以大大加快数据的检索速度，这也是创建索引的最主要的原因。 通过使用索引，可以在查询的过程中，使用优化隐藏器，提高系统的性能。 索引的缺点 时间方面：创建索引和维护索引要耗费时间，具体地，当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，会降低增/改/删的执行效率； 空间方面：索引需要占物理空间。 ","date":"2021-05-03","objectID":"/cs_interview_eight_part_questions/:6:7","tags":["互聯網","大廠","面試題","計算機網路","操作系統","Database","數據結構","演算法","MySQL","C","C++","LeetCode","CS","計算機科學","軟件工程"],"title":"互聯網公司大廠 – 面試八股文彙整","uri":"/cs_interview_eight_part_questions/"},{"categories":["Moment"],"content":"索引使用场景（重点） where select * from innodbl where id \u003c 20 根据id查询记录，因为 id 字段仅建立了主键索引，因此此SQL执行可选的索引只有主键索引，如果有多个，最终会选一个较优的作为检索的依据。 -- 增加一个没有建立索引的字段 altertableinnodb1addsexchar(1);-- 按sex检索时可选的索引为null EXPLAINSELECT*frominnodb1wheresex='男'; 可以尝试在一个字段未建立索引时，根据该字段查询的效率，然后对该字段建立索引（alter table 表名 add index(字段名)），同样的SQL执行的效率，你会发现查询效率会有明显的提升（数据量越大越明显）。 order by 当我们使用 order by 将查询结果按照某个字段排序时，如果该字段没有建立索引，那么执行计划会将查询出的所有数据使用外部排序（将数据从硬盘分批读取到内存使用内部排序，最后合并排序结果），这个操作是很影响性能的，因为需要将查询涉及到的所有数据从磁盘中读到内存（如果单条数据过大或者数据量过多都会降低效率），更无论读到内存之后的排序了。 但是如果我们对该字段建立索引 alter table 表名 add index(字段名)，那么由于索引本身是有序的，因此直接按照索引的顺序和映射关系逐条取出数据即可。而且如果分页的，那么只用取出索引表某个范围内的索引对应的数据，而不用像上述那取出所有数据进行排序再返回某个范围内的数据。（从磁盘取数据是最影响性能的） join 对 join 语句匹配关系（on）涉及的字段建立索引能够提高效率 索引覆盖 如果要查询的字段都建立过索引，那么引擎会直接在索引表中查询而不会访问原始数据（否则只要有一个字段没有建立索引就会做全表扫描），这叫索引覆盖。因此我们需要尽可能的在 select 后只写必要的查询字段，以增加索引覆盖的几率。 这里值得注意的是不要想着为每个字段建立索引，因为优先使用索引的优势就在于其体积小。 ","date":"2021-05-03","objectID":"/cs_interview_eight_part_questions/:6:8","tags":["互聯網","大廠","面試題","計算機網路","操作系統","Database","數據結構","演算法","MySQL","C","C++","LeetCode","CS","計算機科學","軟件工程"],"title":"互聯網公司大廠 – 面試八股文彙整","uri":"/cs_interview_eight_part_questions/"},{"categories":["Moment"],"content":"索引有哪几种类型？ 主键索引: 数据列不允许重复，不允许为NULL，一个表只能有一个主键。 唯一索引: 数据列不允许重复，允许为NULL值，一个表允许多个列创建唯一索引。 可以通过 ALTER TABLE table_name ADD UNIQUE (column); 创建唯一索引 可以通过 ALTER TABLE table_name ADD UNIQUE (column1,column2); 创建唯一组合索引 普通索引: 基本的索引类型，没有唯一性的限制，允许为NULL值。 可以通过 ALTER TABLE table_name ADD INDEX index_name (column); 创建普通索引 可以通过 ALTER TABLE table_name ADD INDEX index_name(column1, column2, column3); 创建组合索引 全文索引： 是目前搜索引擎使用的一种关键技术。 可以通过 ALTER TABLE table_name ADD FULLTEXT (column); 创建全文索引 ","date":"2021-05-03","objectID":"/cs_interview_eight_part_questions/:6:9","tags":["互聯網","大廠","面試題","計算機網路","操作系統","Database","數據結構","演算法","MySQL","C","C++","LeetCode","CS","計算機科學","軟件工程"],"title":"互聯網公司大廠 – 面試八股文彙整","uri":"/cs_interview_eight_part_questions/"},{"categories":["Moment"],"content":"索引的基本原理 索引用来快速地寻找那些具有特定值的记录。如果没有索引，一般来说执行查询时遍历整张表。 索引的原理很简单，就是把无序的数据变成有序的查询 把创建了索引的列的内容进行排序 对排序结果生成倒排表 在倒排表内容上拼上数据地址链 在查询的时候，先拿到倒排表内容，再取出数据地址链，从而拿到具体数据 ","date":"2021-05-03","objectID":"/cs_interview_eight_part_questions/:6:10","tags":["互聯網","大廠","面試題","計算機網路","操作系統","Database","數據結構","演算法","MySQL","C","C++","LeetCode","CS","計算機科學","軟件工程"],"title":"互聯網公司大廠 – 面試八股文彙整","uri":"/cs_interview_eight_part_questions/"},{"categories":["Moment"],"content":"索引算法有哪些？ 索引算法有 BTree 算法和 Hash 算法 BTree算法 BTree是最常用的mysql数据库索引算法，也是mysql默认的算法。因为它不仅可以被用在=,\u003e,\u003e=,\u003c,\u003c=和between这些比较操作符上，而且还可以用于like操作符，只要它的查询条件是一个不以通配符开头的常量， 例如： -- 只要它的查询条件是一个不以通配符开头的常量 select*fromuserwherenamelike'jack%';-- 如果一通配符开头，或者没有使用常量，则不会使用索引，例如： select*fromuserwherenamelike'%jack'; Hash算法 Hash Hash 索引只能用于对等比较，例如=,\u003c=\u003e（相当于=）操作符。由于是一次定位数据，不像BTree索引需要从根节点到枝节点，最后才能访问到页节点这样多次IO访问，所以检索效率远高于BTree索引。 ","date":"2021-05-03","objectID":"/cs_interview_eight_part_questions/:6:11","tags":["互聯網","大廠","面試題","計算機網路","操作系統","Database","數據結構","演算法","MySQL","C","C++","LeetCode","CS","計算機科學","軟件工程"],"title":"互聯網公司大廠 – 面試八股文彙整","uri":"/cs_interview_eight_part_questions/"},{"categories":["Moment"],"content":"索引设计的原则？ 适合索引的列是出现在where子句中的列，或者连接子句中指定的列 基数较小的类，索引效果较差，没有必要在此列建立索引 使用短索引，如果对长字符串列进行索引，应该指定一个前缀长度，这样能够节省大量索引空间 不要过度索引。索引需要额外的磁盘空间，并降低写操作的性能。在修改表内容的时候，索引会进行更新甚至重构，索引列越多，这个时间就会越长。所以只保持需要的索引有利于查询即可。 ","date":"2021-05-03","objectID":"/cs_interview_eight_part_questions/:6:12","tags":["互聯網","大廠","面試題","計算機網路","操作系統","Database","數據結構","演算法","MySQL","C","C++","LeetCode","CS","計算機科學","軟件工程"],"title":"互聯網公司大廠 – 面試八股文彙整","uri":"/cs_interview_eight_part_questions/"},{"categories":["Moment"],"content":"创建索引的原则（重中之重） 索引虽好，但也不是无限制的使用，最好符合一下几个原则 1） 最左前缀匹配原则，组合索引非常重要的原则，mysql会一直向右匹配直到遇到范围查询(\u003e、\u003c、between、like)就停止匹配，比如a = 1 and b = 2 and c \u003e 3 and d = 4 如果建立(a,b,c,d)顺序的索引，d是用不到索引的，如果建立(a,b,d,c)的索引则都可以用到，a,b,d的顺序可以任意调整。 2）较频繁作为查询条件的字段才去创建索引 3）更新频繁字段不适合创建索引 4）若是不能有效区分数据的列不适合做索引列(如性别，男女未知，最多也就三种，区分度实在太低) 5）尽量的扩展索引，不要新建索引。比如表中已经有a的索引，现在要加(a,b)的索引，那么只需要修改原来的索引即 6）定义有外键的数据列一定要建立索引。 7）对于那些查询中很少涉及的列，重复值比较多的列不要建立索引。 8）对于定义为text、image和bit的数据类型的列不要建立索引。 ","date":"2021-05-03","objectID":"/cs_interview_eight_part_questions/:6:13","tags":["互聯網","大廠","面試題","計算機網路","操作系統","Database","數據結構","演算法","MySQL","C","C++","LeetCode","CS","計算機科學","軟件工程"],"title":"互聯網公司大廠 – 面試八股文彙整","uri":"/cs_interview_eight_part_questions/"},{"categories":["Moment"],"content":"什么是数据库事务？ 事务是一个不可分割的数据库操作序列，也是数据库并发控制的基本单位，其执行的结果必须使数据库从一种一致性状态变到另一种一致性状态。事务是逻辑上的一组操作，要么都执行，要么都不执行。 事务最经典也经常被拿出来说例子就是转账了。 假如小明要给小红转账1000元，这个转账会涉及到两个关键操作就是：将小明的余额减少1000元，将小红的余额增加1000元。万一在这两个操作之间突然出现错误比如银行系统崩溃，导致小明余额减少而小红的余额没有增加，这样就不对了。事务就是保证这两个关键操作要么都成功，要么都要失败。 ","date":"2021-05-03","objectID":"/cs_interview_eight_part_questions/:6:14","tags":["互聯網","大廠","面試題","計算機網路","操作系統","Database","數據結構","演算法","MySQL","C","C++","LeetCode","CS","計算機科學","軟件工程"],"title":"互聯網公司大廠 – 面試八股文彙整","uri":"/cs_interview_eight_part_questions/"},{"categories":["Moment"],"content":"事物的四大特性(ACID)介绍一下? 关系性数据库需要遵循ACID规则，具体内容如下： 原子性： 事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用； 一致性： 执行事务前后，数据保持一致，多个事务对同一个数据读取的结果是相同的； 隔离性： 并发访问数据库时，一个用户的事务不被其他事务所干扰，各并发事务之间数据库是独立的； 持久性： 一个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响。 ","date":"2021-05-03","objectID":"/cs_interview_eight_part_questions/:6:15","tags":["互聯網","大廠","面試題","計算機網路","操作系統","Database","數據結構","演算法","MySQL","C","C++","LeetCode","CS","計算機科學","軟件工程"],"title":"互聯網公司大廠 – 面試八股文彙整","uri":"/cs_interview_eight_part_questions/"},{"categories":["Moment"],"content":"什么是脏读？幻读？不可重复读？ 脏读(Drity Read)：某个事务已更新一份数据，另一个事务在此时读取了同一份数据，由于某些原因，前一个RollBack了操作，则后一个事务所读取的数据就会是不正确的。 不可重复读(Non-repeatable read):在一个事务的两次查询之中数据不一致，这可能是两次查询过程中间插入了一个事务更新的原有的数据。 幻读(Phantom Read):在一个事务的两次查询中数据笔数不一致，例如有一个事务查询了几列(Row)数据，而另一个事务却在此时插入了新的几列数据，先前的事务在接下来的查询中，就会发现有几列数据是它先前所没有的。 ","date":"2021-05-03","objectID":"/cs_interview_eight_part_questions/:6:16","tags":["互聯網","大廠","面試題","計算機網路","操作系統","Database","數據結構","演算法","MySQL","C","C++","LeetCode","CS","計算機科學","軟件工程"],"title":"互聯網公司大廠 – 面試八股文彙整","uri":"/cs_interview_eight_part_questions/"},{"categories":["Moment"],"content":"什么是事务的隔离级别？MySQL的默认隔离级别是什么？ 为了达到事务的四大特性，数据库定义了4种不同的事务隔离级别，由低到高依次为Read uncommitted、Read committed、Repeatable read、Serializable，这四个级别可以逐个解决脏读、不可重复读、幻读这几类问题。 隔离级别 脏读 不可重复读 幻读 READ-UNCOMMITTED O O O READ-COMMITTED X O O REPEATABLE-READ X X O SERIALIZABLE X X X SQL 标准定义了四个隔离级别： READ-UNCOMMITTED(读取未提交)： 最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读。 READ-COMMITTED(读取已提交)： 允许读取并发事务已经提交的数据，可以阻止脏读，但是幻读或不可重复读仍有可能发生。 REPEATABLE-READ(可重复读)： 对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生。 SERIALIZABLE(可串行化)： 最高的隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。 这里需要注意的是：Mysql 默认采用的 REPEATABLE_READ隔离级别 Oracle 默认采用的 READ_COMMITTED隔离级别 事务隔离机制的实现基于锁机制和并发调度。其中并发调度使用的是MVVC（多版本并发控制），通过保存修改的旧版本信息来支持并发一致性读和回滚等特性。 因为隔离级别越低，事务请求的锁越少，所以大部分数据库系统的隔离级别都是READ-COMMITTED(读取提交内容)，但是你要知道的是InnoDB 存储引擎默认使用 **REPEATABLE-READ（可重读）**并不会有任何性能损失。 InnoDB 存储引擎在分布式事务的情况下一般会用到**SERIALIZABLE(可串行化)**隔离级别。 ","date":"2021-05-03","objectID":"/cs_interview_eight_part_questions/:6:17","tags":["互聯網","大廠","面試題","計算機網路","操作系統","Database","數據結構","演算法","MySQL","C","C++","LeetCode","CS","計算機科學","軟件工程"],"title":"互聯網公司大廠 – 面試八股文彙整","uri":"/cs_interview_eight_part_questions/"},{"categories":["Moment"],"content":"按照锁的粒度分数据库锁有哪些？锁机制与InnoDB锁算法 在关系型数据库中，可以按照锁的粒度把数据库锁分为行级锁(INNODB引擎)、表级锁(MYISAM引擎)和页级锁(BDB引擎)。 MyISAM 和 InnoDB 存储引擎使用的锁： MyISAM采用表级锁(table-level locking)。 InnoDB支持行级锁(row-level locking)和表级锁，默认为行级锁 行级锁，表级锁和页级锁对比 行级锁 行级锁是Mysql中锁定粒度最细的一种锁，表示只针对当前操作的行进行加锁。行级锁能大大减少数据库操作的冲突。其加锁粒度最小，但加锁的开销也最大。行级锁分为共享锁 和 排他锁。 特点：开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高。 表级锁 表级锁是MySQL中锁定粒度最大的一种锁，表示对当前操作的整张表加锁，它实现简单，资源消耗较少，被大部分MySQL引擎支持。最常使用的MYISAM与INNODB都支持表级锁定。表级锁定分为表共享读锁（共享锁）与表独占写锁（排他锁）。 特点：开销小，加锁快；不会出现死锁；锁定粒度大，发出锁冲突的概率最高，并发度最低。 页级锁 页级锁是MySQL中锁定粒度介于行级锁和表级锁中间的一种锁。表级锁速度快，但冲突多，行级冲突少，但速度慢。所以取了折衷的页级，一次锁定相邻的一组记录。 特点：开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般 ","date":"2021-05-03","objectID":"/cs_interview_eight_part_questions/:6:18","tags":["互聯網","大廠","面試題","計算機網路","操作系統","Database","數據結構","演算法","MySQL","C","C++","LeetCode","CS","計算機科學","軟件工程"],"title":"互聯網公司大廠 – 面試八股文彙整","uri":"/cs_interview_eight_part_questions/"},{"categories":["Moment"],"content":"从锁的类别上分MySQL都有哪些锁呢？ 像上面那样子进行锁定岂不是有点阻碍并发效率了 从锁的类别上来讲，有共享锁和排他锁。 共享锁: 又叫做读锁。 当用户要进行数据的读取时，对数据加上共享锁。共享锁可以同时加上多个。 排他锁: 又叫做写锁。 当用户要进行数据的写入时，对数据加上排他锁。排他锁只可以加一个，他和其他的排他锁，共享锁都相斥。 用上面的例子来说就是用户的行为有两种，一种是来看房，多个用户一起看房是可以接受的。 一种是真正的入住一晚，在这期间，无论是想入住的还是想看房的都不可以。 锁的粒度取决于具体的存储引擎，InnoDB实现了行级锁，页级锁，表级锁。 他们的加锁开销从大到小，并发能力也是从大到小。 ","date":"2021-05-03","objectID":"/cs_interview_eight_part_questions/:6:19","tags":["互聯網","大廠","面試題","計算機網路","操作系統","Database","數據結構","演算法","MySQL","C","C++","LeetCode","CS","計算機科學","軟件工程"],"title":"互聯網公司大廠 – 面試八股文彙整","uri":"/cs_interview_eight_part_questions/"},{"categories":["Moment"],"content":"数据库的乐观锁和悲观锁是什么？怎么实现的？ 数据库管理系统（DBMS）中的并发控制的任务是确保在多个事务同时存取数据库中同一数据时不破坏事务的隔离性和统一性以及数据库的统一性。乐观并发控制（乐观锁）和悲观并发控制（悲观锁）是并发控制主要采用的技术手段。 悲观锁：假定会发生并发冲突，屏蔽一切可能违反数据完整性的操作。在查询完数据的时候就把事务锁起来，直到提交事务。实现方式：使用数据库中的锁机制 乐观锁：假设不会发生并发冲突，只在提交操作时检查是否违反数据完整性。在修改数据的时候把事务锁起来，通过version的方式来进行锁定。实现方式：乐一般会使用版本号机制或CAS算法实现。 两种锁的使用场景 从上面对两种锁的介绍，我们知道两种锁各有优缺点，不可认为一种好于另一种，像乐观锁适用于写比较少的情况下（多读场景），即冲突真的很少发生的时候，这样可以省去了锁的开销，加大了系统的整个吞吐量。 但如果是多写的情况，一般会经常产生冲突，这就会导致上层应用会不断的进行retry，这样反倒是降低了性能，所以一般多写的场景下用悲观锁就比较合适。 ","date":"2021-05-03","objectID":"/cs_interview_eight_part_questions/:6:20","tags":["互聯網","大廠","面試題","計算機網路","操作系統","Database","數據結構","演算法","MySQL","C","C++","LeetCode","CS","計算機科學","軟件工程"],"title":"互聯網公司大廠 – 面試八股文彙整","uri":"/cs_interview_eight_part_questions/"},{"categories":["Moment"],"content":"主键使用自增ID还是UUID？ 推荐使用自增ID，不要使用UUID。 因为在InnoDB存储引擎中，主键索引是作为聚簇索引存在的，也就是说，主键索引的B+树叶子节点上存储了主键索引以及全部的数据(按照顺序)，如果主键索引是自增ID，那么只需要不断向后排列即可，如果是UUID，由于到来的ID与原来的大小不确定，会造成非常多的数据插入，数据移动，然后导致产生很多的内存碎片，进而造成插入性能的下降。 总之，在数据量大一些的情况下，用自增主键性能会好一些。 关于主键是聚簇索引，如果没有主键，InnoDB会选择一个唯一键来作为聚簇索引，如果没有唯一键，会生成一个隐式的主键。 ","date":"2021-05-03","objectID":"/cs_interview_eight_part_questions/:6:21","tags":["互聯網","大廠","面試題","計算機網路","操作系統","Database","數據結構","演算法","MySQL","C","C++","LeetCode","CS","計算機科學","軟件工程"],"title":"互聯網公司大廠 – 面試八股文彙整","uri":"/cs_interview_eight_part_questions/"},{"categories":["Moment"],"content":"操作系統 ","date":"2021-05-03","objectID":"/cs_interview_eight_part_questions/:7:0","tags":["互聯網","大廠","面試題","計算機網路","操作系統","Database","數據結構","演算法","MySQL","C","C++","LeetCode","CS","計算機科學","軟件工程"],"title":"互聯網公司大廠 – 面試八股文彙整","uri":"/cs_interview_eight_part_questions/"},{"categories":["Moment"],"content":"进程和线程的区别 线程具有许多传统进程所具有的特征，故又称为轻型进程(Light—Weight Process)或进程元；而把传统的进程称为重型进程(Heavy—Weight Process)，它相当于只有一个线程的任务。在引入了线程的操作系统中，通常一个进程都有若干个线程，至少包含一个线程。 根本区别：进程是操作系统资源分配的基本单位，而线程是处理器任务调度和执行的基本单位 **资源开销：**每个进程都有独立的代码和数据空间（程序上下文），程序之间的切换会有较大的开销；线程可以看做轻量级的进程，同一类线程共享代码和数据空间，每个线程都有自己独立的运行栈和程序计数器（PC），线程之间切换的开销小。 **包含关系：**如果一个进程内有多个线程，则执行过程不是一条线的，而是多条线（线程）共同完成的；线程是进程的一部分，所以线程也被称为轻权进程或者轻量级进程。 内存分配：同一进程的线程共享本进程的地址空间和资源，而进程之间的地址空间和资源是相互独立的 **影响关系：**一个进程崩溃后，在保护模式下不会对其他进程产生影响，但是一个线程崩溃整个进程都死掉。所以多进程要比多线程健壮。 **执行过程：**每个独立的进程有程序运行的入口、顺序执行序列和程序出口。但是线程不能独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制，两者均可并发执行 ","date":"2021-05-03","objectID":"/cs_interview_eight_part_questions/:7:1","tags":["互聯網","大廠","面試題","計算機網路","操作系統","Database","數據結構","演算法","MySQL","C","C++","LeetCode","CS","計算機科學","軟件工程"],"title":"互聯網公司大廠 – 面試八股文彙整","uri":"/cs_interview_eight_part_questions/"},{"categories":["Moment"],"content":"进程间通讯方式 进程间通信的概念 每个进程各自有不同的用户地址空间，任何一个进程的全局变量在另一个进程中都看不到，所以进程之间要交换数据必须通过内核，在内核中开辟一块缓冲区，进程1把数据从用户空间拷到内核缓冲区，进程2再从内核缓冲区把数据读走，内核提供的这种机制称为进程间通信（IPC，InterProcess Communication） 每个进程各自有不同的用户地址空间，任何一个进程的全局变量在另一个进程中都看不到，所以进程之间要交换数据必须通过内核，在内核中开辟一块缓冲区，进程1把数据从用户空间拷到内核缓冲区，进程2再从内核缓冲区把数据读走，内核提供的这种机制称为进程间通信（IPC，InterProcess Communication） 內容太多，請直接看這個網站 https://www.jianshu.com/p/c1015f5ffa74 簡要回答 1，管道分为命名管道和无名管道，在内核中申请一块固定大小的缓冲区，程序拥有写入和读取的权利，都可以看成一种特殊的文件，具有固定的读端和写端，也可以使用普通的read、write 等函数。但是它不是普通的文件，并不属于其他任何文件系统，并且只存在于内存中；无名管道一般使用fork函数实现父子进程的通信，命名管道用于没有血缘关系的进程也可以进程间通信；面向字节流、自带同步互斥机制、半双工，单向通信，两个管道实现双向通信。 2，消息队列，在内核中创建一队列，队列中每个元素是一个数据报，不同的进程可以通过句柄去访问这个队列；消息队列独立于发送与接收进程，可以通过顺序和消息类型读取，也可以fifo读取；消息队列可实现双向通信 。 3，信号量 ， 在内核中创建一个信号量集合（本质是个数组），数组的元素（信号量）都是1，使用P操作进行-1，使用V操作+1，通过对临界资源进行保护实现多进程的同步 4，共享内存，将同一块物理内存一块映射到不同的进程的虚拟地址空间中，实现不同进程间对同一资源的共享。目前最快的IPC形式，不用从用户态到内核态的频繁切换和拷贝数据，直接从内存中读取就可以，共享内存是临界资源，所以需要操作时必须要保证原子性。使用信号量或者互斥锁都可以。 5，socket是应用层与TCP/IP协议族通信的中间软件抽象层，它是一组接口，把复杂的TCP/IP协议族隐藏在Socket接口后面，对用户来说，一组简单的接口就是全部，让Socket去组织数据。socket起源于UNIX，在Unix一切皆文件哲学的思想下，socket是一种”打开—读/写—关闭”模式的实现，服务器和客户端各自维护一个”文件”，在建立连接打开后，可以向自己文件写入内容供对方读取或者读取对方内容，通讯结束时关闭文件。是一种可以网间通信的方式。 ","date":"2021-05-03","objectID":"/cs_interview_eight_part_questions/:7:2","tags":["互聯網","大廠","面試題","計算機網路","操作系統","Database","數據結構","演算法","MySQL","C","C++","LeetCode","CS","計算機科學","軟件工程"],"title":"互聯網公司大廠 – 面試八股文彙整","uri":"/cs_interview_eight_part_questions/"},{"categories":["Moment"],"content":"进程切换的上下文细节 https://zhuanlan.zhihu.com/p/52845869 什么是 CPU 上下文 CPU 寄存器和程序计数器就是 CPU 上下文，因为它们都是 CPU 在运行任何任务前，必须的依赖环境。 CPU 寄存器是 CPU 内置的容量小、但速度极快的内存。程序计数器则是用来存储 CPU 正在执行的指令位置、或者即将执行的下一条指令位置。 什么是 CPU 上下文切换 就是先把前一个任务的 CPU 上下文（也就是 CPU 寄存器和程序计数器）保存起来，然后加载新任务的上下文到这些寄存器和程序计数器，最后再跳转到程序计数器所指的新位置，运行新任务。 而这些保存下来的上下文，会存储在系统内核中，并在任务重新调度执行时再次加载进来。这样就能保证任务原来的状态不受影响，让任务看起来还是连续运行。 CPU 上下文切换的类型 根据任务的不同，可以分为以下三种类型 - 进程上下文切换 - 线程上下文切换 - 中断上下文切换 进程上下文切换 Linux 按照特权等级，把进程的运行空间分为内核空间和用户空间，分别对应着下图中， CPU 特权等级的 Ring 0 和 Ring 3。 内核空间（Ring 0）具有最高权限，可以直接访问所有资源；用户空间（Ring 3）只能访问受限资源，不能直接访问内存等硬件设备，必须通过系统调用陷入到内核中，才能访问这些特权资源。 进程既可以在用户空间运行，又可以在内核空间中运行。进程在用户空间运行时，被称为进程的用户态，而陷入内核空间的时候，被称为进程的内核态。 系统调用 从用户态到内核态的转变，需要通过系统调用来完成。比如，当我们查看文件内容时，就需要多次系统调用来完成：首先调用 open() 打开文件，然后调用 read() 读取文件内容，并调用 write() 将内容写到标准输出，最后再调用 close() 关闭文件。 在这个过程中就发生了 CPU 上下文切换，整个过程是这样的： 1、保存 CPU 寄存器里原来用户态的指令位 2、为了执行内核态代码，CPU 寄存器需要更新为内核态指令的新位置。 3、跳转到内核态运行内核任务。 4、当系统调用结束后，CPU 寄存器需要恢复原来保存的用户态，然后再切换到用户空间，继续运行进程。 所以，一次系统调用的过程，其实是发生了两次 CPU 上下文切换。（用户态-内核态-用户态） 不过，需要注意的是，系统调用过程中，并不会涉及到虚拟内存等进程用户态的资源，也不会切换进程。这跟我们通常所说的进程上下文切换是不一样的：进程上下文切换，是指从一个进程切换到另一个进程运行；而系统调用过程中一直是同一个进程在运行。 所以，系统调用过程通常称为特权模式切换，而不是上下文切换。系统调用属于同进程内的 CPU 上下文切换。但实际上，系统调用过程中，CPU 的上下文切换还是无法避免的。 进程上下文切换跟系统调用又有什么区别呢 首先，进程是由内核来管理和调度的，进程的切换只能发生在内核态。所以，进程的上下文不仅包括了虚拟内存、栈、全局变量等用户空间的资源，还包括了内核堆栈、寄存器等内核空间的状态。 因此，进程的上下文切换就比系统调用时多了一步：在保存内核态资源（当前进程的内核状态和 CPU 寄存器）之前，需要先把该进程的用户态资源（虚拟内存、栈等）保存下来；而加载了下一进程的内核态后，还需要刷新进程的虚拟内存和用户栈。 如下图所示，保存上下文和恢复上下文的过程并不是“免费”的，需要内核在 CPU 上运行才能完成。 进程上下文切换潜在的性能问题 根据 Tsuna 的测试报告，每次上下文切换都需要几十纳秒到数微秒的 CPU 时间。这个时间还是相当可观的，特别是在进程上下文切换次数较多的情况下，很容易导致 CPU 将大量时间耗费在寄存器、内核栈以及虚拟内存等资源的保存和恢复上，进而大大缩短了真正运行进程的时间。这也正是导致平均负载升高的一个重要因素。 另外，我们知道， Linux 通过 TLB（Translation Lookaside Buffer）来管理虚拟内存到物理内存的映射关系。当虚拟内存更新后，TLB 也需要刷新，内存的访问也会随之变慢。特别是在多处理器系统上，缓存是被多个处理器共享的，刷新缓存不仅会影响当前处理器的进程，还会影响共享缓存的其他处理器的进程。 发生进程上下文切换的场景 1.为了保证所有进程可以得到公平调度，CPU 时间被划分为一段段的时间片，这些时间片再被轮流分配给各个进程。这样，当某个进程的时间片耗尽了，就会被系统挂起，切换到其它正在等待 CPU 的进程运行。 2.进程在系统资源不足（比如内存不足）时，要等到资源满足后才可以运行，这个时候进程也会被挂起，并由系统调度其他进程运行。 3.当进程通过睡眠函数 sleep 这样的方法将自己主动挂起时，自然也会重新调度。当有优先级更高的进程运行时，为了保证高优先级进程的运行，当前进程会被挂起，由高优先级进程来运行 4.发生硬件中断时，CPU 上的进程会被中断挂起，转而执行内核中的中断服务程序。 线程上下文切换 线程与进程最大的区别在于：线程是调度的基本单位，而进程则是资源拥有的基本单位。说白了，所谓内核中的任务调度，实际上的调度对象是线程；而进程只是给线程提供了虚拟内存、全局变量等资源。 所以，对于线程和进程，我们可以这么理解： - 当进程只有一个线程时，可以认为进程就等于线程。 - 当进程拥有多个线程时，这些线程会共享相同的虚拟内存和全局变量等资源。这些资源在上下文切换时是不需要修改的。 - 另外，线程也有自己的私有数据，比如栈和寄存器等，这些在上下文切换时也是需要保存的。 发生线程上下文切换的场景 1.前后两个线程属于不同进程。此时，因为资源不共享，所以切换过程就跟进程上下文切换是一样。 2.前后两个线程属于同一个进程。此时，因为虚拟内存是共享的，所以在切换时，虚拟内存这些资源就保持不动，只需要切换线程的私有数据、寄存器等不共享的数据 中断上下文切换 为了快速响应硬件的事件，中断处理会打断进程的正常调度和执行，转而调用中断处理程序，响应设备事件。而在打断其他进程时，就需要将进程当前的状态保存下来，这样在中断结束后，进程仍然可以从原来的状态恢复运行。 跟进程上下文不同，中断上下文切换并不涉及到进程的用户态。所以，即便中断过程打断了一个正处在用户态的进程，也不需要保存和恢复这个进程的虚拟内存、全局变量等用户态资源。中断上下文，其实只包括内核态中断服务程序执行所必需的状态，包括 CPU 寄存器、内核堆栈、硬件中断参数等。 对同一个 CPU 来说，中断处理比进程拥有更高的优先级，所以中断上下文切换并不会与进程上下文切换同时发生。同样道理，由于中断会打断正常进程的调度和执行，所以大部分中断处理程序都短小精悍，以便尽可能快的执行结束。 另外，跟进程上下文切换一样，中断上下文切换也需要消耗 CPU，切换次数过多也会耗费大量的 CPU，甚至严重降低系统的整体性能。所以，当你发现中断次数过多时，就需要注意去排查它是否会给你的系统带来严重的性能问题。 ","date":"2021-05-03","objectID":"/cs_interview_eight_part_questions/:7:3","tags":["互聯網","大廠","面試題","計算機網路","操作系統","Database","數據結構","演算法","MySQL","C","C++","LeetCode","CS","計算機科學","軟件工程"],"title":"互聯網公司大廠 – 面試八股文彙整","uri":"/cs_interview_eight_part_questions/"},{"categories":["Moment"],"content":"线程切换的上下文细节 答案在上面的問題 ","date":"2021-05-03","objectID":"/cs_interview_eight_part_questions/:7:4","tags":["互聯網","大廠","面試題","計算機網路","操作系統","Database","數據結構","演算法","MySQL","C","C++","LeetCode","CS","計算機科學","軟件工程"],"title":"互聯網公司大廠 – 面試八股文彙整","uri":"/cs_interview_eight_part_questions/"},{"categories":["Moment"],"content":"什么是协程 官方定义如下： A coroutine is a function that can suspend its execution (yield) until the given given YieldInstruction finishes. 用我蹩脚的英语来翻译一下就是： 学过计算机组成原理的都知道，当 CPU 在多个进程间切换时，那些后台程序就会处于这种暂停用英文的 Suspend 或许更恰当）的状态，所以早年的电脑即使用一个 CPU 也可以同时处理多个进程任务，这是一种“伪多线程”的技术。 除此之外比较重要的一点是，协程不是被操作系统内核所管理，而完全是由程序所控制（也就是在用户态执行）。这样带来的好处就是性能得到了很大的提升，不会像线程那样需要上下文切换来消耗资源，因此协程的开销远远小于线程的开销。 注意，这里要划一个重点，协程是一种“伪多线程”，始终记得这一点，可以帮助我们来理解协程会这个概念。 ","date":"2021-05-03","objectID":"/cs_interview_eight_part_questions/:7:5","tags":["互聯網","大廠","面試題","計算機網路","操作系統","Database","數據結構","演算法","MySQL","C","C++","LeetCode","CS","計算機科學","軟件工程"],"title":"互聯網公司大廠 – 面試八股文彙整","uri":"/cs_interview_eight_part_questions/"},{"categories":["Moment"],"content":"线程同步的机制 http://kaiyuan.me/2015/08/20/thread_sync/ 当一个程序涉及到多个线程的时候，线程之间的同步和互斥就显得尤其重要。为了避免一个线程中的敏感数据被另一个线程修改，程序中往往需要显式的使用线程同步机制来保证线程运行环境的安全。当前的编程库环境（例如pthread库）就为多线程的同步和互斥提供了多种不同的机制，包括互斥锁，读写锁，自旋锁，条件变量和信号量等等。本文简要记载使用不同的同步机制时应该注意的问题。 互斥锁 互斥锁指的就是不同的锁之间相互排斥。对于某个临界区而言，任何时间都只能有一个互斥锁的锁住该临界区。当该互斥锁未释放之前，任何其他企图对该临界区进行加锁访问的线程都会被挂起而阻塞。等到该临界区上的锁释放的时候，其他进程才能被唤醒来访问该临界区。 在使用互斥锁的时候需要注意以下几个问题： 但临界区非常下的时候，一般不适合使用互斥锁。原因是互斥锁一旦加锁失败往往会将线程挂起阻塞，而线程的上下文切换也是需要开销的。如果临界区比较小并且需要频繁加锁，那么使用自旋锁更合适一些。（当然网上有资料表明pthread中的互斥锁mutex在加锁失败之后会自旋一段时间，然后再阻塞，基本代替了自旋锁的作用。但由于本文只讨论不同锁的特性，不依赖于具体的实现，因此还是加上这条）。 使用互斥锁的时候及其容易引起死锁。如果加锁顺序和释放锁的顺序不当，互斥锁是比较容易引起死锁的。解决死锁问题一方面可以通过在程序编写中小心注意而避免，另一方面可以通过非阻塞的申请锁的方式而避免。非阻塞申请锁一般在申请失败后就直接返回而不阻塞，避免了因为阻塞而引起的死锁。 任何同步的场景都可以使用互斥锁等价的实现，但是仅仅使用互斥锁有时候严重影响性能，比如下文要提到的读写锁就可以提高临界区访问的并发性。 读写锁 在上文中已经提到，尽管互斥锁会极大地简化线程并发中所涉及的到的临界区访问的控制逻辑，在某些场合，其可能会极大地影响到线程并发的效率，例如在多线程并发读写临界区，并且读多写少得场景下。 直观来看，允许多个read-only的线程并发的访问数据并不会影响程序的运行逻辑，因为他们不会对读取的数据进行任何修改，而要写数据的线程与其他的线程则需要进行绝对的并发控制。读写锁就是在这种背景下产生的。读写锁一般分为读锁和写锁，其互斥逻辑如下：1）同一个临界区可以同时加上多个读锁；2）同一个临界区有且只能有一个写锁；3）读锁和写锁不能共存与一个临界区。 在了解这些特性之后可以看到，当一个线程已经给某个临界区加上读锁之后，后续的读线程仍然能够给此临界区加上读锁进行访问。只有当临界区上的所有锁释放之后，写线程才能成功的给临界区加上写锁。这种逻辑会带来一个直观的问题，就是写线程的饥饿：一旦不同读线程持续不断的给临界区加锁，那么写线程将永远没有机会进入临界区。因此，在使用读写锁的同时需要给予写线程比较高的优先级，从而防止写线程的饥饿。 自旋锁 自旋锁可以理解成为“空转锁”。相比于互斥锁而言，自旋锁一旦加锁失败，其线程并不会被调度挂起进入阻塞状态，而是阻塞在一个空循环上。这种性质决定了自旋锁节省了线程切换的开销，却浪费了CPU时间。(阿里的笔试题就考到了这个问题) 在使用自旋锁的时候需要注意的是，加锁的临界区要尽量的小。如果临界区很长需要花费很多时间，那么大部分的阻塞在自旋上的线程会大量的消耗掉CPU的时间，那么使用自旋锁显然就是不合适的。此外Linux内核在进行临界区处理的时候大量的使用了自旋锁。尽管在真实的编程环境下自旋锁使用的不多，但其仍然是线程同步机制中一种重要的方式。 条件变量 在多线程的环境下我们往往有如下的需求：当A线程完成某件事情之前B线程需要阻塞，当A线程完成该事件之后通知B线程之后，B线程才能被唤醒继续执行。显然这种场景可以使用互斥锁或者信号量来实现，但是一种逻辑上更自然的做法就是使用条件变量。 条件变量一般都有wait()和signal()两个函数，其中wait()函数在未接受到任何信号的嘶吼将会阻塞当前线程，而signal()函数负责唤醒等待在当前条件变量上的线程。注意signal函数具体唤醒多少线程并没有一个特定的限制，其依赖于具体的实现而定。 不同于互斥锁，自旋锁和信号量，等待在某个条件变量上的线程将完全依赖于signal()函数发出的信号而唤醒。一旦发出的信号丢失，该阻塞进程将再也没有机会被唤醒了。因此条件变量一般都需要配合互斥锁或者信号量使用，一般情况下等待线程的逻辑如下： mutex_lock.lock(); ... if(conditions are not satisfied) cond_var.wait(\u0026mutex_lock); //wait之后，mutex_lock会被自动释放 ... mutex_lock.unlock(); 而发送信号的线程如下: mutex_lock.lock(); ... cond_var.signal(\u0026mutex_lock); ... mutex_lock.unlock(); 再次提醒一下，条件变量一定要配合互斥锁使用。不管是wait函数还是signal函数，都最好在加锁之后的区域调用，否则很可能会产生意想不到的问题。 信号量 信号量是Dijkstra在1965年提出的一种同步的方案。这种方案使用一种特殊的被称作信号量的整形结构来记录某一临界区操作的次数。信号量的实现中一般具有两种操作，分别是P操作和V操作。对一个信号量进行P操作时，首先检查其值是否大于0，如果大于0，则将其值减一之后返回进行后续操作，如果值小于等于0，则该进程将进行阻塞。P操作可以由以下逻辑表示: function P(semaphore \u0026s) { s.value--; if(s.value \u003c 0){ wait(s.list) } } 执行V操作时，首先将信号量的值加一，然后检查信号量的值是否大于0，如果大于0，则直接返回执行其他的操作，否则唤醒一个等待在该信号量上的进程。 function V(semaphore \u0026s) { s.value++; if(s.value \u003c= 0){ wake(s.list); } } 在上述操作中，P和V操作都是原子的。这意味着P函数或者V函数中的语句要么都不执行，要么都执行。在单核操作系统中，这种原子性可以通过关中断而保证，而在多核系统中，可以通过锁总线操作而保证。另外需要注意的是，虽然信号量可以针对进程使用，但是在具体应用中，由于线程之间共享数据更加方便，使用信号量进行线程同步的场景更多。 事实上，信号量可以同时用来进行互斥和同步的操作，通过信号量赋予不同的初始值，可以使用信号量模拟互斥锁的行为。 ","date":"2021-05-03","objectID":"/cs_interview_eight_part_questions/:7:6","tags":["互聯網","大廠","面試題","計算機網路","操作系統","Database","數據結構","演算法","MySQL","C","C++","LeetCode","CS","計算機科學","軟件工程"],"title":"互聯網公司大廠 – 面試八股文彙整","uri":"/cs_interview_eight_part_questions/"},{"categories":["Moment"],"content":"select，poll，epoll 的区别 https://www.cnblogs.com/anker/p/3265058.html select，poll，epoll都是IO多路复用的机制。I/O多路复用就通过一种机制，可以监视多个描述符，一旦某个描述符就绪（一般是读就绪或者写就绪），能够通知程序进行相应的读写操作。但select，poll，epoll本质上都是同步I/O，因为他们都需要在读写事件就绪后自己负责进行读写，也就是说这个读写过程是阻塞的，而异步I/O则无需自己负责进行读写，异步I/O的实现会负责把数据从内核拷贝到用户空间。关于这三种IO多路复用的用法，前面三篇总结写的很清楚，并用服务器回射echo程序进行了测试。连接如下所示： select：http://www.cnblogs.com/Anker/archive/2013/08/14/3258674.html poll：http://www.cnblogs.com/Anker/archive/2013/08/15/3261006.html epoll：http://www.cnblogs.com/Anker/archive/2013/08/17/3263780.html 今天对这三种IO多路复用进行对比，参考网上和书上面的资料，整理如下： 1、select实现 select的调用过程如下所示： （1）使用copy_from_user从用户空间拷贝fd_set到内核空间 （2）注册回调函数__pollwait （3）遍历所有fd，调用其对应的poll方法（对于socket，这个poll方法是sock_poll，sock_poll根据情况会调用到tcp_poll,udp_poll或者datagram_poll） （4）以tcp_poll为例，其核心实现就是__pollwait，也就是上面注册的回调函数。 （5）__pollwait的主要工作就是把current（当前进程）挂到设备的等待队列中，不同的设备有不同的等待队列，对于tcp_poll来说，其等待队列是sk-\u003esk_sleep（注意把进程挂到等待队列中并不代表进程已经睡眠了）。在设备收到一条消息（网络设备）或填写完文件数据（磁盘设备）后，会唤醒设备等待队列上睡眠的进程，这时current便被唤醒了。 （6）poll方法返回时会返回一个描述读写操作是否就绪的mask掩码，根据这个mask掩码给fd_set赋值。 （7）如果遍历完所有的fd，还没有返回一个可读写的mask掩码，则会调用schedule_timeout是调用select的进程（也就是current）进入睡眠。当设备驱动发生自身资源可读写后，会唤醒其等待队列上睡眠的进程。如果超过一定的超时时间（schedule_timeout指定），还是没人唤醒，则调用select的进程会重新被唤醒获得CPU，进而重新遍历fd，判断有没有就绪的fd。 （8）把fd_set从内核空间拷贝到用户空间。 总结： select的几大缺点： （1）每次调用select，都需要把fd集合从用户态拷贝到内核态，这个开销在fd很多时会很大 （2）同时每次调用select都需要在内核遍历传递进来的所有fd，这个开销在fd很多时也很大 （3）select支持的文件描述符数量太小了，默认是1024 2、poll实现 poll的实现和select非常相似，只是描述fd集合的方式不同，poll使用pollfd结构而不是select的fd_set结构，其他的都差不多。 关于select和poll的实现分析，可以参考下面几篇博文： http://blog.csdn.net/lizhiguo0532/article/details/6568964#comments http://blog.csdn.net/lizhiguo0532/article/details/6568968 http://blog.csdn.net/lizhiguo0532/article/details/6568969 http://www.ibm.com/developerworks/cn/linux/l-cn-edntwk/index.html?ca=drs- http://linux.chinaunix.net/techdoc/net/2009/05/03/1109887.shtml 3、epoll epoll既然是对select和poll的改进，就应该能避免上述的三个缺点。那epoll都是怎么解决的呢？在此之前，我们先看一下epoll和select和poll的调用接口上的不同，select和poll都只提供了一个函数——select或者poll函数。而epoll提供了三个函数，epoll_create,epoll_ctl和epoll_wait，epoll_create是创建一个epoll句柄；epoll_ctl是注册要监听的事件类型；epoll_wait则是等待事件的产生。 对于第一个缺点，epoll的解决方案在epoll_ctl函数中。每次注册新的事件到epoll句柄中时（在epoll_ctl中指定EPOLL_CTL_ADD），会把所有的fd拷贝进内核，而不是在epoll_wait的时候重复拷贝。epoll保证了每个fd在整个过程中只会拷贝一次。 对于第二个缺点，epoll的解决方案不像select或poll一样每次都把current轮流加入fd对应的设备等待队列中，而只在epoll_ctl时把current挂一遍（这一遍必不可少）并为每个fd指定一个回调函数，当设备就绪，唤醒等待队列上的等待者时，就会调用这个回调函数，而这个回调函数会把就绪的fd加入一个就绪链表）。epoll_wait的工作实际上就是在这个就绪链表中查看有没有就绪的fd（利用schedule_timeout()实现睡一会，判断一会的效果，和select实现中的第7步是类似的）。 对于第三个缺点，epoll没有这个限制，它所支持的FD上限是最大可以打开文件的数目，这个数字一般远大于2048,举个例子,在1GB内存的机器上大约是10万左右，具体数目可以cat /proc/sys/fs/file-max察看,一般来说这个数目和系统内存关系很大。 总结： （1）select，poll实现需要自己不断轮询所有fd集合，直到设备就绪，期间可能要睡眠和唤醒多次交替。而epoll其实也需要调用epoll_wait不断轮询就绪链表，期间也可能多次睡眠和唤醒交替，但是它是设备就绪时，调用回调函数，把就绪fd放入就绪链表中，并唤醒在epoll_wait中进入睡眠的进程。虽然都要睡眠和交替，但是select和poll在“醒着”的时候要遍历整个fd集合，而epoll在“醒着”的时候只要判断一下就绪链表是否为空就行了，这节省了大量的CPU时间。这就是回调机制带来的性能提升。 （2）select，poll每次调用都要把fd集合从用户态往内核态拷贝一次，并且要把current往设备等待队列中挂一次，而epoll只要一次拷贝，而且把current往等待队列上挂也只挂一次（在epoll_wait的开始，注意这里的等待队列并不是设备等待队列，只是一个epoll内部定义的等待队列）。这也能节省不少的开销。 ","date":"2021-05-03","objectID":"/cs_interview_eight_part_questions/:7:7","tags":["互聯網","大廠","面試題","計算機網路","操作系統","Database","數據結構","演算法","MySQL","C","C++","LeetCode","CS","計算機科學","軟件工程"],"title":"互聯網公司大廠 – 面試八股文彙整","uri":"/cs_interview_eight_part_questions/"},{"categories":["Moment"],"content":"epoll水平触发和边缘触发的区别 https://blog.csdn.net/lihao21/article/details/67631516 epoll也是实现I/O多路复用的一种方法，为了深入了解epoll的原理，我们先来看下epoll水平触发（level trigger，LT，LT为epoll的默认工作模式）与边缘触发（edge trigger，ET）两种工作模式。 使用脉冲信号来解释LT和ET可能更加贴切。Level是指信号只需要处于水平，就一直会触发；而edge则是指信号为上升沿或者下降沿时触发。说得还有点玄乎，我们以生活中的一个例子来类比LT和ET是如何确定读操作是否就绪的。 水平触发 儿子：妈妈，我收到了500元的压岁钱。 妈妈：嗯，省着点花。 儿子：妈妈，我今天花了200元买了个变形金刚。 妈妈：以后不要乱花钱。 儿子：妈妈，我今天买了好多好吃的，还剩下100元。 妈妈：用完了这些钱，我可不会再给你钱了。 儿子：妈妈，那100元我没花，我攒起来了 妈妈：这才是明智的做法！ 儿子：妈妈，那100元我还没花，我还有钱的。 妈妈：嗯，继续保持。 儿子：妈妈，我还有100元钱。 妈妈：… 接下来的情形就是没完没了了：只要儿子一直有钱，他就一直会向他的妈妈汇报。LT模式下，只要内核缓冲区中还有未读数据，就会一直返回描述符的就绪状态，即不断地唤醒应用进程。在上面的例子中，儿子是缓冲区，钱是数据，妈妈则是应用进程了解儿子的压岁钱状况（读操作）。 边缘触发 儿子：妈妈，我收到了500元的压岁钱。 妈妈：嗯，省着点花。 （儿子使用压岁钱购买了变形金刚和零食。） 儿子： 妈妈：儿子你倒是说话啊？压岁钱呢？ 这个就是ET模式，儿子只在第一次收到压岁钱时通知妈妈，接下来儿子怎么把压岁钱花掉并没有通知妈妈。即儿子从没钱变成有钱，需要通知妈妈，接下来钱变少了，则不会再通知妈妈了。在ET模式下， 缓冲区从不可读变成可读，会唤醒应用进程，缓冲区数据变少的情况，则不会再唤醒应用进程。 我们再详细说明LT和ET两种模式下对读写操作是否就绪的判断。 水平触发 对于读操作 只要缓冲内容不为空，LT模式返回读就绪。 2. 对于写操作 只要缓冲区还不满，LT模式会返回写就绪。 边缘触发 对于读操作 （1）当缓冲区由不可读变为可读的时候，即缓冲区由空变为不空的时候。 （2）当有新数据到达时，即缓冲区中的待读数据变多的时候。 （3）当缓冲区有数据可读，且应用进程对相应的描述符进行EPOLL_CTL_MOD 修改EPOLLIN事件时。 2. 对于写操作 （1）当缓冲区由不可写变为可写时。 （2）当有旧数据被发送走，即缓冲区中的内容变少的时候。 （3）当缓冲区有空间可写，且应用进程对相应的描述符进行EPOLL_CTL_MOD 修改EPOLLOUT事件时。 ","date":"2021-05-03","objectID":"/cs_interview_eight_part_questions/:7:8","tags":["互聯網","大廠","面試題","計算機網路","操作系統","Database","數據結構","演算法","MySQL","C","C++","LeetCode","CS","計算機科學","軟件工程"],"title":"互聯網公司大廠 – 面試八股文彙整","uri":"/cs_interview_eight_part_questions/"},{"categories":["Moment"],"content":"epoll 什么时候可写，什么时候可读，监听数量有限制吗 難度高，google 不到答案 https://man7.org/linux/man-pages/man7/epoll.7.html https://kernel.taobao.org/2019/12/epoll-is-fundamentally-broken/ 擷取自 https://eli.thegreenplace.net/2017/concurrent-servers-part-3-event-driven/ As an example, let’s look at epoll, Linux’s solution to the high-volume I/O event notification problem. The key to epoll’s efficiency is greater cooperation from the kernel. Instead of using a file descriptor set, epoll_wait fills a buffer with events that are currently ready. Only the ready events are added to the buffer, so there is no need to iterate over all the currently watched file descriptors in the client. This changes the process of discovering which descriptors are ready from O(N) in select’s case to O(1). A full presentation of the epoll API is not the goal here - there are plenty of online resources for that. As you may have guessed, though, I am going to write yet another version of our concurrent server - this time using epoll instead of select. The full code sample is here. In fact, since the vast majority of the code is the same as select-server, I’ll only focus on the novelty - the use of epoll in the main loop: struct epoll_event accept_event; accept_event.data.fd = listener_sockfd; accept_event.events = EPOLLIN; if (epoll_ctl(epollfd, EPOLL_CTL_ADD, listener_sockfd, \u0026accept_event) \u003c 0) { perror_die(\"epoll_ctl EPOLL_CTL_ADD\"); } struct epoll_event* events = calloc(MAXFDS, sizeof(struct epoll_event)); if (events == NULL) { die(\"Unable to allocate memory for epoll_events\"); } while (1) { int nready = epoll_wait(epollfd, events, MAXFDS, -1); for (int i = 0; i \u003c nready; i++) { if (events[i].events \u0026 EPOLLERR) { perror_die(\"epoll_wait returned EPOLLERR\"); } if (events[i].data.fd == listener_sockfd) { // The listening socket is ready; this means a new peer is connecting. ... } else { // A peer socket is ready. if (events[i].events \u0026 EPOLLIN) { // Ready for reading. ... } else if (events[i].events \u0026 EPOLLOUT) { // Ready for writing. ... } } } } We start by configuring epoll with a call to epoll_ctl. In this case, the configuration amounts to adding the listening socket to the descriptors epoll is watching for us. We then allocate a buffer of ready events to pass to epoll for modification. The call to epoll_wait in the main loop is where the magic’s at. It blocks until one of the watched descriptors is ready (or until a timeout expires), and returns the number of ready descriptors. This time, however, instead of blindly iterating over all the watched sets, we know that epoll_write populated the events buffer passed to it with the ready events, from 0 to nready-1, so we iterate only the strictly necessary number of times. To reiterate this critical difference from select: if we’re watching 1000 descriptors and two become ready, epoll_waits returns nready=2 and populates the first two elements of the events buffer - so we only “iterate” over two descriptors. With select we’d still have to iterate over 1000 descriptors to find out which ones are ready. For this reason epoll scales much better than select for busy servers with many active sockets. The rest of the code is straightforward, since we’re already familiar with select-server. In fact, all the “business logic” of epoll-server is exactly the same as for select-server - the callbacks consist of the same code. This similarity is tempting to exploit by abstracting away the event loop into a library/framework. I’m going to resist this itch, because so many great programmers succumbed to it in the past. Instead, in the next post we’re going to look at libuv - one of the more popular event loop abstractions emerging recently. Libraries like libuv allow us to write concurrent asynchronous servers without worrying about the greasy details of the underlying system calls. ","date":"2021-05-03","objectID":"/cs_interview_eight_part_questions/:7:9","tags":["互聯網","大廠","面試題","計算機網路","操作系統","Database","數據結構","演算法","MySQL","C","C++","LeetCode","CS","計算機科學","軟件工程"],"title":"互聯網公司大廠 – 面試八股文彙整","uri":"/cs_interview_eight_part_questions/"},{"categories":["Moment"],"content":"如何实现内存池 https://zhuanlan.zhihu.com/p/64719710 为什么要用内存池 C++程序默认的内存管理（new，delete，malloc，free）会频繁地在堆上分配和释放内存，导致性能的损失，产生大量的内存碎片，降低内存的利用率。默认的内存管理因为被设计的比较通用，所以在性能上并不能做到极致。 因此，很多时候需要根据业务需求设计专用内存管理器，便于针对特定数据结构和使用场合的内存管理，比如：内存池。 内存池原理 内存池的思想是，在真正使用内存之前，预先申请分配一定数量、大小预设的内存块留作备用。当有新的内存需求时，就从内存池中分出一部分内存块，若内存块不够再继续申请新的内存，当内存释放后就回归到内存块留作后续的复用，使得内存使用效率得到提升，一般也不会产生不可控制的内存碎片。 内存池设计 算法原理： 1.预申请一个内存区chunk，将内存中按照对象大小划分成多个内存块block 2.维持一个空闲内存块链表，通过指针相连，标记头指针为第一个空闲块 3.每次新申请一个对象的空间，则将该内存块从空闲链表中去除，更新空闲链表头指针 4.每次释放一个对象的空间，则重新将该内存块加到空闲链表头 5.如果一个内存区占满了，则新开辟一个内存区，维持一个内存区的链表，同指针相连，头指针指向最新的内存区，新的内存块从该区内重新划分和申请 如图所示： ","date":"2021-05-03","objectID":"/cs_interview_eight_part_questions/:7:10","tags":["互聯網","大廠","面試題","計算機網路","操作系統","Database","數據結構","演算法","MySQL","C","C++","LeetCode","CS","計算機科學","軟件工程"],"title":"互聯網公司大廠 – 面試八股文彙整","uri":"/cs_interview_eight_part_questions/"},{"categories":["Moment"],"content":"cpu占用 100%，怎么排查问题 https://blog.csdn.net/pengjunlee/article/details/107150785 一、引子 对于互联网公司，线上CPU飙升的问题很常见（例如某个活动开始，流量突然飙升时），按照本文的步骤排查，基本1分钟即可搞定！特此整理排查方法一篇，供大家参考讨论提高。 二、问题复现 线上系统突然运行缓慢，CPU飙升，甚至到100%，以及Full GC次数过多，接着就是各种报警：例如接口超时报警等。此时急需快速线上排查问题。 三、问题排查 不管什么问题，既然是CPU飙升，肯定是查一下耗CPU的线程，然后看看GC。 3.1核心排查步骤 1.执行top命令：查看所有进程占系统CPU的排序。极大可能排第一个的就是咱们的java进程（COMMAND列）。PID那一列就是进程号。 2.执行top -Hp 进程号命令：查看java进程下的所有线程占CPU的情况。 3.执行printf “%x\\n 10命令 ：后续查看线程堆栈信息展示的都是十六进制，为了找到咱们的线程堆栈信息，咱们需要把线程号转成16进制。例如,printf “%x\\n 10-》打印：a，那么在jstack中线程号就是0xa. 4.执行 jstack 进程号 | grep 线程ID 查找某进程下-》线程ID（jstack堆栈信息中的nid）=0xa的线程状态。如果\"VM Thread” os_prio=0 tid=0x00007f871806e000 nid=0xa runnable，第一个双引号圈起来的就是线程名，如果是“VM Thread”这就是虚拟机GC回收线程了 5.执行jstat -gcutil 进程号 统计间隔毫秒 统计次数（缺省代表一致统计），查看某进程GC持续变化情况，如果发现返回中FGC很大且一直增大-》确认Full GC! 也可以使用jmap -heap 进程ID查看一下进程的堆内从是不是要溢出了，特别是老年代内从使用情况一般是达到阈值(具体看垃圾回收器和启动时配置的阈值)就会进程Full GC。 6.执行jmap -dump:format=b,file=filename 进程ID，导出某进程下内存heap输出到文件中。可以通过eclipse的mat工具查看内存中有哪些对象比较多。 3.2原因分析 1.内存消耗过大，导致Full GC次数过多 执行步骤1-5： 多个线程的CPU都超过了100%，通过jstack命令可以看到这些线程主要是垃圾回收线程-》上一节步骤2 通过jstat命令监控GC情况，可以看到Full GC次数非常多，并且次数在不断增加。–》上一节步骤5 确定是Full GC,接下来找到具体原因： 生成大量的对象，导致内存溢出-》执行步骤6，查看具体内存对象占用情况。 内存占用不高，但是Full GC次数还是比较多，此时可能是代码中手动调用 System.gc()导致GC次数过多，这可以通过添加 -XX:+DisableExplicitGC来禁用JVM对显示GC的响应。 2.代码中有大量消耗CPU的操作，导致CPU过高，系统运行缓慢； 执行步骤1-4：在步骤4jstack，可直接定位到代码行。例如某些复杂算法，甚至算法BUG，无限循环递归等等。 3.由于锁使用不当，导致死锁。 执行步骤1-4：如果有死锁，会直接提示。关键字：deadlock.步骤四，会打印出业务死锁的位置。 造成死锁的原因：最典型的就是2个线程互相等待对方持有的锁。 4.随机出现大量线程访问接口缓慢。 代码某个位置有阻塞性的操作，导致该功能调用整体比较耗时，但出现是比较随机的；平时消耗的CPU不多，而且占用的内存也不高。 ","date":"2021-05-03","objectID":"/cs_interview_eight_part_questions/:7:11","tags":["互聯網","大廠","面試題","計算機網路","操作系統","Database","數據結構","演算法","MySQL","C","C++","LeetCode","CS","計算機科學","軟件工程"],"title":"互聯網公司大廠 – 面試八股文彙整","uri":"/cs_interview_eight_part_questions/"},{"categories":["Moment"],"content":"系统调用和函数调用的区别 系统调用 操作系统服务的编程接口 通常由高级语言编写（C或C++） 程序访问通常通过高层次 的API接口（C标准库的库函数）而不是直接进行系统调用 每个系统调用对应一个系统调用编号 系统调用与函数调用的区别 系统调用 1.使用INT和IRET指令，内核和应用程序使用的是不同的堆栈，因此存在堆栈的切换，从用户态切换到内核态，从而可以使用特权指令操控设备 2.依赖于内核，不保证移植性 3.在用户空间和内核上下文环境间切换，开销较大 是操作系统的一个入口点 函数调用 1.使用CALL和RET指令，调用时没有堆栈切换 2.平台移植性好 3.属于过程调用，调用开销较小 4.一个普通功能函数的调用 圖表 函数库调用 系统调用 在所有的ANSI C编译器版本中，C库函数是相同的 各个操作系统的系统调用是不同的 它调用函数库中的一段程序（或函数） 它调用系统内核的服务 与用户程序相联系 是操作系统的一个入口点 在用户地址空间执行 在内核地址空间执行 它的运行时间属于**“用户时间”** 它的运行时间属于**“系统时间”** 属于过程调用，调用开销较小 需要在用户空间和内核上下文环境间切换，开销较大 在C函数库libc中有大约300个函数 在UNIX中大约有90个系统调用 典型的C函数库调用：system fprintf malloc 典型的系统调用：chdir fork write brk； ","date":"2021-05-03","objectID":"/cs_interview_eight_part_questions/:7:12","tags":["互聯網","大廠","面試題","計算機網路","操作系統","Database","數據結構","演算法","MySQL","C","C++","LeetCode","CS","計算機科學","軟件工程"],"title":"互聯網公司大廠 – 面試八股文彙整","uri":"/cs_interview_eight_part_questions/"},{"categories":["Moment"],"content":"动态库和静态库的区别 https://zhuanlan.zhihu.com/p/71372182 什么是静态库 前面所提到可重定位目标文件以一种特定的方式打包成一个单独的文件，并且在链接生成可执行文件时，从这个单独的文件中“拷贝”它自己需要的内容到最终的可执行文件中。这个单独的文件，称为静态库。linux中通常以.a(archive)为后缀 还是拿前面的例子来说，我们使用静态链接构建我们的可执行文件： $ gcc -c main.c $ gcc -static -o main main.o -lm 在这个过程中，就会用到系统中的静态库libm.a。这个过程做了什么呢？首先第一条命令会将main.c编译成可重定位目标文件main.o，第二条命令的static参数，告诉链接器应该使用静态链接，-lm参数表明链接libm.a这个库（类似的，如果要链接libxxx.a,使用-lxxx即可）。由于main.c中使用了libm.a中的exp函数，因此链接时，会将libm.a中需要的代码“拷贝”到最终的可执行文件main中。 特别注意，必须把-lm放在后面。放在最后时它是这样的一个解析过程： 链接器从左往右扫描可重定位目标文件和静态库扫描main.o时，发现一个未解析的符号exp，记住这个未解析的符号扫描libm.a，找到了前面未解析的符号，因此提取相关代码最终没有任何未解析的符号，编译链接完成 那如果将-lm放在前面，又是怎样的情况呢？ 链接器从左往右扫描可重定位目标文件和静态库扫描libm.a，由于前面没有任何未解析的符号，因此不会提取任何代码扫描main.o，发现未解析的符号exp扫描结束，还有一个未解析的符号，因此编译链接报错 如果把-lm放在前面，编译结果如下： $ gcc -static -lm -o main main.o main.o: In function `main': main.c:(.text+0x2f): undefined reference to `exp' collect2: error: ld returned 1 exit status 更详细的解释也可以参考《一个奇怪的链接问题》。 我们看看最终生成的文件大小： $ ls -lh main -rwxrwxr-x 1 hyb hyb 988K 6月 27 20:22 main 生成的可执行文件大小为988k。ls的高级用法可参考《ls命令常见实用用法》。 由于最终生成的可执行文件中已经包含了exp相关的二进制代码，因此这个可执行文件在一个没有libm.a的linux系统中也能正常运行。 什么是动态库 动态库和静态库类似，但是它并不在链接时将需要的二进制代码都“拷贝”到可执行文件中，而是仅仅“拷贝”一些重定位和符号表信息，这些信息可以在程序运行时完成真正的链接过程。linux中通常以.so（shared object）作为后缀。 通常我们编译的程序默认就是实用动态链接： $ gcc -o main main.c -lm #默认使用的是动态链接 我们来看最终生成的文件大小： $ ls -lh main -rwxrwxr-x 1 hyb hyb 8.5K 6月 27 20:25 main 可以看到，通过动态链接的程序只有8.5k！ 另外我们还可以通过ldd命令来观察可执行文件链接了哪些动态库： $ ldd main linux-vdso.so.1 =\u003e (0x00007ffc7b5a2000) libm.so.6 =\u003e /lib/x86_64-linux-gnu/libm.so.6 (0x00007fe9642bf000) libc.so.6 =\u003e /lib/x86_64-linux-gnu/libc.so.6 (0x00007fe963ef5000) /lib64/ld-linux-x86-64.so.2 (0x00007fe9645c8000) 正因为我们并没有把libm.so中的二进制代码“拷贝”可执行文件中，我们的程序在其他没有上面的动态库时，将无法正常运行。 有什么区别 到这里我们大致了解了静态库和动态库的区别了，静态库被使用目标代码最终和可执行文件在一起（它只会有自己用到的），而动态库与它相反，它的目标代码在运行时或者加载时链接。正是由于这个区别，会导致下面所介绍的这些区别。 可执行文件大小不一样 从前面也可以观察到，静态链接的可执行文件要比动态链接的可执行文件要大得多，因为它将需要用到的代码从二进制文件中“拷贝”了一份，而动态库仅仅是复制了一些重定位和符号表信息。 占用磁盘大小不一样 如果有多个可执行文件，那么静态库中的同一个函数的代码就会被复制多份，而动态库只有一份，因此使用静态库占用的磁盘空间相对比动态库要大。 扩展性与兼容性不一样 如果静态库中某个函数的实现变了，那么可执行文件必须重新编译，而对于动态链接生成的可执行文件，只需要更新动态库本身即可，不需要重新编译可执行文件。正因如此，使用动态库的程序方便升级和部署。 依赖不一样 静态链接的可执行文件不需要依赖其他的内容即可运行，而动态链接的可执行文件必须依赖动态库的存在。所以如果你在安装一些软件的时候，提示某个动态库不存在的时候也就不奇怪了。 即便如此，系统中一班存在一些大量公用的库，所以使用动态库并不会有什么问题。 复杂性不一样 相对来讲，动态库的处理要比静态库要复杂，例如，如何在运行时确定地址？多个进程如何共享一个动态库？当然，作为调用者我们不需要关注。另外动态库版本的管理也是一项技术活。这也不在本文的讨论范围。 加载速度不一样 由于静态库在链接时就和可执行文件在一块了，而动态库在加载或者运行时才链接，因此，对于同样的程序，静态链接的要比动态链接加载更快。所以选择静态库还是动态库是空间和时间的考量。但是通常来说，牺牲这点性能来换取程序在空间上的节省和部署的灵活性时值得的。再加上局部性原理，牺牲的性能并不多。 总结 静态库和动态库具体是何如链接的已经超出了本文的介绍范围，本文仅简单介绍了一些静态库和动态库的区别，另外文中提到的在其他的linux系统，也指的是同样处理器架构的系统。但是了解这些基本信息，就能够帮助我们解决很多编译问题了。更多内容可自己阅读装载，链接方面的书籍。后面的文章也会介绍更多相关信息。 ","date":"2021-05-03","objectID":"/cs_interview_eight_part_questions/:7:13","tags":["互聯網","大廠","面試題","計算機網路","操作系統","Database","數據結構","演算法","MySQL","C","C++","LeetCode","CS","計算機科學","軟件工程"],"title":"互聯網公司大廠 – 面試八股文彙整","uri":"/cs_interview_eight_part_questions/"},{"categories":["Moment"],"content":"阻塞和非阻塞的区别 https://blog.csdn.net/lengxiao1993/article/details/78154467 进程间的通信时通过 send() 和 receive() 两种基本操作完成的。具体如何实现这两种基础操作，存\u003e 在着不同的设计。 消息的传递有可能是阻塞的或非阻塞的 – 也被称为同步或异步的： 阻塞式发送（blocking send）. 发送方进程会被一直阻塞， 直到消息被接受方进程收到。 非阻塞式发送（nonblocking send）。 发送方进程调用 send() 后， 立即就可以其他操作。 阻塞式接收（blocking receive） 接收方调用 receive() 后一直阻塞， 直到消息到达可用。 非阻塞式接受（nonblocking receive） 接收方调用 receive() 函数后， 要么得到一个有效的结果， 要么得到一个空值， 即不会被阻塞。 上述不同类型的发送方式和不同类型的接收方式，可以自由组合。 我们所说的 “阻塞”是指进程在发起了一个系统调用（System Call） 后， 由于该系统调用的操作不能立即完成，需要等待一段时间，于是内核将进程挂起为**等待 （waiting）**状态， 以确保它不会被调度执行， 占用 CPU 资源。 I/O System Call 的阻塞/非阻塞， 同步/异步 这里再重新审视 阻塞/非阻塞 IO 这个概念， 其实阻塞和非阻塞描述的是进程的一个操作是否会使得进程转变为“等待”的状态， 但是为什么我们总是把它和 IO 连在一起讨论呢？ 原因是， 阻塞这个词是与系统调用 System Call 紧紧联系在一起的， 因为要让一个进程进入 等待（waiting） 的状态, 要么是它主动调用 wait() 或 sleep() 等挂起自己的操作， 另一种就是它调用 System Call, 而 System Call 因为涉及到了 I/O 操作， 不能立即完成， 于是内核就会先将该进程置为等待状态， 调度其他进程的运行， 等到 它所请求的 I/O 操作完成了以后， 再将其状态更改回 ready 。 操作系统内核在执行 System Call 时， CPU 需要与 IO 设备完成一系列物理通信上的交互， 其实再一次会涉及到阻塞和非阻塞的问题， 例如， 操作系统发起了一个读硬盘的请求后， 其实是向硬盘设备通过总线发出了一个请求，它即可以阻塞式地等待IO 设备的返回结果，也可以非阻塞式的继续其他的操作。 在现代计算机中，这些物理通信操作基本都是异步完成的， 即发出请求后， 等待 I/O 设备的中断信号后， 再来读取相应的设备缓冲区。 但是，大部分操作系统默认为用户级应用程序提供的都是阻塞式的系统调用 （blocking systemcall）接口， 因为阻塞式的调用，使得应用级代码的编写更容易（代码的执!行顺序和编写顺序是一致的）。 但同样， 现在的大部分操作系统也会提供非阻塞I/O 系统调用接口（Nonblocking I/O system call）。 一个非阻塞调用不会挂起调用程序， 而是会立即返回一个值， 表示有多少bytes 的数据被成功读取（或写入）。 非阻塞I/O 系统调用( nonblocking system call )的另一个替代品是 异步I/O系统调用 （asychronous system call）。 与非阻塞 I/O 系统调用类似，asychronous system call 也是会立即返回， 不会等待 I/O 操作的完成， 应用程序可以继续执行其他的操作， 等到 I/O 操作完成了以后，操作系统会通知调用进程（设置一个用户空间特殊的变量值 或者 触发一个 signal 或者 产生一个软中断 或者 调用应用程序的回调函数）。 此处， 非阻塞I/O 系统调用( nonblocking system call ) 和 **异步I/O系统调用 （asychronous system call）**的区别是： 1.一个非阻塞I/O 系统调用 read() 操作立即返回的是任何可以立即拿到的数据， 可以是完整的结果， 也可以是不完整的结果， 还可以是一个空值。 2.而异步I/O系统调用 read（）结果必须是完整的， 但是这个操作完成的通知可以延迟到将来的一个时间点。 下图展示了同步I/O 与 异步 I/O 的区别 （非阻塞 IO 在下图中没有绘出）. *注意， 上面提到的 非阻塞I/O 系统调用( nonblocking system call ) 和 异步I/O系统调用 都是非阻塞式的行为（non-blocking behavior）。 他们的差异仅仅是返回结果的方式和内容不同。 总结： 1.阻塞/非阻塞， 同步/异步的概念要注意讨论的上下文： 在进程通信层面， 阻塞/非阻塞， 同步/异步基本是同义词， 但是需要注意区分讨论的对象是发送方还是接收方。 发送方阻塞/非阻塞（同步/异步）和接收方的阻塞/非阻塞（同步/异步） 是互不影响的。 在 IO 系统调用层面（ IO system call ）层面， 非阻塞IO 系统调用 和 异步IO 系统调用存在着一定的差别， 它们都不会阻塞进程， 但是返回结果的方式和内容有所差别， 但是都属于非阻塞系统调用（ non-blocing system call ） 2.非阻塞系统调用（non-blocking I/O system call 与 asynchronous I/O system call） 的存在可以用来实现线程级别的 I/O 并发， 与通过多进程实现的 I/O 并发相比可以减少内存消耗以及进程切换的开销。 ","date":"2021-05-03","objectID":"/cs_interview_eight_part_questions/:7:14","tags":["互聯網","大廠","面試題","計算機網路","操作系統","Database","數據結構","演算法","MySQL","C","C++","LeetCode","CS","計算機科學","軟件工程"],"title":"互聯網公司大廠 – 面試八股文彙整","uri":"/cs_interview_eight_part_questions/"},{"categories":["Moment"],"content":"死锁的概念，发生的必要条件 https://blog.csdn.net/ZWE7616175/article/details/79881236 一、死锁概念 死锁是指两个或多个进程在执行的过程中，因为竞争资源而造成互相等待的现象，若无外力作用，它们都无法推进下去。 1.在等待对方时占有不可抢占的资源 举个例子，假设有P1，P2两个进程，都需要A和B两个资源，两个都等待另一个资源而不肯释放资源，就这样无限等待中，这就形成死锁。这只是死锁的一种情况，就是在等待对方时占有不可抢占的资源。 2.竞争可消耗资源引起死锁 有P1，P2，P3三个进程，P1向P2发送消息并接受P3消息，P2向P3发送消息并接受P2消息，P3向P1发送消息并接受P2消息，如果设置是先接到消息后发送消息，则所有的消息都不能发送，也造成了死锁。 3.进程推进顺序不当引起死锁 有进程P1，P2，都需要资源A,B，本来可以P1运行A，P1运行B，P2运行B，P2运行A，P2运行B，但顺序换了，P1运行A时P2运行B，容易引发死锁，属于第一种的资源抢占问题。 二、产生死锁的四个必要条件 1.互斥条件 一个资源每次只能被一个进程使用，即在一段时间内某资源仅为一个进程所使用。此时如果有其他进程请求该资源，则请求进程只能等待。 2.请求与保持条件 进程中已经保持了至少一个资源，但又提出了新的资源请求，而该资源已经被其他进程占有，此时请求进程被阻塞，但对自己已经获得资源保持不放。 3.不可剥夺条件 进程未使用完的资源在未使用完毕之前，不能被其他进程强行夺走，即只能由获得该资源的进程自己来释放。 4.循环等待条件 若干进程间形成首尾相接循环等待资源的关系。在发生死锁时必然存在一个进程等待队列{P1，P2，…,Pn},其中P1等待P2占有的资源，P2等待P3占有的资源，…，Pn等待P1占有的资源，形成一个进程等待环路，环路中每一个进程所占有的资源同时被另一个申请。 注意：这四个条件是死锁的必然条件，只要系统发生死锁，这些条件必然成立。只要有上述条件有一条不满足，就不会发生死锁。 三、死锁的预防 我们可以通过破坏产生死锁的四个必要条件来预防死锁，由于资源互斥是固有特性无法改变的。 1.破坏“请求与保持”条件 方法一：静态分配，每个进程在开始执行时就申请他所需要的全部资源。 方法二：动态分配，每个进程在申请所需要的资源时他本身不占用系统资源。 2.破坏“不可剥夺”条件 一个进程不可获得其所需要的全部资源便处于等待状态，等待期间他占用的资源将被隐式的释放重新加入到系统的资源列表中，可以被其他进程使用，而等待的进程只有重新获得自己原有的资源以及新申请的资源才可以重新启动，执行。 3.破坏“循环等待”条件 采用资源有序分配的基本思想。将系统中的资源顺序进行编号，将紧缺的、稀少的资源采用较大的编号，申请资源时必须按照编号的顺序执行，一个进程只有较小编号的进程才能申请较大编号的进程。 四、死锁的避免 基本思想：系统对进程发出每一个系统能够满足的资源申请进行动态检查，并根据检查结果决定是否分配资源，如果分配后系统可能发生死锁，则不予分配，否则分配。这是一种动态策略。典型的避免死锁的算法试银行家算法。 五、死锁的检测及解除 无需采取任何措施，允许进程在运行过程中发生死锁。通过系统的检测机构及时的检测出死锁的发生，然后采取某种措施解除死锁。 死锁的预防和避免都属于事先预防策略，但预防死锁的限制条件较为严格，实现起来较为简单，但往往导致资源利用率低。避免死锁的限制条件相对宽松，资源分配后需要通过算法来判断是否进入不安全状态，实现起来较为复杂。 ","date":"2021-05-03","objectID":"/cs_interview_eight_part_questions/:7:15","tags":["互聯網","大廠","面試題","計算機網路","操作系統","Database","數據結構","演算法","MySQL","C","C++","LeetCode","CS","計算機科學","軟件工程"],"title":"互聯網公司大廠 – 面試八股文彙整","uri":"/cs_interview_eight_part_questions/"},{"categories":["Moment"],"content":"怎么处理死锁 在上個問題中 如何实现多线程的数据同步 https://www.jianshu.com/p/54290e809f68 1.应用背景 程序在设计当中如果采取多线程操作的时候，如果操作的对象是一个的话，由于多个线程共享同一块内存空间，因此经常会遇到数据安全访问的问题，下面看一个经典的问题，银行取钱的问题： 1）、你有一张银行卡，里面有5000块钱，然后你到取款机取款，取出3000，当正在取的时候，取款机已经查询到你有5000块钱，然后正准备减去300块钱的时候 2）、你的老婆拿着那张银行卡对应的存折到银行取钱，也要取3000.然后银行的系统查询，存折账户里还有6000（因为上面钱还没扣），所以它也准备减去3000， 3）、你的卡里面减去3000，5000-3000=2000，并且你老婆的存折也是5000-3000=2000。 4）、结果，你们一共取了6000，但是卡里还剩下2000。 不难发现，当多个线程访问同一数据并操作的时候非常容易出现类似的问题，。为了避免这样的事情发生，我们要保证线程同步互斥，所谓同步互斥就是：并发执行的多个线程在某一时间内只允许一个线程在执行以访问共享数据。 2.同步互斥锁 同步锁原理：Java会为每个对象内置同步锁，通过使用synchronized来获取一个对象的同步锁，synchronized的使用方式，是在一段代码块中，加上synchronized(object){ … } 当线程首次执行到synchronized语句块时候会获得对象的同步锁（锁最开始属于对象，后被线程持有），在当前线程不释放同步锁时候，其他线程获取该对象同步锁的行为是被阻塞的，直到该锁被释放。以下几种情况下，线程才会释放掉对象的同步锁 1.线程执行完synchronized修饰的语句块。 2.线程主动执行wait()来释放同步锁。 同步锁虽然可以解决多并发引起的数据安全问题，但是会在一定程度上影响程序运行的效率，也会引起死锁问题。因此慎重使用。下面是别人描述的死锁，做引用。 死锁：多个线程同时被阻塞，它们中的一个或者全部都在等待某个资源被释放。由于线程被无限期地阻塞，因此程序不能正常运行。简单的说就是:线程死锁时，第一个线程等待第二个线程释放资源，而同时第二个线程又在等待第一个线程释放资源。这里举一个通俗的例子：如在人行道上两个人迎面相遇，为了给对方让道，两人同时向一侧迈出一步，双方无法通过，又同时向另一侧迈出一步，这样还是无法通过。假设这种情况一直持续下去，这样就会发生死锁现象。 导致死锁的根源在于不适当地运用“synchronized”关键词来管理线程对特定对象的访问。“synchronized”关键词的作用是，确保在某个时刻只有一个线程被允许执行特定的代码块，因此，被允许执行的线程首先必须拥有对变量或对象的排他性访问权。当线程访问对象时，线程会给对象加锁，而这个锁导致其它也想访问同一对象的线程被阻塞，直至第一个线程释放它加在对象上的锁。 一个死锁的造成很简单，比如有两个对象A 和 B 。第一个线程锁住了A，然后休眠1秒，轮到第二个线程执行，第二个线程锁住了B，然后也休眠1秒，然后有轮到第一个线程执行。第一个线程又企图锁住B，可是B已经被第二个线程锁定了，所以第一个线程进入阻塞状态，又切换到第二个线程执行。第二个线程又企图锁住A，可是A已经被第一个线程锁定了，所以第二个线程也进入阻塞状态。就这样，死锁造成了。 3.显式锁 为了符合Java面向对象的设计原则，在JDK1.5中，引入了显示锁的概念。 程序设计过程中如果提前发现可能会引起多线程数据访问的安全问题，可以通过Lock lock =newReentrantLock();来获取一个锁，并将该锁作为运行参数传入其中，在关键数据块之前使用lock.lock();来控制对竞争资源并发访问的控制，显式锁的优点是可以知道持有锁的对象，比同步锁也清晰好多。当然使用完之后也要主动释放(lock.unlock())。 4.读写锁 读写锁是在显示锁的基础上对读写进行分离的一种锁，可以认为是为了提高并发效率的一种优化。使用方法类比显式锁 初始化：ReentrantReadWriteLock rwl = new ReentrantReadWriteLock(); 四种操作： rwl.readLock().lock(); rwl.readLock().unlock() rwl.writeLock().lock(); rwl.writeLock().unlock() 关于读写锁之间的互斥： 1，读锁是排写锁操作的，读锁不排读锁操作，多个读锁可以并发不阻塞。即在读锁获取后和读锁释放之前，写锁并不能被任何线程获得，多个读锁同时作用期间，试图获取写锁的线程都处于等待状态，当最后一个读锁释放后,试图获取写锁的线程才有机会获取写锁。 2，写锁是排写锁、排读锁操作的。当一个线程获取到写锁之后，其他试图获取写锁和试图获取读锁的线程都处于等待状态，直到写锁被释放。 3，在写锁状态中，可以获取读锁 即线程持有写锁的状态下是可以继续申请读锁的。即一线程同时持有读锁和写锁 4，读锁是不能够获得写锁的，如果要加写锁，本线程必须释放所持有的读锁。 5.volatile 用volatile修饰的变量，线程在每次使用变量的时候，都会读取变量修改后的最的值。volatile很容易被误用，用来进行原子性操作，可以看作是一种轻量级的synchronized，但是是尽量保证每次读取的是最新的，并不绝对保证。 ","date":"2021-05-03","objectID":"/cs_interview_eight_part_questions/:7:16","tags":["互聯網","大廠","面試題","計算機網路","操作系統","Database","數據結構","演算法","MySQL","C","C++","LeetCode","CS","計算機科學","軟件工程"],"title":"互聯網公司大廠 – 面試八股文彙整","uri":"/cs_interview_eight_part_questions/"},{"categories":["Moment"],"content":"fork 的原理 在Linux中fork函数是非常重要的函数，它的作用是从已经存在的进程中创建一个子进程，而原进程称为父进程。 https://zhuanlan.zhihu.com/p/36872365 fork的原理 先通过下面这段代码简单的介绍一下fork这个函数，了解一下它的功能 #include \u003cunistd.h\u003e#include \u003cstdio.h\u003e int main() { int pid = fork(); if (pid == -1) return -1; if (pid) { printf(\"I am father, my pid is %d\\n\", getpid()); return 0; } else { printf(\"I am child, my pid is %d\\n\", getpid()); return 0; } } 下图是这段代码的运行结果 看到这个结果是不是很奇怪，为什么if的分支执行到了，else的分支也执行到了。这明显不符合程序执行最基本的原理。这个放到后面再来解释，先来了解一下fork这个函数 pid_t fork(); 上面是fork函数的原型，它有三个返回值 该进程为父进程时，返回子进程的pid 该进程为子进程时，返回0 fork执行失败，返回-1 那么问题来了，fork它是如何知道一个进程是父进程还是子进程的。 这个就涉及到fork本身的功能了，它的作用是克隆进程，也就是将原先的一个进程再克隆出一个来，克隆出的这个进程就是原进程的子进程，这个子进程和其他的进程没有什么区别，同样拥有自己的独立的地址空间。不同的是子进程是在fork返回之后才开始执行的，就像一把叉子一样，执行fork之后，父子进程就分道扬镳了，所以fork这个名字就很形象，叉子的意思。 这幅图就非常形象 接下来同过ps命令查看一下是否真的出现了两个一样的进程 透过这些现象，来看一下fork的本质。 fork在执行之后，会创建出一个新的进程，这个新的进程内部的数据是原进程所有数据的一份拷贝。因此fork就相当于把某个进程的全部资源复制了一遍，然后让cs：eip指向新进程的指令部分。 fork给父进程返回子进程pid，给其拷贝出来的子进程返回0，这也是他的特点之一，一次调用，两次返回。两次返回看上去有点神秘，实质是在子进程的栈中构造好数据后，子进程从栈中获取到的返回值。 fork的应用 fork的应用场景非常多，这里只讨论在这里kernel中的应用。 在之后的内容中，将会实现shell，那么这个shell由谁来调用呢。比如说内建的shell命令，他是写死在程序中的，本质上就是一个函数。肯定要有一个东西来调用它 在这个kernel的设计中，会有一个init进程，通过这个init进程fork出一个子进程，这个子进程就专门来处理我们的shell。 下一节就会实现shell了。终于从内核层到了用户层，可以直观的看出效果了。 ","date":"2021-05-03","objectID":"/cs_interview_eight_part_questions/:7:17","tags":["互聯網","大廠","面試題","計算機網路","操作系統","Database","數據結構","演算法","MySQL","C","C++","LeetCode","CS","計算機科學","軟件工程"],"title":"互聯網公司大廠 – 面試八股文彙整","uri":"/cs_interview_eight_part_questions/"},{"categories":["Moment"],"content":"服务端可以建立连接的最大数目由什么决定 在計算機網路區面試題有提到這問題 以下為延伸題 ","date":"2021-05-03","objectID":"/cs_interview_eight_part_questions/:7:18","tags":["互聯網","大廠","面試題","計算機網路","操作系統","Database","數據結構","演算法","MySQL","C","C++","LeetCode","CS","計算機科學","軟件工程"],"title":"互聯網公司大廠 – 面試八股文彙整","uri":"/cs_interview_eight_part_questions/"},{"categories":["Moment"],"content":"知道的系统调用有哪些 概述 在计算机中，系统调用（通常缩写为syscall）是计算机程序从操作系统的内核请求服务的程序化方式。这可能包括与硬件相关的服务（例如，访问硬盘驱动器），创建和执行新进程，以及与内核服务（如进程调度）的通信。系统调用提供了进程和操作系统之间的重要接口。 在大多数系统中，系统调用只能由用户空间的进程来进行，而在某些系统中，例如在OS/360及其继任者中，有特权的系统代码也会发出系统调用。 系统调用的类别 系统调用大致可以分为六大类： 1.过程控制 a.创建进程 b.终止进程 c.载入、执行 d.获取/设置过程属性 e.等待时间、等待事件、信号事件 f.分配和释放内存 2.文件管理 a.建文件、删文件 b.打开文件、关闭文件 c.读、写、调位置 d.获取/设置文件属性 3.设备管理 a.请求设器、释放设器 b.读、写、调位位置 c.获取/设置设备属性 d.连接或断开设备 4.信息维护 a.获取/设定时间或日期 b.获取/设置系统数据 c.获取/设置进程、文件或设备属性 5.通信 a.建立、断开通信 b.收发信息 c.转移状态信息 d.连接和断开远程设备 6.保护措施 a.获取/设置权限 安全模型 除了一些嵌入式系统外，大多数现代处理器的架构都涉及到安全模型。例如，环形模型指定了软件可以执行的多个权限级别：一个程序通常被限制在自己的地址空间内，这样它就不能访问或修改其他运行中的程序或操作系统本身，并且通常被阻止直接操作硬件设备（如帧缓冲区或网络设备）。 但是，很多时候许多应用程序需要访问这些组件来完成自己的任务，因此操作系统就提供了系统调用，为这类操作提供定义良好的、实现安全的通信方式。 操作系统以最高级别的权限执行，允许应用程序通过系统调用请求使用服务，而系统调用通常是通过中断发起的。中断会自动使CPU进入某种高权限级别，然后将控制权传递给内核，由内核决定调用程序是否应该被授予所请求的服务。 如果请求服务被允许的话，内核会执行一组特定的指令来完成任务。而调用程序对内核没有直接控制权，任务完成后将控制权返回给调用程序。 程序库API 一般来说，系统环境会提供了一个程序库来暴露一些API，这些API可以在应用程序和操作系统之间完成通信任务。 在类似Unix的系统中，这些API通常是C程序库库(libc)实现的一部分，例如glibc，它为系统调用提供了封装函数，通常与系统调用的名称相同。 在Windows NT上，这个API是Native API的一部分，在ntdll.dll库中；这是一个未公开发行的API，被常规Windows API的实现所使用，也被Windows上的一些系统程序直接使用。该库的封装函数层提供了一个普通函数调用的方法（是汇编级的子程序调用），用于使用系统调用，这也使得系统调用更加模块化。 在这里，封装层的主要功能是将所有要传递给系统调用的参数都放在相应的处理器寄存器中（有时也可以放在调用栈中），同时也为内核设置一个唯一的系统调用编号来调用。这样一来，存在于操作系统和应用程序之间的库就增加了可移植性。 对库函数本身的调用不会导致切换到内核模式，通常是正常的子程序调用（例如，在某些指令集架构（ISA）中使用 “CALL\"汇编指令）。 实际的系统调用确实将控制权转移到了内核（而且这比抽象的库调用更依赖于具体的实现和平台环境）。例如，在类似Unix的系统中，fork和execve是C库函数，这些函数反过来调用fork和exec这些系统调用的指令。 直接在应用程序代码中进行系统调用比较复杂，可能需要使用嵌入式汇编代码(在C和C++中)，并且需要了解系统调用操作的底层二进制接口，而这些二进制接口可能会随着时间的推移而变化，它们不是应用程序二进制接口的一部分，而程序库函数的作用就是为了抽象出这些逻辑而创建的。 在基于exokernel的系统中，库作为中介的作用尤为重要。在exokernels上，库将用户应用屏蔽在非常低级的内核API中，并提供抽象层和资源管理。 由OS/360和DOS/360衍生出来的IBM操作系统，包括z/OS和z/VSE，都是通过汇编语言宏程序库来实现系统调用的。它们的起源于汇编语言编程比高级语言更普遍的年代。因此，IBM的系统调用不能被高级语言程序直接调用，而是需要一个封装的可调用的汇编语言子程序。 系统中的示例和检测工具 **在Unix、Unix-like和其他兼容POSIX的操作系统上，常用的系统调用有open、read、write、close、wait、exec、exc、fork、exit和kill。**许多现代操作系统都有数百个系统调用。例如，Linux和OpenBSD各有300多个不同的调用，NetBSD有近500个，FreeBSD有500多个，Windows 7有近700个，而Plan9有51个。 有些工具如strace、ftrace和truss等可以从进程一开始就跟踪报告该进程调用的所有系统调用，或者可以把这些工具绑定附加到一个已经运行的进程上来跟踪其进程调用情况。只要该追踪操作不违反用户的权限，就可以拦截该进程所做的任何系统调用。这些程序工具的这种特殊能力通常也是通过系统调用来实现的，例如strace是通过ptrace或procfs中的文件的系统调用来实现。 ","date":"2021-05-03","objectID":"/cs_interview_eight_part_questions/:7:19","tags":["互聯網","大廠","面試題","計算機網路","操作系統","Database","數據結構","演算法","MySQL","C","C++","LeetCode","CS","計算機科學","軟件工程"],"title":"互聯網公司大廠 – 面試八股文彙整","uri":"/cs_interview_eight_part_questions/"},{"categories":["Moment"],"content":"多个父子进程不断循环申请内存，总数量超出内存大小，会发生什么 自閉中 只要不写入，不无限fork，理论上没影响 申请了不用（触发缺页中断，真正分配内存）是不会发生任何事情的 操作系统一般允许 overcommit…要是没开 overcommit 的话分配会失败，什么也不会发生 不过加了个循环fork，所以就不一样了 fork 是指的是 fork bomb 那种量级的 fork？😂 是的，最终会内存 or fd 爆炸而结束 Overcommit Memory Overcommit的意思是作業系統承諾給進程的內存大小超過了實際可用的內存。一個保守的作業系統不會允許memory overcommit，有多少就分配多少，再申請就沒有了，這其實有些浪費內存，因為進程實際使用到的內存往往比申請的內存要少，比如某個進程malloc()了200MB內存，但實際上只用到了100MB，按照UNIX/Linux的算法，物理內存頁的分配發生在使用的瞬間，而不是在申請的瞬間，也就是說未用到的100MB內存根本就沒有分配，這100MB內存就閒置了。下面這個概念很重要，是理解memory overcommit的關鍵：commit(或overcommit)針對的是內存申請，內存申請不等於內存分配，內存只在實際用到的時候才分配。 file descriptor https://kkc.github.io/2020/08/22/file-descriptor/ file descriptor (fd) 基本上是一層介面，可以讓我們去操作 file 和其他 input/output interface (例如 pipe \u0026 socket)。 ","date":"2021-05-03","objectID":"/cs_interview_eight_part_questions/:7:20","tags":["互聯網","大廠","面試題","計算機網路","操作系統","Database","數據結構","演算法","MySQL","C","C++","LeetCode","CS","計算機科學","軟件工程"],"title":"互聯網公司大廠 – 面試八股文彙整","uri":"/cs_interview_eight_part_questions/"},{"categories":["Moment"],"content":"申请超出总内存大小的内存后，在每个进程中堆内存进行读写，会发生什么 自閉中 視乎情況會先使用 swap / 分頁檔 再不行會觸發 OOM Killer / 應用崩潰 ","date":"2021-05-03","objectID":"/cs_interview_eight_part_questions/:7:21","tags":["互聯網","大廠","面試題","計算機網路","操作系統","Database","數據結構","演算法","MySQL","C","C++","LeetCode","CS","計算機科學","軟件工程"],"title":"互聯網公司大廠 – 面試八股文彙整","uri":"/cs_interview_eight_part_questions/"},{"categories":["Moment"],"content":"多个父子进程同时对同一个文件进行修改，发生什么 自閉中 https://meik2333.com/posts/linux-many-proc-write-file/ ","date":"2021-05-03","objectID":"/cs_interview_eight_part_questions/:7:22","tags":["互聯網","大廠","面試題","計算機網路","操作系統","Database","數據結構","演算法","MySQL","C","C++","LeetCode","CS","計算機科學","軟件工程"],"title":"互聯網公司大廠 – 面試八股文彙整","uri":"/cs_interview_eight_part_questions/"},{"categories":["Moment"],"content":"recv返回值的含义 recv方法： 模型： #include \u003csys/types.h\u003e #include \u003csys/socket.h\u003e ssize_t recv(int sockfd, void *buf, size_t len, int flags); 参数： sockfd创建的文件描述符fd，buf接收数据的缓冲区，len接收数据的长度，flags表示信息，默认设置为0 当应用程序调用recv接收数据的时候，recv函数会等待sockfd中发送数据的缓冲区的协议发送完数据，如果在等待过程中出现网络错误，则会返回SOCKET_ERROR。如果sockfd中的缓冲区中没有数据或者协议已经发送完数据，则recv会检查sockfd的接受缓冲区，如果该缓冲区正在接受数据，则recv会一直等待，知道缓冲区接受数据完毕，之后recv将数据从缓冲区拷贝一份值buf中，数据通过协议转发的，recv只是将数据从缓冲区拷贝过来。注，如果recv在拷贝数据时出现错误，则返回SOCKET_ERROT,如果在协议传输数据中出现网络错误，则返回0。 阻塞与非阻塞recv返回值没有区别，都是： \u003c0 出错 =0 对方调用了close API来关闭连接 \u003e0 接收到的数据大小， 特别地：返回值\u003c0时并且$(errno == EINTR || errno == EWOULDBLOCK || errno == EAGAIN)$的情况下认为连接是正常的，继续接收。 但是如下特点： 只是阻塞模式下recv会一直阻塞直到接收到数据，非阻塞模式下如果没有数据就会返回，不会阻塞着读，因此需要循环读取）。 返回说明： （1）成功执行时，返回接收到的字节数。 （2）若另一端已关闭连接则返回0，这种关闭是对方主动且正常的关闭 （3）失败返回-1，errno被设为以下的某个值 EAGAIN：套接字已标记为非阻塞，而接收操作被阻塞或者接收超时 EBADF：sock不是有效的描述词 ECONNREFUSE：远程主机阻绝网络连接 EFAULT：内存空间访问出错 EINTR：操作被信号中断 EINVAL：参数无效 ENOMEM：内存不足 ENOTCONN：与面向连接关联的套接字尚未被连接上 ENOTSOCK：sock索引的不是套接字 send方法： 模型： #include \u003csys/types.h\u003e#include \u003csys/socket.h\u003e ssize_t send(int sockfd, const void *buf, size_t len, int flags); 参数： sockfd：创建的sockfd文件描述符，buf发送数据所在的数据区，len发送数据的长度，flags标志位默认设置为0 当程序使用send方法的时候，send会首先检查协议sockfd中的发送缓冲区中是否有数据发送，send会比较发送数据的buf长度和sockfd发送数据的缓冲区长度，如果len大于sockfd的发送长度，则send返回SOCKET_ERROR，如果发送缓冲区的大小足够，则将数据buf中的数据发送至发送缓冲区中，确认send函数将数据拷贝至发送换区中，另外，如果send检测发送缓冲区有数据但是还未发送，就比较该缓冲区的剩余空间和和len的大小，如果len大于剩余空间，就一直等待，直到缓冲区中的数据发送玩为止，如果len \u003c 缓冲区剩余的大小，就将发送的数据拷贝至该缓冲区中，如果send函数copy数据成功，就返回实际copy的字节数，如果send在copy数据时出现错误，那么send就返回SOCKET_ERROR；如果send在等待协议传送数据时网络断开的话，那么send函数也返回SOCKET_ERROR。(send函数只是将数据拷贝至发送缓冲中，就返回，此刻数据不一定发送至接收端)。 总结，不管是send还是recv方法，都是数据的缓冲区和发送的缓冲区的拷贝操作过程，真正发送数据的是协议功能，注意三种返回值的可能性，\u003e0表示成功，返回实际发送或接受的字节数，=0表示超时，对方主动关闭了连接过程，\u003c0出错，此种情况可能出现过重情况，如上所示。其中errno == EINTR || errno == EWOULDBLOCK || errno == EAGAIN这三种是特殊情况，实际使用中表示继续正常接受数据即可。 如图所示通信过程： send()方法的行为 对于send方法，将需要发送的数据拷贝至发送缓冲区，否则进入阻塞或者进入超时等待。如果改变这种状态，将发送缓冲区大小设置为0，这样，当send方法返回是，所发送的数据就都到达目的机器。但是，只是到达目标服务器的接受缓冲区，并不保证数据以被应用层所接收。另外， 在发送数据时，协议根据滑动窗口和MSS值来确定tcp报文段的数据字段大小，这样就能保证接收缓冲区不会溢出。如果接收方的滑动窗口为0，但是发送方还有数据尚未发送完成，就是用探测机制，一方面检测对方方的滑动窗口的大小变化（探测机制是通过每次发送一个字节来进行检测，由先前的30s到之后的1分钟，最终达到2分钟间隔）)，另一方面检测对方的连接是否异常。 push标志指示接收端应尽快将数据提交给应用层。如果send函数提交的待发送数据量较小，例如小于1460B（参照MSS值确定），那么协议层会将该报文中的TCP头部的push字段置为1；如果待发送的数据量较大，需要拆成多个数据段发送时，协议层只会将最后一个分段报文的TCP头部的push字段置1。 recv()方法的行为 对recv方法来说，将接收缓冲区中的数据拷贝至应用层的缓冲区中，当应用缓冲区满或者接受缓冲区数据接收完，就会返回。如果将接受缓冲区大小设置为0，那么该方法会直接从协议中的滑动窗口中获取数据。要么缓冲区接收满为止。要么当push标志位1的时候 ，recv返回实际接收的数据大小。 协议层收到TCP数据包后(保存在滑动窗口区)，本方的滑动窗口合拢（窗口值减小）；当协议层将数据拷贝到接收缓冲区(滑动窗口区—\u003e接收缓冲区)，或者应用层调用recv接收数据(接收缓冲区—\u003e应用层缓冲区，滑动窗口区—\u003e应用层缓冲区)后，本方的滑动窗口张开(窗口值增大)。收到数据更新window后，协议层向对方发送ACK确认。 ","date":"2021-05-03","objectID":"/cs_interview_eight_part_questions/:7:23","tags":["互聯網","大廠","面試題","計算機網路","操作系統","Database","數據結構","演算法","MySQL","C","C++","LeetCode","CS","計算機科學","軟件工程"],"title":"互聯網公司大廠 – 面試八股文彙整","uri":"/cs_interview_eight_part_questions/"},{"categories":["Moment"],"content":"Linux Linux 的 mutex、semphore、condition_variable、read-write-lock 等操作系统API。 ","date":"2021-05-03","objectID":"/cs_interview_eight_part_questions/:8:0","tags":["互聯網","大廠","面試題","計算機網路","操作系統","Database","數據結構","演算法","MySQL","C","C++","LeetCode","CS","計算機科學","軟件工程"],"title":"互聯網公司大廠 – 面試八股文彙整","uri":"/cs_interview_eight_part_questions/"},{"categories":["Moment"],"content":"Linux 常用指令 https://www.runoob.com/w3cnote/linux-common-command-2.html 特別注意 查看系統指令 1、ls命令 就是 list 的缩写，通过 ls 命令不仅可以查看 linux 文件夹包含的文件，而且可以查看文件权限(包括目录、文件夹、文件权限)查看目录信息等等。 常用参数搭配： ls -a 列出目录所有文件，包含以.开始的隐藏文件 ls -A 列出除.及..的其它文件 ls -r 反序排列 ls -t 以文件修改时间排序 ls -S 以文件大小排序 ls -h 以易读大小显示 ls -l 除了文件名之外，还将文件的权限、所有者、文件大小等信息详细列出来 2、cd 命令 cd(changeDirectory) 命令语法： cd [目录名] 说明：切换当前目录至 dirName。 3、pwd 命令 pwd 命令用于查看当前工作目录路径。 4、mkdir 命令 mkdir 命令用于创建文件夹。 可用选项： -m: 对新建目录设置存取权限，也可以用 chmod 命令设置; -p: 可以是一个路径名称。此时若路径中的某些目录尚不存在,加上此选项后，系统将自动建立好那些尚不在的目录，即一次可以建立多个目录。 5、rm 命令 删除一个目录中的一个或多个文件或目录，如果没有使用 -r 选项，则 rm 不会删除目录。如果使用 rm 来删除文件，通常仍可以将该文件恢复原状。 rm [选项] 文件… 6、rmdir 命令 从一个目录中删除一个或多个子目录项，删除某目录时也必须具有对其父目录的写权限。 注意：不能删除非空目录 7、mv 命令 移动文件或修改文件名，根据第二参数类型（如目录，则移动文件；如为文件则重命令该文件）。 当第二个参数为目录时，第一个参数可以是多个以空格分隔的文件或目录，然后移动第一个参数指定的多个文件到第二个参数指定的目录中。 8、cp 命令 将源文件复制至目标文件，或将多个源文件复制至目标目录。 注意：命令行复制，如果目标文件已经存在会提示是否覆盖，而在 shell 脚本中，如果不加 -i 参数，则不会提示，而是直接覆盖！ -i 提示 -r 复制目录及目录内所有项目 -a 复制的文件与原文件时间一样 9、cat 命令 cat 主要有三大功能： 1.一次显示整个文件: cat filename 2.从键盘创建一个文件: cat \u003e filename 只能创建新文件，不能编辑已有文件。 3.将几个文件合并为一个文件: cat file1 file2 \u003e file -b 对非空输出行号 -n 输出所有行号 10、more 命令 功能类似于 cat, more 会以一页一页的显示方便使用者逐页阅读，而最基本的指令就是按空白键（space）就往下一页显示，按 b 键就会往回（back）一页显示。 命令参数： +n 从笫 n 行开始显示 -n 定义屏幕大小为n行 +/pattern 在每个档案显示前搜寻该字串（pattern），然后从该字串前两行之后开始显示 -c 从顶部清屏，然后显示 -d 提示“Press space to continue，’q’ to quit（按空格键继续，按q键退出）”，禁用响铃功能 -l 忽略Ctrl+l（换页）字符 -p 通过清除窗口而不是滚屏来对文件进行换页，与-c选项相似 -s 把连续的多个空行显示为一行 -u 把文件内容中的下画线去掉 常用操作命令： Enter 向下 n 行，需要定义。默认为 1 行 Ctrl+F 向下滚动一屏 空格键 向下滚动一屏 Ctrl+B 返回上一屏 = 输出当前行的行号 :f 输出文件名和当前行的行号 V 调用vi编辑器 !命令 调用Shell，并执行命令 q 退出more 11、less 命令 less 与 more 类似，但使用 less 可以随意浏览文件，而 more 仅能向前移动，却不能向后移动，而且 less 在查看之前不会加载整个文件。 常用命令参数： -i 忽略搜索时的大小写 -N 显示每行的行号 -o \u003c文件名\u003e 将less 输出的内容在指定文件中保存起来 -s 显示连续空行为一行 /字符串：向下搜索“字符串”的功能 ?字符串：向上搜索“字符串”的功能 n：重复前一个搜索（与 / 或 ? 有关） N：反向重复前一个搜索（与 / 或 ? 有关） -x \u003c数字\u003e 将“tab”键显示为规定的数字空格 b 向后翻一页 d 向后翻半页 h 显示帮助界面 Q 退出less 命令 u 向前滚动半页 y 向前滚动一行 空格键 滚动一行 回车键 滚动一页 [pagedown]： 向下翻动一页 [pageup]： 向上翻动一页 实例： （1）ps 查看进程信息并通过 less 分页显示 ps -aux | less -N （2）查看多个文件 less 1.log 2.log 12、head 命令 head 用来显示档案的开头至标准输出中，默认 head 命令打印其相应文件的开头 10 行。 常用参数： -n\u003c行数\u003e 显示的行数（行数为复数表示从最后向前数） 13、tail 命令 用于显示指定文件末尾内容，不指定文件时，作为输入信息进行处理。常用查看日志文件。 常用参数： -f 循环读取（常用于查看递增的日志文件） -n\u003c行数\u003e 显示行数（从后向前） （1）循环读取逐渐增加的文件内容 ping 127.0.0.1 \u003e ping.log \u0026 后台运行：可使用 jobs -l 查看，也可使用 fg 将其移到前台运行。 tail -f ping.log （查看日志） 14、which 命令 在 linux 要查找某个文件，但不知道放在哪里了，可以使用下面的一些命令来搜索： which 查看可执行文件的位置。 whereis 查看文件的位置。 locate 配合数据库查看文件位置。 find 实际搜寻硬盘查询文件名称。 which 是在 PATH 就是指定的路径中，搜索某个系统命令的位置，并返回第一个搜索结果。使用 which 命令，就可以看到某个系统命令是否存在，以及执行的到底是哪一个位置的命令。 常用参数： -n 指定文件名长度，指定的长度必须大于或等于所有文件中最长的文件名。 17、find 命令 用于在文件树中查找文件，并作出相应的处理。 命令格式： find pathname -options [-print -exec -ok …] 命令参数： pathname: find命令所查找的目录路径。例如用.来表示当前目录，用/来表示系统根目录。 -print： find命令将匹配的文件输出到标准输出。 -exec： find命令对匹配的文件执行该参数所给出的shell命令。相应命令的形式为’command' { } ;，注意{ }和\\；之间的空格。 -ok： 和-exec的作用相同，只不过以一种更为安全的模式来执行该参数所给出的shell命令，在执行每一个命令之前，都会给出提示，让用户来确定是否执行。 命令选项： -name 按照文件名查找文件 -perm 按文件权限查找文件 -user 按文件属主查找文件 -group 按照文件所属的组来查找文件。 -type 查找某一类型的文件，诸如： b - 块设备文件 d - 目录 c - 字符设备文件 l - 符号链接文件 p - 管道文件 f - 普通文件 -size n :[c] 查找文件长度为n块文件，带有c时表文件字节大小 -amin n 查找系统中最后N分钟访问的文件 -atime n 查找系统中最后n24小时访问的文件 -cmin n 查找系统中最后N分钟被改变文件状态的文件 -ctime n 查找系统中最后n24小时被改变文件状态的文件 -mmin n 查找系统中最后N分钟被改变文件数据的文件 -mtime n 查找系统中最后n*24小时被改变文件数据的文件 (用减号-来限定更改时间在距今n日以内的文件，而用加号+来限定更改时间在距今n日以前的文件。 ) -maxdepth n 最大查找目录深度 -prune 选项来指出需要忽略的目录。在使用-prune选项时要当心，因为如果你同时使用了-depth选项，那么-prune选项就会被find命令忽略 -newer 如果希望查找更改时间比某个文件新但比另一个文件旧的所有文件，可以使用-newer选项 18、chmod 命令 用于改变 linux 系统文件或目录的访问权限。用它控制文件或目录的访问权限。该命令有两种用法。一种是包含字母和操作符表达式的文字设定法；另一种是包含数字的数字设定法。 每一文件或目录的访问权限都有三组，每组用三位表示，分别为文件属主的读、写和执行权限；与属主同组的用户的读、写和执行权限；系统中其他用户的读、写和执行权限。可使用 ls -l test.txt 查找。 以文件 log2012.log 为例： -rw-r–r– 1 root root 296K 11-13 06:03 log2012.log 第一列共有 10 个位置，第一个字符指定了文件类型。在通常意义上，一个目录也是一个文件。如果第一个字符是横线，表示是一个非目录的文件。如果是 d，表示是一个目录。从第二个字符开始到第十个 9 个字符，3 个字符一组，分别表示了 3 组用户对文件或者目录的权限。权限字符用横线代表空许可，r 代表只读，w 代表写，x 代表可执行。 常用参数： -c 当发生改变时，报告处理信息 -R 处理指定目录以及其子目录下所有文件 权限范围： u ：目录或者文件的当前的用户 g ：目录或者文件的当前的群组 o ：除了目录或者文","date":"2021-05-03","objectID":"/cs_interview_eight_part_questions/:8:1","tags":["互聯網","大廠","面試題","計算機網路","操作系統","Database","數據結構","演算法","MySQL","C","C++","LeetCode","CS","計算機科學","軟件工程"],"title":"互聯網公司大廠 – 面試八股文彙整","uri":"/cs_interview_eight_part_questions/"},{"categories":["Moment"],"content":"算法 非常重要：記得一定要刷 LeetCode 的劍指 Offer。 考試概率: 快速排序 \u003e 冒泡排序 \u003e 归并排序 \u003e 桶排序 十大经典排序算法 https://www.runoob.com/w3cnote/ten-sorting-algorithm.html ","date":"2021-05-03","objectID":"/cs_interview_eight_part_questions/:9:0","tags":["互聯網","大廠","面試題","計算機網路","操作系統","Database","數據結構","演算法","MySQL","C","C++","LeetCode","CS","計算機科學","軟件工程"],"title":"互聯網公司大廠 – 面試八股文彙整","uri":"/cs_interview_eight_part_questions/"},{"categories":["Moment"],"content":"排序的稳定性，概念 这个说错了，我还以为试是问时r[j]之前，而在排序后的序列中，r[i]仍在r[j]之前，则称这种排序算法是稳定的；否则称为不稳定的。 ","date":"2021-05-03","objectID":"/cs_interview_eight_part_questions/:9:1","tags":["互聯網","大廠","面試題","計算機網路","操作系統","Database","數據結構","演算法","MySQL","C","C++","LeetCode","CS","計算機科學","軟件工程"],"title":"互聯網公司大廠 – 面試八股文彙整","uri":"/cs_interview_eight_part_questions/"},{"categories":["Moment"],"content":"氣泡排序 低概率 冒泡排序（Bubble Sort）也是一种简单直观的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢\"浮\"到数列的顶端。 作为最简单的排序算法之一，冒泡排序给我的感觉就像 Abandon 在单词书里出现的感觉一样，每次都在第一页第一位，所以最熟悉。冒泡排序还有一种优化算法，就是立一个 flag，当在一趟序列遍历中元素没有发生交换，则证明该序列已经有序。但这种改进对于提升性能来 说并没有什么太大作用。 算法步骤 比较相邻的元素。如果第一个比第二个大，就交换他们两个。 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。 针对所有的元素重复以上的步骤，除了最后一个。 持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。 #include \u003cstdio.h\u003evoid bubble_sort(int arr[], int len) { int i, j, temp; for (i = 0; i \u003c len - 1; i++) for (j = 0; j \u003c len - 1 - i; j++) if (arr[j] \u003e arr[j + 1]) { temp = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = temp; } } int main() { int arr[] = { 22, 34, 3, 32, 82, 55, 89, 50, 37, 5, 64, 35, 9, 70 }; int len = (int) sizeof(arr) / sizeof(*arr); bubble_sort(arr, len); int i; for (i = 0; i \u003c len; i++) printf(\"%d \", arr[i]); return 0; } ","date":"2021-05-03","objectID":"/cs_interview_eight_part_questions/:9:2","tags":["互聯網","大廠","面試題","計算機網路","操作系統","Database","數據結構","演算法","MySQL","C","C++","LeetCode","CS","計算機科學","軟件工程"],"title":"互聯網公司大廠 – 面試八股文彙整","uri":"/cs_interview_eight_part_questions/"},{"categories":["Moment"],"content":"插入排序 插入排序的代码实现虽然没有冒泡排序和选择排序那么简单粗暴，但它的原理应该是最容易理解的了，因为只要打过扑克牌的人都应该能够秒懂。插入排序是一种最简单直观的排序算法，它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。 插入排序和冒泡排序一样，也有一种优化算法，叫做拆半插入。 算法步骤 将第一待排序序列第一个元素看做一个有序序列，把第二个元素到最后一个元素当成是未排序序列。 从头到尾依次扫描未排序序列，将扫描到的每个元素插入有序序列的适当位置。（如果待插入的元素与有序序列中的某个元素相等，则将待插入元素插入到相等元素的后面。） void insertion_sort(int arr[], int len){ int i,j,key; for (i=1;i\u003clen;i++){ key = arr[i]; j=i-1; while((j\u003e=0) \u0026\u0026 (arr[j]\u003ekey)) { arr[j+1] = arr[j]; j--; } arr[j+1] = key; } } ","date":"2021-05-03","objectID":"/cs_interview_eight_part_questions/:9:3","tags":["互聯網","大廠","面試題","計算機網路","操作系統","Database","數據結構","演算法","MySQL","C","C++","LeetCode","CS","計算機科學","軟件工程"],"title":"互聯網公司大廠 – 面試八股文彙整","uri":"/cs_interview_eight_part_questions/"},{"categories":["Moment"],"content":"归并排序 归并排序（Merge sort）是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。 作为一种典型的分而治之思想的算法应用，归并排序的实现由两种方法： 自上而下的递归（所有递归的方法都可以用迭代重写，所以就有了第 2 种方法）； 自下而上的迭代； 在《数据结构与算法 JavaScript 描述》中，作者给出了自下而上的迭代方法。但是对于递归法，作者却认为： However, it is not possible to do so in JavaScript, as the recursion goes too deep for the language to handle. 然而，在 JavaScript 中这种方式不太可行，因为这个算法的递归深度对它来讲太深了。 说实话，我不太理解这句话。意思是 JavaScript 编译器内存太小，递归太深容易造成内存溢出吗？还望有大神能够指教。 和选择排序一样，归并排序的性能不受输入数据的影响，但表现比选择排序好的多，因为始终都是 O(nlogn) 的时间复杂度。代价是需要额外的内存空间。 算法步骤 申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列； 设定两个指针，最初位置分别为两个已经排序序列的起始位置； 比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置； 重复步骤 3 直到某一指针达到序列尾； 将另一序列剩下的所有元素直接复制到合并序列尾。 int min(int x, int y) { return x \u003c y ? x : y; } void merge_sort(int arr[], int len) { int *a = arr; int *b = (int *) malloc(len * sizeof(int)); int seg, start; for (seg = 1; seg \u003c len; seg += seg) { for (start = 0; start \u003c len; start += seg * 2) { int low = start, mid = min(start + seg, len), high = min(start + seg * 2, len); int k = low; int start1 = low, end1 = mid; int start2 = mid, end2 = high; while (start1 \u003c end1 \u0026\u0026 start2 \u003c end2) b[k++] = a[start1] \u003c a[start2] ? a[start1++] : a[start2++]; while (start1 \u003c end1) b[k++] = a[start1++]; while (start2 \u003c end2) b[k++] = a[start2++]; } int *temp = a; a = b; b = temp; } if (a != arr) { int i; for (i = 0; i \u003c len; i++) b[i] = a[i]; b = a; } free(b); } ","date":"2021-05-03","objectID":"/cs_interview_eight_part_questions/:9:4","tags":["互聯網","大廠","面試題","計算機網路","操作系統","Database","數據結構","演算法","MySQL","C","C++","LeetCode","CS","計算機科學","軟件工程"],"title":"互聯網公司大廠 – 面試八股文彙整","uri":"/cs_interview_eight_part_questions/"},{"categories":["Moment"],"content":"快速排序 快速排序是由东尼·霍尔所发展的一种排序算法。在平均状况下，排序 n 个项目要 Ο(nlogn) 次比较。在最坏状况下则需要 Ο(n2) 次比较，但这种状况并不常见。事实上，快速排序通常明显比其他 Ο(nlogn) 算法更快，因为它的内部循环（inner loop）可以在大部分的架构上很有效率地被实现出来。 快速排序使用分治法（Divide and conquer）策略来把一个串行（list）分为两个子串行（sub-lists）。 快速排序又是一种分而治之思想在排序算法上的典型应用。本质上来看，快速排序应该算是在冒泡排序基础上的递归分治法。 快速排序的名字起的是简单粗暴，因为一听到这个名字你就知道它存在的意义，就是快，而且效率高！它是处理大数据最快的排序算法之一了。虽然 Worst Case 的时间复杂度达到了 O(n²)，但是人家就是优秀，在大多数情况下都比平均时间复杂度为 O(n logn) 的排序算法表现要更好，可是这是为什么呢，我也不知道。好在我的强迫症又犯了，查了 N 多资料终于在《算法艺术与信息学竞赛》上找到了满意的答案： 快速排序的最坏运行情况是 O(n²)，比如说顺序数列的快排。但它的平摊期望时间是 O(nlogn)，且 O(nlogn) 记号中隐含的常数因子很小，比复杂度稳定等于 O(nlogn) 的归并排序要小很多。所以，对绝大多数顺序性较弱的随机数列而言，快速排序总是优于归并排序。 算法步骤 从数列中挑出一个元素，称为 “基准”（pivot）; 重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作； 递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序； 循環解法 typedef struct _Range { int start, end; } Range; Range new_Range(int s, int e) { Range r; r.start = s; r.end = e; return r; } void swap(int *x, int *y) { int t = *x; *x = *y; *y = t; } void quick_sort(int arr[], const int len) { if (len \u003c= 0) return; // 避免len等於負值時引發段錯誤（Segment Fault） // r[]模擬列表,p為數量,r[p++]為push,r[--p]為pop且取得元素 Range r[len]; int p = 0; r[p++] = new_Range(0, len - 1); while (p) { Range range = r[--p]; if (range.start \u003e= range.end) continue; int mid = arr[(range.start + range.end) / 2]; // 選取中間點為基準點 int left = range.start, right = range.end; do { while (arr[left] \u003c mid) ++left; // 檢測基準點左側是否符合要求 while (arr[right] \u003e mid) --right; //檢測基準點右側是否符合要求 if (left \u003c= right) { swap(\u0026arr[left], \u0026arr[right]); left++; right--; // 移動指針以繼續 } } while (left \u003c= right); if (range.start \u003c right) r[p++] = new_Range(range.start, right); if (range.end \u003e left) r[p++] = new_Range(left, range.end); } } 遞歸 void swap(int *x, int *y) { int t = *x; *x = *y; *y = t; } void quick_sort_recursive(int arr[], int start, int end) { if (start \u003e= end) return; int mid = arr[end]; int left = start, right = end - 1; while (left \u003c right) { while (arr[left] \u003c mid \u0026\u0026 left \u003c right) left++; while (arr[right] \u003e= mid \u0026\u0026 left \u003c right) right--; swap(\u0026arr[left], \u0026arr[right]); } if (arr[left] \u003e= arr[end]) swap(\u0026arr[left], \u0026arr[end]); else left++; if (left) quick_sort_recursive(arr, start, left - 1); quick_sort_recursive(arr, left + 1, end); } void quick_sort(int arr[], int len) { quick_sort_recursive(arr, 0, len - 1); } ","date":"2021-05-03","objectID":"/cs_interview_eight_part_questions/:9:5","tags":["互聯網","大廠","面試題","計算機網路","操作系統","Database","數據結構","演算法","MySQL","C","C++","LeetCode","CS","計算機科學","軟件工程"],"title":"互聯網公司大廠 – 面試八股文彙整","uri":"/cs_interview_eight_part_questions/"},{"categories":["Moment"],"content":"二分搜索 重要 在二分搜尋法中，從數列的中間開始搜尋，如果這個數小於我們所搜尋的數，由於數列已排序，則該數左邊的數一定都小於要搜尋的對象，所以無需浪費時間在左邊的數；如果搜尋的數大於所搜尋的對象，則右邊的數無需再搜尋，直接搜尋左邊的數。 所以在二分搜尋法中，將數列不斷的分為兩個部份，每次從分割的部份中取中間數比對，例如要搜尋92於以下的數列，首先中間數索引為(0+9)/2 = 4（索引由0開始）： [3 24 57 57 67 68 83 90 92 95] 由於67小於92，所以轉搜尋右邊的數列： 3 24 57 57 67 [68 83 90 92 95] 由於90小於92，再搜尋右邊的數列，這次就找到所要的數了： 3 24 57 57 67 68 83 90 [92 95] C 的寫法 #include \u003cstdio.h\u003e//recursive binary search int bisearch(int key,int *list,int right,int left) { int middle=(left+right)/2; if(left\u003cright) { if(key==list[middle]) { return middle; } else if(key\u003clist[middle]) { right=middle-1; return bisearch(key,list,right,left); } else { left=middle+1; return bisearch(key,list,right,left); } } return -1; } int main() { int list[10]={5,12,34,56,76,81,99,123,145,168}; int right=9; int left=0; int middle; int key; printf(\"請輸入要搜尋的key:\\n\"); scanf(\"%d\",\u0026key); printf(\"key:%d在第%d個位置\\n\",key,bisearch(key,list,right,left)); } C++ 的寫法 int binary_search(vector\u003cint\u003e \u0026nums, int target) { int left = 0; int right = nums.size() - 1; // array 長度 -1 while (left \u003c= right) { int mid = (left + right) / 2; // 用 int 的性質做無條件捨去 if (nums[mid] \u003e target) { right = mid - 1; } else if (nums[mid] \u003c target) { left = mid + 1; } else { return mid; // 剛好找到 target } } return -1; }int main() { vector\u003cint\u003e nums = {1,3,4,7,8,10}; cout \u003c\u003c binary_search(nums, 0) \u003c\u003c endl; // -1 cout \u003c\u003c binary_search(nums, 1) \u003c\u003c endl; // 0 cout \u003c\u003c binary_search(nums, 3) \u003c\u003c endl; // 1 cout \u003c\u003c binary_search(nums, 4) \u003c\u003c endl; // 2 cout \u003c\u003c binary_search(nums, 5) \u003c\u003c endl; // -1 cout \u003c\u003c binary_search(nums, 7) \u003c\u003c endl; // 3 cout \u003c\u003c binary_search(nums, 8) \u003c\u003c endl; // 4 cout \u003c\u003c binary_search(nums, 10) \u003c\u003c endl; // 5 cout \u003c\u003c binary_search(nums, 11) \u003c\u003c endl; // -1 } ","date":"2021-05-03","objectID":"/cs_interview_eight_part_questions/:9:6","tags":["互聯網","大廠","面試題","計算機網路","操作系統","Database","數據結構","演算法","MySQL","C","C++","LeetCode","CS","計算機科學","軟件工程"],"title":"互聯網公司大廠 – 面試八股文彙整","uri":"/cs_interview_eight_part_questions/"},{"categories":["Moment"],"content":"二叉树DFS/BFS实现（C++） https://blog.csdn.net/usstmiracle/article/details/107021776 深度优先搜索算法（Depth First Search） DFS是搜索算法的一种。它沿着树的深度遍历树的节点，尽可能深的搜索树的分支。当节点v的所有边都己被探寻过，搜索将回溯到发现节点v的那条边的起始节点。这一过程一直进行到已发现从源节点可达的所有节点为止。如果还存在未被发现的节点，则选择其中一个作为源节点并重复以上过程，整个进程反复进行直到所有节点都被访问为止。 如上图所示的二叉树： A 是第一个访问的，然后顺序是 B、D，然后是 E。接着再是 C、F、G。那么，怎么样才能来保证这个访问的顺序呢？ 分析一下，在遍历了根结点后，就开始遍历左子树，最后才是右子树。因此可以借助堆栈的数据结构，由于堆栈是后进先出的顺序，由此可以先将右子树压栈，然后再对左子树压栈，这样一来，左子树结点就存在了栈顶上，因此某结点的左子树能在它的右子树遍历之前被遍历。 广度优先搜索算法（Breadth First Search） 又叫宽度优先搜索，或横向优先搜索。是从根节点开始，沿着树的宽度遍历树的节点。如果所有节点均被访问，则算法中止。 如上图所示的二叉树，A 是第一个访问的，然后顺序是 B、C，然后再是 D、E、F、G。那么，怎样才能来保证这个访问的顺序呢？ 借助队列数据结构，由于队列是先进先出的顺序，因此可以先将左子树入队，然后再将右子树入队。这样一来，左子树结点就存在队头，可以先被访问到。 代码实现： #include\u003ciostream\u003e#include \u003cqueue\u003e#include\u003cstack\u003eusing namespace std; struct Node { int nVal; Node *pLeft; Node *pRight; Node(int val,Node* left=NULL,Node * right=NULL):nVal(val),pLeft(left),pRight(right){}; //构造 }; // 析构 void DestroyTree(Node *pRoot) { if (pRoot==NULL) return; Node* pLeft=pRoot-\u003epLeft; Node* pRight=pRoot-\u003epRight; delete pRoot; pRoot =NULL; DestroyTree(pLeft); DestroyTree(pRight); } // 用queue实现的BFS void BFS(Node *pRoot) { if (pRoot==NULL) return; queue\u003cNode*\u003e Q; Q.push(pRoot); while(!Q.empty()) { Node *node = Q.front(); cout\u003c\u003cnode-\u003enVal\u003c\u003c\"-\u003e\"; if (node-\u003epLeft!=NULL) { Q.push(node-\u003epLeft); } if (node-\u003epRight!=NULL) { Q.push(node-\u003epRight); } Q.pop(); } cout\u003c\u003cendl; } // DFS的递归实现 void DFS_Recursive(Node* pRoot) { if (pRoot==NULL) return; cout\u003c\u003cpRoot-\u003enVal\u003c\u003c\" \"; if (pRoot-\u003epLeft!=NULL) DFS_Recursive(pRoot-\u003epLeft); if (pRoot-\u003epRight!=NULL) DFS_Recursive(pRoot-\u003epRight); } // DFS的迭代实现版本（stack） void DFS_Iterative(Node* pRoot) { if (pRoot==NULL) return; stack\u003cNode*\u003e S; S.push(pRoot); while (!S.empty()) { Node *node=S.top(); cout\u003c\u003cnode-\u003enVal\u003c\u003c\",\"; S.pop(); if (node-\u003epRight!=NULL) { S.push(node-\u003epRight); } if (node-\u003epLeft!=NULL) { S.push(node-\u003epLeft); } } } // 打印树的信息 void PrintTree(Node* pRoot) { if (pRoot==NULL) return; cout\u003c\u003cpRoot-\u003enVal\u003c\u003c\" \"; if (pRoot-\u003epLeft!=NULL) { PrintTree(pRoot-\u003epLeft); } if (pRoot-\u003epRight!=NULL) { PrintTree(pRoot-\u003epRight); } } int main() { Node *node1=new Node(4); Node *node2=new Node(5); Node *node3=new Node(6); Node* node4=new Node(2,node1,node2); Node* node5=new Node(3,node3); Node* node6=new Node(1,node4,node5); Node* pRoot = node6; //PrintTree(pRoot); //DFS_Recursive(pRoot); DFS_Iterative(pRoot); DestroyTree(pRoot); return 0; } ","date":"2021-05-03","objectID":"/cs_interview_eight_part_questions/:9:7","tags":["互聯網","大廠","面試題","計算機網路","操作系統","Database","數據結構","演算法","MySQL","C","C++","LeetCode","CS","計算機科學","軟件工程"],"title":"互聯網公司大廠 – 面試八股文彙整","uri":"/cs_interview_eight_part_questions/"},{"categories":["Moment"],"content":"dijkstra算法求最短路径 https://zhuanlan.zhihu.com/p/40338107 看这个算法的时候，虽然也是看到各种例子，但是对例子的说明，很多博客写的让我一脸懵，真为自己的智商感到着急。接下去我也将用一个例子来说明这个算法，希望初学者看到我的这篇可以更加浅显易懂。 先引用别人的关于该算法的定义，有耐心的可以看看，也可以直接跳到例子。 迪杰斯特拉(Dijkstra)算法是典型最短路径算法，用于计算一个节点到其他节点的最短路径。 它的主要特点是以起始点为中心向外层层扩展(广度优先搜索思想)，直到扩展到终点为止。 基本思想 通过Dijkstra计算图G中的最短路径时，需要指定起点s(即从顶点s开始计算)。 此外，引进两个集合S和U。S的作用是记录已求出最短路径的顶点(以及相应的最短路径长度)，而U则是记录还未求出最短路径的顶点(以及该顶点到起点s的距离)。 初始时，S中只有起点s；U中是除s之外的顶点，并且U中顶点的路径是”起点s到该顶点的路径”。然后，从U中找出路径最短的顶点，并将其加入到S中；接着，更新U中的顶点和顶点对应的路径。 然后，再从U中找出路径最短的顶点，并将其加入到S中；接着，更新U中的顶点和顶点对应的路径。 … 重复该操作，直到遍历完所有顶点。 操作步骤 初始时，S只包含起点s；U包含除s外的其他顶点，且U中顶点的距离为”起点s到该顶点的距离”[例如，U中顶点v的距离为(s,v)的长度，然后s和v不相邻，则v的距离为∞]。 从U中选出”距离最短的顶点k”，并将顶点k加入到S中；同时，从U中移除顶点k。 更新U中各个顶点到起点s的距离。之所以更新U中顶点的距离，是由于上一步中确定了k是求出最短路径的顶点，从而可以利用k来更新其它顶点的距离；例如，(s,v)的距离可能大于(s,k)+(k,v)的距离。 重复步骤(2)和(3)，直到遍历完所有顶点。 单纯的看上面的理论可能比较难以理解，下面通过实例来对该算法进行说明。以D为开头，求D到各个点的最短距离。 第1步：初始化距离，其实指与D直接连接的点的距离。dis[c]代表D到C点的最短距离，因而初始dis[C]=3，dis[E]=4，dis[D]=0，其余为无穷大。设置集合S用来表示已经找到的最短路径。此时，S={D}。现在得到D到各点距离{D(0)，C(3)，E（4），F（），G（），B（），A()}，其中*代表未知数也可以说是无穷大，括号里面的数值代表D点到该点的最短距离。 第2步：不考虑集合S中的值，因为dis[C]=3，是当中距离最短的，所以此时更新S，S={D,C}。接着我们看与C连接的点，分别有B，E，F，已经在集合S中的不看，dis[C-B]=10，因而dis[B]=dis[C]+10=13，dis[F]=dis[C]+dis[C-F]=9，dis[E]=dis[C]+dis[C-E]=3+5=8\u003e4(初始化时的dis[E]=4)不更新。此时{D(0)，C(3)，E（4），F（9），G（），B（13），A()}。 第3步：在第2步中，E点的值4最小，更新S={D，C，E}，此时看与E点直接连接的点，分别有F，G。dis[F]=dis[E]+dis[E-F]=4+2=6（比原来的值小，得到更新），dis[G]=dis[E]+dis[E-G]=4+8=12（更新）。此时{D(0)，C(3)，E（4），F（6），G（12），B（13），A(*)}。 第4步：在第3步中，F点的值6最小，更新S={D，C，E，F}，此时看与F点直接连接的点，分别有B，A，G。dis[B]=dis[F]+dis[F-B]=6+7=13，dis[A]=dis[F]+dis[F-A]=6+16=22，dis[G]=dis[F]+dis[F-G]=6+9=15\u003e12（不更新）。此时{D(0)，C(3)，E（4），F（6），G（12），B（13），A(22)}. 第5步：在第4步中，G点的值12最小，更新S={D，C，E，F，G}，此时看与G点直接连接的点，只有A。dis[A]=dis[G]+dis[G-A]=12+14=26\u003e22(不更新)。{D(0)，C(3)，E（4），F（6），G（12），B（13），A(22)}. 第6步：在第5步中，B点的值13最小，更新S={D，C，E，F，G，B}，此时看与B点直接连接的点，只有A。dis[A]=dis[B]+dis[B-A]=13+12=25\u003e22(不更新)。{D(0)，C(3)，E（4），F（6），G（12），B（13），A(22)}. 第6步：最后只剩下A值，直接进入集合S={D，C，E，F，G，B，A}，此时所有的点都已经遍历结束，得到最终结果{D(0)，C(3)，E（4），F（6），G（12），B（13），A(22)}. ","date":"2021-05-03","objectID":"/cs_interview_eight_part_questions/:9:8","tags":["互聯網","大廠","面試題","計算機網路","操作系統","Database","數據結構","演算法","MySQL","C","C++","LeetCode","CS","計算機科學","軟件工程"],"title":"互聯網公司大廠 – 面試八股文彙整","uri":"/cs_interview_eight_part_questions/"},{"categories":["Moment"],"content":"图的构建 问了几个图存储结构。有邻接矩阵、邻接多重表、邻接表、十字链表等。 ","date":"2021-05-03","objectID":"/cs_interview_eight_part_questions/:9:9","tags":["互聯網","大廠","面試題","計算機網路","操作系統","Database","數據結構","演算法","MySQL","C","C++","LeetCode","CS","計算機科學","軟件工程"],"title":"互聯網公司大廠 – 面試八股文彙整","uri":"/cs_interview_eight_part_questions/"},{"categories":["Moment"],"content":"結語 整理到後面發現根本記不下來全部。(〒︿〒) ","date":"2021-05-03","objectID":"/cs_interview_eight_part_questions/:10:0","tags":["互聯網","大廠","面試題","計算機網路","操作系統","Database","數據結構","演算法","MySQL","C","C++","LeetCode","CS","計算機科學","軟件工程"],"title":"互聯網公司大廠 – 面試八股文彙整","uri":"/cs_interview_eight_part_questions/"},{"categories":["Linux"],"content":"前言 在半年前，因為我的 ArchLinux 發行版系統在某次滾完系統後，我的 Mariadb 數據庫系統崩潰了，無法啟動服務，當時找了一下解決辦法，依然沒解決，網上雖然也有看到有些人也碰到跟我相似的問題，但都沒有具體好的解決辦法，像是 [SOLVED] Unable to start mariadb.service What to Do if MariaDB Doesn’t Start Failed to start MariaDB database server after upgrade to debian 9 今天終於在 ArchLinux-CN Telegram 技術群提問獲得了解決。 ","date":"2021-05-03","objectID":"/archlinux_fail_to_start_mariadb/:1:0","tags":["Database","Mariadb","ArchLinux","Linux"],"title":"Mariadb 啟動服務失敗","uri":"/archlinux_fail_to_start_mariadb/"},{"categories":["Linux"],"content":"問題 我的 Linux 在某次更新完系統開機階段就會顯示我的數據庫啟動失敗，開機後我試著登入數據庫卻登入失敗。於是試著啟動 mariadb.service 於是出現下面的畫面： mariadb.service 啟動失敗systemctl_start_mariadb_service_failed.png \" mariadb.service 啟動失敗 於是我接著查看 mariadb.service 的 status： 檢查 mariadb.service statussystemctl_status_mariadb.png \" 檢查 mariadb.service status 依然沒找到問題所在，於是我進一步查看日誌： $ journalctl -xeu mariadb.service 檢查 mariadb.service 日誌journalctl_xeu_mariadb.png \" 檢查 mariadb.service 日誌 看完日誌我依然沒有解決思路，於是我問了一下 TG ArchLinux-CN 群友。 ","date":"2021-05-03","objectID":"/archlinux_fail_to_start_mariadb/:2:0","tags":["Database","Mariadb","ArchLinux","Linux"],"title":"Mariadb 啟動服務失敗","uri":"/archlinux_fail_to_start_mariadb/"},{"categories":["Linux"],"content":"解決 群友沒有比較好的解決方法，於是建議要不要將數據庫文件刪掉，重新新建新的數據庫，然後我想想數據庫中也沒有比較重要的數據，平常我做完項目也會習慣性將數據庫導出 *.sql 文件，所以接受了這個方案。具體操作如下： # 刪除數據庫 sudo rm -rf /var/lib/mysql # 添加新的數據庫 sudo mariadb-install-db --user=mysql --basedir=/usr --datadir=/var/lib/mysql 然後再次啟動 mariadb.service 就正常了。 數據庫服務啟動成功solute_question_mariadb_status.png \" 數據庫服務啟動成功 ","date":"2021-05-03","objectID":"/archlinux_fail_to_start_mariadb/:3:0","tags":["Database","Mariadb","ArchLinux","Linux"],"title":"Mariadb 啟動服務失敗","uri":"/archlinux_fail_to_start_mariadb/"},{"categories":["Linux"],"content":"結語 記得平常要養成數據庫備份的工作，不然真的會很慘。 ","date":"2021-05-03","objectID":"/archlinux_fail_to_start_mariadb/:4:0","tags":["Database","Mariadb","ArchLinux","Linux"],"title":"Mariadb 啟動服務失敗","uri":"/archlinux_fail_to_start_mariadb/"},{"categories":["Linux"],"content":"Reference MariaDB (简体中文) - ArchWiki ","date":"2021-05-03","objectID":"/archlinux_fail_to_start_mariadb/:5:0","tags":["Database","Mariadb","ArchLinux","Linux"],"title":"Mariadb 啟動服務失敗","uri":"/archlinux_fail_to_start_mariadb/"},{"categories":["MySQL"],"content":"前言 自己經常用資料庫（數據庫），但是語法如果太久沒用都會忘光光，我就在這篇文章當作一個小抄，不然每次碰到 MySQL 語法問題都要 Google 一下語法使用，很麻煩。 ","date":"2020-12-24","objectID":"/mysql_learn_note_basic/:1:0","tags":["MySQL","Database"],"title":"MySQL 的基礎語法使用筆記","uri":"/mysql_learn_note_basic/"},{"categories":["MySQL"],"content":"MySQL 使用工具 我自己是比較偏好使用 MariaDB，因人而異，總之我這篇文章就略過什麼 MySQL 安裝過程，這些都是自己探索安裝一下就可以了。 # 進入 MySQL 指令 # 登入使用者為 root mysql -u root -p ","date":"2020-12-24","objectID":"/mysql_learn_note_basic/:2:0","tags":["MySQL","Database"],"title":"MySQL 的基礎語法使用筆記","uri":"/mysql_learn_note_basic/"},{"categories":["MySQL"],"content":"基礎語法 自行修改中文成英文。不要真的輸入中文當資料庫名稱或資料表名稱喔。 操作功能 MySQL 語法格式 說明 列出所有資料庫 show databases; 建立資料庫 create database 資料庫名稱; 刪除資料庫 drop database 資料庫名稱; 使用資料庫 use 資料庫名稱; 建立資料表 create table 資料表名稱( sn integer auto_increment primary key, name char(20), mail char(50), home char(50), messages char(50) ); 常用資料庫資料型態 1. INT (整數) 2. CHAR (1~255字元字串) 3. VARCHAR (不超過255字元不定長度字串) 4. TEXT (不定長度字串最多65535字元) 列出所有資料表 show tables; 列出資料表欄位資訊 describe 資料表名稱; 修改資料表欄位 alter table 資料表名稱 change column 原來欄位名稱 新欄位名稱資料型態; 新增資料表欄位 alter table 資料表名稱 add column 欄位名稱 資料型態; 刪除資料表欄位 alter table 資料表名稱 drop column 欄位名稱; 刪除資料表 drop table 資料表名稱; 清空資料表 truncate table 資料表名稱; 只清除資料並保留結構、欄位、索引 … 插入欄位資料 insert into 資料表名稱(欄位1,欄位2,欄位3,欄位4, …… 欄位N) values(‘值1’,‘值2’,‘值3’,‘值4’, …… ‘值N’); 更新修改欄位資料 update 資料表名稱 set 欄位1=‘值1’,欄位2=‘值2’,欄位3=‘值3’,… 欄位N=‘值N’ where 條件式 (例如 sn=‘5’ 或 name=‘塔司尼’ ); 查詢單一欄位資料 select 欄位名 from 資料表名稱; 查詢多個欄位資料 select 欄位名, 欄位名, 欄位名 from 資料表名稱; 查詢欄位資料的唯一值 select distinct 欄位名 from 資料表名稱; 重複值只列一次 查詢所有欄位資料 select * from 資料表名稱; 條件式查詢 select * from 資料表名稱 where 條件式 (例如 sn=‘5’); （=, \u003c, \u003e, !=） 條件式查詢 and select * from 資料表名稱 where 條件式1 and 條件式2; 條件式查詢 or select * from 資料表名稱 where 條件式1 or 條件式2; 查詢某一範圍 between select * from 資料表名稱 where 欄位名 between 值1 and 值2; 查詢空值欄位的資料 select * from 資料表名稱 where 欄位名 is null; 相反： not null; 查詢特定筆數資料 select * from 資料表名稱 limit 8, 10; 第9筆開始選取10筆 查詢結果遞增排序 select * from 資料表名稱 order by 欄位名; 查詢結果遞減排序 select * from 資料表名稱 order by 欄位名 desc ; 查詢比對字串列出單一欄位 select 欄位名 from 資料表名稱 where 欄位名 like ‘%字串%'; 查詢比對字串列出所有欄位 select * from 資料表名稱 where 欄位名 like ‘%字串%'; 刪除條件值資料 delete from 資料表名稱 where 條件式 (例如 sn=‘5’ 或 id=‘91001’ ); 刪除條件值資料 delete from 資料表名稱 where 條件式1 and 條件式2; 刪除條件值資料 delete from 資料表名稱 where 條件式1 or 條件式2; 比對刪除條件值資料 delete from 資料表名稱 where 欄位名 like ‘%字串%'; ","date":"2020-12-24","objectID":"/mysql_learn_note_basic/:3:0","tags":["MySQL","Database"],"title":"MySQL 的基礎語法使用筆記","uri":"/mysql_learn_note_basic/"},{"categories":["MySQL"],"content":"匯出資料庫 mysqldump 是個匯出 Database (資料庫) 的指令，也是 IT 人員最常用到的 MySQL 資料庫匯出方法之一。 mysqldump -u root -p 資料庫名稱 \u003e database_name.sql –all-databases: 匯出所有資料庫。 –no-data: 不匯出資料。 –routine: 匯出 stored routines (預存程序) 和自訂函數。 –single-transaction: 該選項從伺服器轉儲數據之前發出一個BEGIN SQL- 句。 –skip-lock-tables: 不鎖定 table (資料表)。 –trigger: 匯出 trigger (觸發器)。 ","date":"2020-12-24","objectID":"/mysql_learn_note_basic/:4:0","tags":["MySQL","Database"],"title":"MySQL 的基礎語法使用筆記","uri":"/mysql_learn_note_basic/"},{"categories":["MySQL"],"content":"匯入資料庫 匯入 *.sql 最簡單的辦法的辦法就是進入 MySQL 建立一個資料庫並使用該資料庫，然後直接加載 *.sql。 進入 MySQL： mysql -u root -p 建立並加載資料表，加載的資料庫位置是在檔案系統中的絕對位置。 mysql\u003ecreatedatabasetest;mysql\u003eusetest;mysql\u003esource/home/user/test.sql; ","date":"2020-12-24","objectID":"/mysql_learn_note_basic/:5:0","tags":["MySQL","Database"],"title":"MySQL 的基礎語法使用筆記","uri":"/mysql_learn_note_basic/"},{"categories":["MySQL"],"content":"新建資料庫使用者 我一般是建議新建一個跟 root 擁有一樣權限的使用者。 mysql\u003eGRANTALLON*.*TO'admin'@'localhost'IDENTIFIEDBY'password'WITHGRANTOPTION;mysql\u003eFLUSHPRIVILEGES;mysql\u003eexit ","date":"2020-12-24","objectID":"/mysql_learn_note_basic/:6:0","tags":["MySQL","Database"],"title":"MySQL 的基礎語法使用筆記","uri":"/mysql_learn_note_basic/"},{"categories":["MySQL"],"content":"Reference MySQL 語法匯整 - 凍仁的筆記 How To Install MariaDB on Ubuntu 18.04 - Digital Ocean ","date":"2020-12-24","objectID":"/mysql_learn_note_basic/:7:0","tags":["MySQL","Database"],"title":"MySQL 的基礎語法使用筆記","uri":"/mysql_learn_note_basic/"},{"categories":["Linux"],"content":"前言 我因為最近在做雲計算實驗中的 Hadoop + Spark，我在我的 Windows 上用 VMware Workstation 開了三個虛擬機，且都裝了 CentOS7 系統。當時因為我下課結束將筆電蓋住，去實驗室將電腦打開的時候，整個 Windows 系統變得很卡，視窗方面無法移動縮放，我只好強制關機重啟筆電，結果一開機啟動虛擬機就出錯了。 ","date":"2020-12-24","objectID":"/vmware_centos_fail_boot_xfs_corruption/:1:0","tags":["VMware","Workstation","CentOS","boot","xfs"],"title":"VMware Workstation Pro 中 CentOS 7 啟動崩潰","uri":"/vmware_centos_fail_boot_xfs_corruption/"},{"categories":["Linux"],"content":"問題 我的三台 CentOS 虛擬機都出現 CentOS 7 Fails to Boot – XFS Corruption – Enters Emergency Mode 這樣的報錯，看起來是 XFS 文件系統出錯了，錯誤畫面如下： CentOS 無法啟動centos_fail_to_boot.jpg \" CentOS 無法啟動 我嘗試了很久想想怎麼修復，爬文看看是哪裡出錯了，終於在一篇文章中找到解決辦法。 ","date":"2020-12-24","objectID":"/vmware_centos_fail_boot_xfs_corruption/:2:0","tags":["VMware","Workstation","CentOS","boot","xfs"],"title":"VMware Workstation Pro 中 CentOS 7 啟動崩潰","uri":"/vmware_centos_fail_boot_xfs_corruption/"},{"categories":["Linux"],"content":"解決 I chose the default boot option and reached a console. Ideally one should create a dump of the damaged partition by running xfs_metadump, restore the dump to an image using xfs_mdrestore, and then perform the repair on that image. That way you can evaluate the repair done to the image to see if it will work or irreversibly damage your actual data. I went ahead and just did the repair on the actual data: xfs_repair -L /dev/mapper/centos-root The repair completed and after a reboot CentOS started successfully. 根據這些內容，於是我在進入的終端裡輸入了修復鏡像指令。 xfs_repair -L /dev/mapper/centos-root 接著我輸入 exit 登出後，重新進入系統，結果成功啟動 CentOS 7虛擬機，進入圖形界面也沒問題。 ","date":"2020-12-24","objectID":"/vmware_centos_fail_boot_xfs_corruption/:3:0","tags":["VMware","Workstation","CentOS","boot","xfs"],"title":"VMware Workstation Pro 中 CentOS 7 啟動崩潰","uri":"/vmware_centos_fail_boot_xfs_corruption/"},{"categories":["Linux"],"content":"衍生問題 經過上面的操作後，雖然能正常啟動 CentOS 了，但是卻導致原本可以連網了 CentOS 虛擬機，現在竟然無法連網…(☉д⊙)，檢查了 VMware 的連網設置，明明設置了 NAT 可以自動連網的呀！？往上一堆奇怪的教學，嘗試了沒用，然後我也不敢直接將物理地址寫死，因為我電腦時常切換網路。 ","date":"2020-12-24","objectID":"/vmware_centos_fail_boot_xfs_corruption/:4:0","tags":["VMware","Workstation","CentOS","boot","xfs"],"title":"VMware Workstation Pro 中 CentOS 7 啟動崩潰","uri":"/vmware_centos_fail_boot_xfs_corruption/"},{"categories":["Linux"],"content":"結語 用虛擬機實在是太不穩了，原本以為解決了啟動問題，為了可能需要將所有實驗重新做一次捏了一把冷汗，最後還是需要新安裝，重新將所有實驗重做一次。我還是 Too Young Too Simple 了。 ","date":"2020-12-24","objectID":"/vmware_centos_fail_boot_xfs_corruption/:5:0","tags":["VMware","Workstation","CentOS","boot","xfs"],"title":"VMware Workstation Pro 中 CentOS 7 啟動崩潰","uri":"/vmware_centos_fail_boot_xfs_corruption/"},{"categories":["Linux"],"content":"Reference CentOS 7 Fails to Boot – XFS Corruption – Enters Emergency Mode - JC-LAN ","date":"2020-12-24","objectID":"/vmware_centos_fail_boot_xfs_corruption/:6:0","tags":["VMware","Workstation","CentOS","boot","xfs"],"title":"VMware Workstation Pro 中 CentOS 7 啟動崩潰","uri":"/vmware_centos_fail_boot_xfs_corruption/"},{"categories":["演算法"],"content":"前言 是個難度適中的題目。 ","date":"2020-12-23","objectID":"/leetcode_add_two_numbers/:1:0","tags":["LeetCode","C"],"title":"LeetCode 題庫 - Add Two Numbers (兩數相加)","uri":"/leetcode_add_two_numbers/"},{"categories":["演算法"],"content":"題目 Add Two Numbers (兩數相加) ","date":"2020-12-23","objectID":"/leetcode_add_two_numbers/:2:0","tags":["LeetCode","C"],"title":"LeetCode 題庫 - Add Two Numbers (兩數相加)","uri":"/leetcode_add_two_numbers/"},{"categories":["演算法"],"content":"題目描述 You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order, and each of their nodes contains a single digit. Add the two numbers and return the sum as a linked list. You may assume the two numbers do not contain any leading zero, except the number 0 itself. 給出兩個非空的鏈表用來表示兩個非負的整數。其中，它們各自的位數是按照逆序的方式存儲的，並且它們的每個節點只能存儲一位數字。 如果，我們將這兩個數相加起來，則會返回一個新的鍊表來表示它們的和。 您可以假設除了數字 0 之外，這兩個數都不會以 0 開頭。 ","date":"2020-12-23","objectID":"/leetcode_add_two_numbers/:3:0","tags":["LeetCode","C"],"title":"LeetCode 題庫 - Add Two Numbers (兩數相加)","uri":"/leetcode_add_two_numbers/"},{"categories":["演算法"],"content":"測資 Example 1： Input: l1 = [2,4,3], l2 = [5,6,4] Output: [7,0,8] Explanation: 342 + 465 = 807. Example 2： Input: l1 = [0], l2 = [0] Output: [0] Example 3： Input: l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9] Output: [8,9,9,9,0,0,0,1] ","date":"2020-12-23","objectID":"/leetcode_add_two_numbers/:4:0","tags":["LeetCode","C"],"title":"LeetCode 題庫 - Add Two Numbers (兩數相加)","uri":"/leetcode_add_two_numbers/"},{"categories":["演算法"],"content":"限制 Constraints: The number of nodes in each linked list is in the range [1, 100]. 0 \u003c= Node.val \u003c= 9 It is guaranteed that the list represents a number that does not have leading zeros. ","date":"2020-12-23","objectID":"/leetcode_add_two_numbers/:5:0","tags":["LeetCode","C"],"title":"LeetCode 題庫 - Add Two Numbers (兩數相加)","uri":"/leetcode_add_two_numbers/"},{"categories":["演算法"],"content":"解題思路 ","date":"2020-12-23","objectID":"/leetcode_add_two_numbers/:6:0","tags":["LeetCode","C"],"title":"LeetCode 題庫 - Add Two Numbers (兩數相加)","uri":"/leetcode_add_two_numbers/"},{"categories":["演算法"],"content":"碰壁與問題 一開始如果你使用將鏈表的單個數字全部轉換成一個完整數字，然後進行相加，在轉換成一個鏈表，這樣會造成 Int 溢出，因為他的節點範圍是 1 ~ 100，所以不能用這個方法。 如果你是要新建第三個的鏈表存結果，然後再將兩者的相加一位一位存到新的鏈表，這樣會很費運行內存，然後考慮的情況變多。 在 C 中我們無法提前知道鏈表的長度。 必須將時間複雜度控制在 O(N)。 ","date":"2020-12-23","objectID":"/leetcode_add_two_numbers/:6:1","tags":["LeetCode","C"],"title":"LeetCode 題庫 - Add Two Numbers (兩數相加)","uri":"/leetcode_add_two_numbers/"},{"categories":["演算法"],"content":"解決 將兩個鏈表上一位一位的相加結果都存到第一個鏈表上，這樣子解決了時間與運行記憶體問題，連帶將需要考慮的情也減少，這樣我們只需要考慮到第一個鏈表的長度不夠，還有相加進位，鏈表的頭節點不為空。 ","date":"2020-12-23","objectID":"/leetcode_add_two_numbers/:6:2","tags":["LeetCode","C"],"title":"LeetCode 題庫 - Add Two Numbers (兩數相加)","uri":"/leetcode_add_two_numbers/"},{"categories":["演算法"],"content":"源碼 我使用 C 語言解決了這題。 /** * Definition for singly-linked list. * struct ListNode { * int val; * struct ListNode *next; * }; */ struct ListNode* addTwoNumbers(struct ListNode* l1, struct ListNode* l2){ struct ListNode *p = l1, *q = l2; int temp = 0; // 進位相加值 // b 加到 a 上 while(p || q) { if (p \u0026\u0026 q) { // p q 都還沒到尾 temp += p-\u003eval + q-\u003eval; q = q-\u003enext; } else if (p \u0026\u0026 !q) { // q 已經到尾 temp += p-\u003eval; } else if (!p \u0026\u0026 q) { // p 已經到尾 temp += q-\u003eval; q = q-\u003enext; } // 將結果寫入 p-\u003eval = temp % 10; temp -= p-\u003eval; temp /= 10; // 如果還有進位值但 p 已經到尾的情況 // 如果p 已經到尾部 但是 q 還沒到尾部的情況 if (!p-\u003enext \u0026\u0026 (temp != 0 || q)) { struct ListNode *s = (struct ListNode *)malloc(sizeof(struct ListNode)); s-\u003eval = 0; s-\u003enext = NULL; p-\u003enext = s; //printf(\"temp %d ,p %d\\n\", temp, p != NULL); } p = p-\u003enext; } return l1; } ","date":"2020-12-23","objectID":"/leetcode_add_two_numbers/:7:0","tags":["LeetCode","C"],"title":"LeetCode 題庫 - Add Two Numbers (兩數相加)","uri":"/leetcode_add_two_numbers/"},{"categories":["演算法"],"content":"結語 解這題的前提是需要理解鏈表的概念，其次我自己在本地寫輸入測資時寫得很麻煩，因為 LeetCode 上的編輯器沒有給 main 函數，也無法 Debug（貌似要充錢）。 ","date":"2020-12-23","objectID":"/leetcode_add_two_numbers/:8:0","tags":["LeetCode","C"],"title":"LeetCode 題庫 - Add Two Numbers (兩數相加)","uri":"/leetcode_add_two_numbers/"},{"categories":["演算法"],"content":"前言 最近刷到的簡單題庫題。 ","date":"2020-12-23","objectID":"/leetcode_two_sum/:1:0","tags":["LeetCode","C"],"title":"LeetCode 題庫 - Two Sum (兩數之和)","uri":"/leetcode_two_sum/"},{"categories":["演算法"],"content":"題目 Two Sum (兩數之和) ","date":"2020-12-23","objectID":"/leetcode_two_sum/:2:0","tags":["LeetCode","C"],"title":"LeetCode 題庫 - Two Sum (兩數之和)","uri":"/leetcode_two_sum/"},{"categories":["演算法"],"content":"題目描述 Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target. You may assume that each input would have exactly one solution, and you may not use the same element twice. You can return the answer in any order. 給定一個整數數組 nums 和一個目標值 target，請你在該數組中找出和為目標值的那 兩個 整數，並返回他們的數組下標。 你可以假設每種輸入只會對應一個答案。但是，數組中同一個元素不能使用兩遍。 ","date":"2020-12-23","objectID":"/leetcode_two_sum/:3:0","tags":["LeetCode","C"],"title":"LeetCode 題庫 - Two Sum (兩數之和)","uri":"/leetcode_two_sum/"},{"categories":["演算法"],"content":"測資 Example 1： Input: nums = [2,7,11,15], target = 9 Output: [0,1] Output: Because nums[0] + nums[1] == 9, we return [0, 1]. Example 2： Input: nums = [3,2,4], target = 6 Output: [1,2] Example 3： Input: nums = [3,3], target = 6 Output: [0,1] ","date":"2020-12-23","objectID":"/leetcode_two_sum/:4:0","tags":["LeetCode","C"],"title":"LeetCode 題庫 - Two Sum (兩數之和)","uri":"/leetcode_two_sum/"},{"categories":["演算法"],"content":"限制 2 \u003c= nums.length \u003c= 103 -109 \u003c= nums[i] \u003c= 109 -109 \u003c= target \u003c= 109 Only one valid answer exists. ","date":"2020-12-23","objectID":"/leetcode_two_sum/:5:0","tags":["LeetCode","C"],"title":"LeetCode 題庫 - Two Sum (兩數之和)","uri":"/leetcode_two_sum/"},{"categories":["演算法"],"content":"解題思路 就使用暴力解就行了，遍歷整個陣列。 ","date":"2020-12-23","objectID":"/leetcode_two_sum/:6:0","tags":["LeetCode","C"],"title":"LeetCode 題庫 - Two Sum (兩數之和)","uri":"/leetcode_two_sum/"},{"categories":["演算法"],"content":"源碼 我使用 C 語言寫的。裡面比較需要注意的是要自己聲明新的返回指針，returnSize 只需要保持 2 就好。 /** * Note: The returned array must be malloced, assume caller calls free(). */ int* twoSum(int* nums, int numsSize, int target, int* returnSize){ int flag = 0; // 判斷是否配對成功 int *returnN = (int *)malloc(sizeof(int)*2); for(int i = 0; i \u003c numsSize; i++) { for(int j = i + 1; j \u003c numsSize; j++) { if(nums[i] + nums[j] == target) { returnN[0] = i; returnN[1] = j; flag = 1; break; } } if(flag == 1) { break; } } *returnSize = 2; //printf(\"%d %d\", returnSize[0], returnSize[1]); return returnN; } ","date":"2020-12-23","objectID":"/leetcode_two_sum/:7:0","tags":["LeetCode","C"],"title":"LeetCode 題庫 - Two Sum (兩數之和)","uri":"/leetcode_two_sum/"},{"categories":["演算法"],"content":"結語 送分題。 ","date":"2020-12-23","objectID":"/leetcode_two_sum/:8:0","tags":["LeetCode","C"],"title":"LeetCode 題庫 - Two Sum (兩數之和)","uri":"/leetcode_two_sum/"},{"categories":["Linux"],"content":"前言 有些新手不知道怎麼使用 SSH 連接服務器時不需要輸密碼，特此寫一下。 ","date":"2020-12-22","objectID":"/ssh_no_password_connection/:1:0","tags":["SSH","Server"],"title":"SSH 免密訪問服務器端","uri":"/ssh_no_password_connection/"},{"categories":["Linux"],"content":"SSH ","date":"2020-12-22","objectID":"/ssh_no_password_connection/:2:0","tags":["SSH","Server"],"title":"SSH 免密訪問服務器端","uri":"/ssh_no_password_connection/"},{"categories":["Linux"],"content":"前置工作 為了避免麻煩每次用 SSH 連的時候都要輸入 IP，可以在各自域名解析中添加服務器的 IP 給予命名映射。 兩台服務器都編輯 /etc/hosts 文件，添加以下內容，假設各自的公網 IP 是 10.10.15.xx1、10.10.15.xx2。 10.10.15.xx1 Server1 10.10.15.xx2 Server2 這樣子我們在服務器上連接另一個服務器時只需要輸入 ssh Server1、ssh Server2。 ","date":"2020-12-22","objectID":"/ssh_no_password_connection/:2:1","tags":["SSH","Server"],"title":"SSH 免密訪問服務器端","uri":"/ssh_no_password_connection/"},{"categories":["Linux"],"content":"生成密鑰 我們假設有兩台服務器需要互相無密連接，這裡需要生成公鑰和私鑰，然後主機使用者之間共享公鑰。 如果是自己的本地電腦不需要輸入密碼連上服務器端，作法大同小異，把自己的電腦當作一台服務器即可。 先在本地生成密鑰，兩台服務器上都各自輸入下面指令，過程中如果有需要你輸入什麼，只需要一直輸入 Enter 就好了。 ssh-keygen -t rsa # 當前使用者生成密鑰 如果你當前是普通使用者就會在 /home/user/.ssh/ 目錄下找到 id_rsa.pub 公鑰。如果是 root 使用者，會在 /root/.ssh/ 目錄裡找到。 ","date":"2020-12-22","objectID":"/ssh_no_password_connection/:2:2","tags":["SSH","Server"],"title":"SSH 免密訪問服務器端","uri":"/ssh_no_password_connection/"},{"categories":["Linux"],"content":"互相共享公鑰 我們先將服務器一的公鑰文件傳給服務器二。 scp /root/.ssh/id_rsa.pub root@Server2:/root/.ssh/id_rsa.pub.Server1 接著在服務器二上面將雙方公鑰合成一個授權驗證文件。 註：關於 chmod 的權限設置數字計算，可以參考菜鳥教學的文章。 ssh Server2 cd /root/.ssh # 將自己的公鑰加入 cat id_rsa.pub \u003e\u003e authorized_keys # 將另一個服務器的公鑰加入 cat id_rsa.pub.Server1 \u003e\u003e authorized_keys # 給予權限 chmod 644 authorized_keys #(important!!!) # 將公鑰文件傳回另一個服務器 scp ~/.ssh/authorized_keys root@Server1:/root/.ssh/authorized_keys 然後再試試用 SSH 連接就不需要輸入密碼了。 ","date":"2020-12-22","objectID":"/ssh_no_password_connection/:2:3","tags":["SSH","Server"],"title":"SSH 免密訪問服務器端","uri":"/ssh_no_password_connection/"},{"categories":["Linux"],"content":"前言 由於這學期我選修了軟件測試的課程，我們以十人小組為單位，對我在暑假實訓所參與的 MD-Blog 個人空間系統項目進行 Web 測試，過程中我將那個項目部署到了阿里雲的雲服務器上。這篇文章我紀錄一下我部署 Web 的過程。 ","date":"2020-12-21","objectID":"/deploy_springboot_flask_vue_web/:1:0","tags":["Vue","Vue-cli","Server","Web","npm","SpringBoot","Linux","Java","JDK","Maven","IntelliJ","IDEA","Jar","Nginx","Python","Flask"],"title":"部署 SpringBoot、Flask 與 Vue 前端與雙後端完全分離 Web 項目","uri":"/deploy_springboot_flask_vue_web/"},{"categories":["Linux"],"content":"購買服務器 因為我是用學生優惠等方式白嫖到了半年的阿里雲雲服務器，所以這方面其實沒怎麼出錢，幸好在軟件測試項目結題才到期，不過用學生優惠購買最低配的雲服務器，三個月也只需要 28 元人民幣，騰訊雲我因為過不了實名認證就算了（…這裡我要吐嘈一下連雲服務器都要實名認證）。 總之購買好雲服務器後新增好實例，通常我是建議使用 CentOS7 作為服務器的操作系統，進入雲服務器的控制台，你會看到服務器的公網 IP、私網 IP 和密碼，密碼可以重新修改。 這裡我們假設我們服務器的公網 IP 是 1.2.3.4。 ","date":"2020-12-21","objectID":"/deploy_springboot_flask_vue_web/:2:0","tags":["Vue","Vue-cli","Server","Web","npm","SpringBoot","Linux","Java","JDK","Maven","IntelliJ","IDEA","Jar","Nginx","Python","Flask"],"title":"部署 SpringBoot、Flask 與 Vue 前端與雙後端完全分離 Web 項目","uri":"/deploy_springboot_flask_vue_web/"},{"categories":["Linux"],"content":"部署項目前的工作 ","date":"2020-12-21","objectID":"/deploy_springboot_flask_vue_web/:3:0","tags":["Vue","Vue-cli","Server","Web","npm","SpringBoot","Linux","Java","JDK","Maven","IntelliJ","IDEA","Jar","Nginx","Python","Flask"],"title":"部署 SpringBoot、Flask 與 Vue 前端與雙後端完全分離 Web 項目","uri":"/deploy_springboot_flask_vue_web/"},{"categories":["Linux"],"content":"安裝環境 在配置之前我們需要將我們的 JDK、Python、MySQL、Nginx 在服務器端配置完畢。 JDK 注意：服務器安裝的 JDK 環境必須跟你的打包時使用的 JDK 版本一致，不然在運行後端 JAR 包時會報版本錯誤及不兼容的問題，要選擇 JDK1.8 以上的版本。 這裡是建議自己在本地下載好 JDK 然後 SCP 上傳至服務器端，選擇 Linux x64 Compressed Archive 下載，不要下錯成 Linux ARM 架構的（因為我下錯過，沒仔細看名稱），壓縮包名大致為 jdk-8u271-linux-x64.tar.gz。 在用 SCP 上傳前要先進入服務器新增好資料夾，如果 SCP 上傳時指定到不存在的資料夾時，不會自動幫你新建一個新的資料夾。 ssh root@1.2.3.4 # 使用 ssh 連上服務器 cd /home # 進入家目錄 mkdir jdk # 新建 jdk 資料夾 exit # 退出 ssh # scp 上傳 scp ./jdk-8u271-linux-x64.tar.gz root@1.2.3.4:/home/jdk/jdk1.8.tar.gz ssh root@1.2.3.4 # 使用 ssh 連上服務器 cd /home/jdk tar -zxvf jdk1.8.tar.gz # 解壓縮 接著你就會看到目錄新增一個 JDK 目錄。下一步我們編輯環境變量： vi /etc/profile 加入以下內容： 自行修改目錄名，保持目錄名一致正確。 # jdk export JAVA_HOME=/home/jdk/jdk1.8.0_271 export JAVA_JRE=/home/jdk/jdk1.8.0_271/jre source /etc/profile java -version # 查看版本 Python 有些服務器默認只有 Python2，但是我們項目需要用到的是 Python3，我在這裡說一下怎麼讓 CentOS7 系統默認使用 Python3，不管系統是 Ubuntu 還是 CentOS 步驟都一樣，只差在安裝 Python3 的方法， python -V # 先查看 Python 版本 ls -al /usr/bin/python # 查看指向 yum update -y # 先更新環境 yum install python3 # 安裝 python3 python3 # 輸入 python3 驗證已經安裝好 # 會輸出以下信息表示已經安裝 python3 成功 Python 3.6.8 (default, Nov 16 2020, 16:55:22) [GCC 4.8.5 20150623 (Red Hat 4.8.5-44)] on linux Type \"help\", \"copyright\", \"credits\" or \"license\" for more information. \u003e\u003e\u003e 接下來將系統預設的 Python2.7 改成 Python3.6。 # 重新命名備份 mv /usr/bin/python /usr/bin/python2.7.5 # 編輯 yum 避免連接指向錯誤 vi /usr/bin/yum 把頭部的 #!/usr/bin/python 改成 #!/usr/bin/python2.7.5 保存退出。然後重新建立新的連結： rm -rf /usr/bin/python rm -rf /usr/bin/py # 複製並重新命名 mv /usr/bin/python3.6 /usr/bin/python 接下來如果輸入 python 就會看到預設的 Python 是 3.6.8 版本。 MySQL 我比較偏好使用 MariaDB，這是 MySQL 的加強版。主要是 root 的密碼可以是空白。 # Installing MariaDB Server 10.4 sudo yum install wget wget https://downloads.mariadb.com/MariaDB/mariadb_repo_setup chmod +x mariadb_repo_setup sudo ./mariadb_repo_setup sudo yum install MariaDB-server sudo systemctl start mariadb.service sudo mysql_secure_installation # 會要求你設置 root 密碼 在數據庫方面，我們經常遇到的錯誤是會使用 root 去登入數據庫，常常碰到登不進去的問題，怎麼修改 root 密碼也沒辦法。 這裡有個很好的解決方法，就是新增一個一樣擁有 root 權限的使用者，並使用該使用者登入數據庫就沒問題了。所以我每次都是使用這方法解決，推薦。 進入 MySQL： mysql 新增一個使用者為 admin，密碼為 password，並擁有所有權限： 可自行修改，不需要跟我一模一樣。 MariaDB[(none)]\u003eGRANTALLON*.*TO'admin'@'localhost'IDENTIFIEDBY'password'WITHGRANTOPTION; 刷新權限： MariaDB[(none)]\u003eFLUSHPRIVILEGES; 退出： MariaDB[(none)]\u003eexit; Nginx 安裝 Nginx： yum install nginx 我們確認一下 Nginx 是否能正常運行，Nginx 預設的監聽端口是 80。 # 輸入以下指令運行 Nginx nginx 接下來在自己的瀏覽器上輸入 1.2.3.4 公網 IP，就會自動跳轉顯示 Nginx 啟動成功畫面。前提是你已將服務器的 80 端口在防火牆打開了。 nginx # 運行 nginx nginx -t # 試配置文件是否有語法錯誤 nginx -s reopen # 重啟 Nginx nginx -s reload # 重新加載 Nginx 配置文件，然後以優雅方式重啟 Nginx nginx -s stop # 强制停止 Nginx 服務 nginx -s quit # 優雅地停止 Nginx 服务（即處理完所有請求後再停止服務） ","date":"2020-12-21","objectID":"/deploy_springboot_flask_vue_web/:3:1","tags":["Vue","Vue-cli","Server","Web","npm","SpringBoot","Linux","Java","JDK","Maven","IntelliJ","IDEA","Jar","Nginx","Python","Flask"],"title":"部署 SpringBoot、Flask 與 Vue 前端與雙後端完全分離 Web 項目","uri":"/deploy_springboot_flask_vue_web/"},{"categories":["Linux"],"content":"新增項目目錄 我們預先將要部署的項目目錄新建好： cd /home mkdir sxblog cd sxblog mkdir java python sql vue ","date":"2020-12-21","objectID":"/deploy_springboot_flask_vue_web/:3:2","tags":["Vue","Vue-cli","Server","Web","npm","SpringBoot","Linux","Java","JDK","Maven","IntelliJ","IDEA","Jar","Nginx","Python","Flask"],"title":"部署 SpringBoot、Flask 與 Vue 前端與雙後端完全分離 Web 項目","uri":"/deploy_springboot_flask_vue_web/"},{"categories":["Linux"],"content":"開端口 我直接將系統的 firewalld disable 掉。 因為服務器會有防火牆這些功能，要到服務器控制台的安全組的安全規則設置或是防火牆將進方向和出方向需要用到的後端端口與前端端口都打開，不然外部訪問不了服務器，阿里雲的服務器有點奇妙的是無法一次將所有的端口打開，騰訊雲卻可以。 我使用的 Port 有 8090（SpringBoot）、5000（Flask）、80（Nginx 前端靜態文件代理）。 ","date":"2020-12-21","objectID":"/deploy_springboot_flask_vue_web/:3:3","tags":["Vue","Vue-cli","Server","Web","npm","SpringBoot","Linux","Java","JDK","Maven","IntelliJ","IDEA","Jar","Nginx","Python","Flask"],"title":"部署 SpringBoot、Flask 與 Vue 前端與雙後端完全分離 Web 項目","uri":"/deploy_springboot_flask_vue_web/"},{"categories":["Linux"],"content":"配置數據庫 將你項目使用的數據庫導出 *.sql 文件，並使用 SCP 上傳至雲服務器上。 修改一下自己要上傳的數據庫文件名稱，這裡假設我的數據庫文件是 sxblog.sql # 用 root 登入服務器端 scp ./sxblog.sql root@1.2.3.4:/home/sxblog/sql/sxblog.sql 接著將該數據庫文件導入數據庫系統： # 連上服務器 ssh root@1.2.3.4 # 使用文章上面我新增的使用者 mysql -u admin -p MariaDB[(none)]\u003ecreatedatabasesxblog;MariaDB[(none)]\u003eusesxblog;MariaDB[(sxblog)]\u003esource/home/sxblog/sql/sxblog.sql; ","date":"2020-12-21","objectID":"/deploy_springboot_flask_vue_web/:4:0","tags":["Vue","Vue-cli","Server","Web","npm","SpringBoot","Linux","Java","JDK","Maven","IntelliJ","IDEA","Jar","Nginx","Python","Flask"],"title":"部署 SpringBoot、Flask 與 Vue 前端與雙後端完全分離 Web 項目","uri":"/deploy_springboot_flask_vue_web/"},{"categories":["Linux"],"content":"後端部署 ","date":"2020-12-21","objectID":"/deploy_springboot_flask_vue_web/:5:0","tags":["Vue","Vue-cli","Server","Web","npm","SpringBoot","Linux","Java","JDK","Maven","IntelliJ","IDEA","Jar","Nginx","Python","Flask"],"title":"部署 SpringBoot、Flask 與 Vue 前端與雙後端完全分離 Web 項目","uri":"/deploy_springboot_flask_vue_web/"},{"categories":["Linux"],"content":"Spring Boot打包 修改配置文件 再打包後端 SpringBoot 項目前，你需要先修改自己項目的配制文件。在 SpringBoot 項目目錄中，要確認依賴是否是固定的版本，然後確認是否有加入 Maven 依賴： 使用 JAR 包啟動 Web 後端應用並不需要在服務器上配置 Tomcat 容器環境，因為 SpringBoot 有內置 Tomcat 運行，但是要確保你的 JDK 版本是 1.8 以上，還有與服務器上的 JDK 版本一致。 \u003c!--將應用打包成可以運行的 JAR 包--\u003e \u003cbuild\u003e \u003cplugins\u003e \u003cplugin\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-maven-plugin\u003cartifactId\u003e \u003c/plugin\u003e \u003c/plugins\u003e \u003c/build\u003e 然後調整項目的配置參數：將數據庫的連接使用者改成是服務器上數據庫的使用者（像我前面新鄒的是 admin），數據庫密碼也要變，預設的後端運行端口只要不跟其他後端衝突就不用改，我這次的 SpringBoot 是 8090 端口，所以我在服務器的控制台安全組部份允許 8090 端口訪問。 在有 pom.xml 的目錄下執行 Maven 的指令： maven clean # 清理 maven package # 打包 接下來就會看到目錄下出現了一個 target 資料夾，裡面是打包成 Jar 包的目錄，進入該目錄並在本地運行試試： # 這裡的 xxxx 需要改成你實際打包出來的包名 java -jar xxxx.jar 進入瀏覽器輸入運行的 IP 和 Port 就知道有沒有問題，如果運行過程有報錯，可能是打包失敗，需要查看自己的源碼哪裡寫錯了。 部署到服務器 確認都沒問題了之後我們就可以部署到服務器上了。 將整個 target 資料夾 SCP 上傳到服務器端。 scp -r ./target root@1.2.3.4:/home/sxblog/java/target 進入服務器端運行 Jar 包，使用 nohup 讓該進程在我們退出連結後依然能在後台運行，\u003etemp.txt 是可以指定我們的日誌輸出文件。如果沒有 nohup 就安裝一下。 ssh root@1.2.3.4 # 進入 target/ 使用 nohup 運行 JAR nohup java -jar xxxx.jar \u003etemp.txt \u0026 ","date":"2020-12-21","objectID":"/deploy_springboot_flask_vue_web/:5:1","tags":["Vue","Vue-cli","Server","Web","npm","SpringBoot","Linux","Java","JDK","Maven","IntelliJ","IDEA","Jar","Nginx","Python","Flask"],"title":"部署 SpringBoot、Flask 與 Vue 前端與雙後端完全分離 Web 項目","uri":"/deploy_springboot_flask_vue_web/"},{"categories":["Linux"],"content":"Flask 記得如果你項目需要用到一些 Python 的包，需要自己用 pip 下載好，像是 flask 和 flask_cors。 關於 Flask 就相對 SpringBoot 的部署簡單很多，不需要經過打包，只需要確認服務器上有穩定的 Python3 版本。我們先將我們的 Flask 源碼目錄 SCP 上傳到雲服務器： scp -r ./flask root@1.2.3.4:/home/sxblog/python/flask 接下來進入服務器，改一下 Flask 的運行 IP 和端口，將運行的改成： if __name__ == '__main__': app.run(host='0.0.0.0',port=5000,debug=True) 接著後台運行 Flask： nohup python ./flaskApi.py \u003e temp.txt \u0026 如果你的 Flask 應用沒有寫 main 函數，需要自己在運行指令那裡指定： export FLASK_APP=flaskApi.py nohup flask run -h 0.0.0.0 -p 5000 \u003e temp.txt \u0026 最後還是提醒要去雲服務器控制台將 5000 端口打開。 ","date":"2020-12-21","objectID":"/deploy_springboot_flask_vue_web/:5:2","tags":["Vue","Vue-cli","Server","Web","npm","SpringBoot","Linux","Java","JDK","Maven","IntelliJ","IDEA","Jar","Nginx","Python","Flask"],"title":"部署 SpringBoot、Flask 與 Vue 前端與雙後端完全分離 Web 項目","uri":"/deploy_springboot_flask_vue_web/"},{"categories":["Linux"],"content":"前端部署 開始前我要提醒一下，不要想在服務器上配置 NodeJS 環境，然後將 Vue 源碼放到服務器上使用 npm 去代理運行，這想法是非常蠢的事，因為這作法會耗盡服務器的資源，但沒關係，每個初學者可能會遇到這件事，代表你有去思考如何部署前端。 ","date":"2020-12-21","objectID":"/deploy_springboot_flask_vue_web/:6:0","tags":["Vue","Vue-cli","Server","Web","npm","SpringBoot","Linux","Java","JDK","Maven","IntelliJ","IDEA","Jar","Nginx","Python","Flask"],"title":"部署 SpringBoot、Flask 與 Vue 前端與雙後端完全分離 Web 項目","uri":"/deploy_springboot_flask_vue_web/"},{"categories":["Linux"],"content":"修改請求 IP 前端向後端請求的 IP 要修改成服務器上的公網 IP，這裡非常重要，所以自己平時在寫前端時就應該養成習慣將請求接口全面的管理，像我就是使用 vueX 去管理，擷取部份如下： // api.js const api = { state: { // spring flask base url springBaseURL: \"http://127.0.0.1:8090\", flaskBaseURL: \"http://127.0.0.1:5000\", // account signIn signUp signInURL: \"/user/signIn\", signUpURL: \"/user/signUp\", // check the username if it is exist usernameVerifyURL: \"/user/username_verify\", verifyEmailURL: \"/user/email_verify\", forgotPasswordURL: \"/user/find_passwd\", // account setting getUserDataURL: \"/user/get_data\", updateUserUrl: '/user/change_data', updateUsernameURL: \"/user/change_data\", updateEmailURL: \"/user/change_data\", // ... // tags addNewTagURL: \"/insertTag\", deleteTagURL: \"/deleteTag\", // comment getCommentByBlogIdURL: \"/getCommentListByBlog\", addNewCommentURL: \"/insertComment\", // news getSchoolNewsURL: \"/getNews\", getGamesNewsURL: \"/getEpicFreeGame\" }, mutations: { }, actions: {}, getters: {} } export default api; 於是我只需要修改上面那兩個參數即可，改成 springBaseURL: \"http://1.2.3.4:8090\"、flaskBaseURL: \"http://1.2.3.4:5000\"，至於為什麼要修改成公網 IP 而不是私網或是 127.0.0.1、0.0.0.0 之類的，這是因為你的前端網頁相當於將靜態文件傳到瀏覽器給使用者瀏覽你的網頁，與你的服務器是分開的，如果要請求數據就等同於從外部訪問服務器內部，所以必須使用公網 IP。 ","date":"2020-12-21","objectID":"/deploy_springboot_flask_vue_web/:6:1","tags":["Vue","Vue-cli","Server","Web","npm","SpringBoot","Linux","Java","JDK","Maven","IntelliJ","IDEA","Jar","Nginx","Python","Flask"],"title":"部署 SpringBoot、Flask 與 Vue 前端與雙後端完全分離 Web 項目","uri":"/deploy_springboot_flask_vue_web/"},{"categories":["Linux"],"content":"前端打包 在前端的項目目錄執行 npm run build 就可以將整個項目打包成靜態文件，並存於項目目錄的 ./dist 資料夾。 npm run build # 前端打包指令 打包結束後將打包好的靜態文件使用 VScode 的一個 Live Server 的 Plugin，使用該 Live Server 對 dist 根目錄的 index.html 進行代理，並在瀏覽器上測試前端是否可以向服務器上的後端進行請求回應，如果沒有問題，就代表 ./dist 資料夾可以 SCP 上傳至服務器上了。 # 上傳至服務器 scp -r ./dist root@1.2.3.4:/home/sxblog/vue/dist ","date":"2020-12-21","objectID":"/deploy_springboot_flask_vue_web/:6:2","tags":["Vue","Vue-cli","Server","Web","npm","SpringBoot","Linux","Java","JDK","Maven","IntelliJ","IDEA","Jar","Nginx","Python","Flask"],"title":"部署 SpringBoot、Flask 與 Vue 前端與雙後端完全分離 Web 項目","uri":"/deploy_springboot_flask_vue_web/"},{"categories":["Linux"],"content":"使用 Nginx 代理 接下來我們要使用 Nginx 對前端靜態文件進行代理，我們先編輯 /etc/nginx/nginx.conf vi /etc/nginx/nginx.conf 編輯成如下： 以下有些參數需要自己修改，像是 公網 IP、靜態文件路徑配置。 user root; # 用戶 worker_processes auto; error_log /www/wwwlogs/nginx_error.log crit; pid /www/server/nginx/logs/nginx.pid; worker_rlimit_nofile 51200; events { use epoll; worker_connections 51200; multi_accept on; } http { include mime.types; # include luawaf.conf; include proxy.conf; default_type application/octet-stream; server_names_hash_bucket_size 512; client_header_buffer_size 32k; large_client_header_buffers 4 32k; client_max_body_size 50m; sendfile on; tcp_nopush on; keepalive_timeout 60; tcp_nodelay on; fastcgi_connect_timeout 300; fastcgi_send_timeout 300; fastcgi_read_timeout 300; fastcgi_buffer_size 64k; fastcgi_buffers 4 64k; fastcgi_busy_buffers_size 128k; fastcgi_temp_file_write_size 256k; fastcgi_intercept_errors on; gzip on; gzip_min_length 1k; gzip_buffers 4 16k; gzip_http_version 1.1; gzip_comp_level 2; gzip_types text/plain application/javascriptapplication/x-javascript text/javascript text/cssapplication/xml; gzip_vary on; gzip_proxied expired no-cache no-store private auth; gzip_disable \"MSIE [1-6]\\.\"; limit_conn_zone $binary_remote_addr zone=perip:10m; limit_conn_zone $server_name zone=perserver:10m; server_tokens off; # 訪問日誌配置在這 # 自定義名為 main 的日誌格式 log_format main '$remote_addr - $remote_user [$time_local] \"$request\"' '$status $body_bytes_sent \"$http_referer\" ' '\"$http_user_agent\" \"$http_x_forwarded_for\"'; access_log /www/wwwlogs/access.log main; # 這裡是具體路徑 # 這裡是我們需要注意的東西，也是配置主要需要修改的東西 server { # 修改此處，ip 要是公網 ip # 我們訪問 119.29.143.49：80 listen 80; # 端口 server_name 119.29.143.49; # 服務器名， 要代理的服務器的名字 # 此處修改靜態文件路徑 # 存放静態資源的文件路徑 root /home/sxblog/vue/dist; # ngix的配置文件 include /www/nginx/conf/*.conf; location / { } error_page 404 /404.html; location = /40x.html { } error_page 500 502 503 504 /50x.html; location = /50x.html { } # 如果 vue-router 是 history 模式，加上下面這段 # vue-router 配置 location / { try_files $uri $uri/ @router; index index.html; } location @router { rewrite ^.*$ /index.html last; } } include /www/server/panel/vhost/nginx/*.conf; } 值得注意的是這配置文件尾部是 vue-router 的配置： # vue-router 配置 location / { try_files $uri $uri/ @router; index index.html; } location @router { rewrite ^.*$ /index.html last; } 這是因為 Vue-router 默認的模式是 hash，而我在寫前端時設定的模式是 history 模式，如果沒加上上面那段，刷新頁面就會跳轉到 404，因為會包含到 #。 最後運行： nohup nginx \u0026 這樣就搭建好一個 Web 項目了。 (〃∀〃) ","date":"2020-12-21","objectID":"/deploy_springboot_flask_vue_web/:6:3","tags":["Vue","Vue-cli","Server","Web","npm","SpringBoot","Linux","Java","JDK","Maven","IntelliJ","IDEA","Jar","Nginx","Python","Flask"],"title":"部署 SpringBoot、Flask 與 Vue 前端與雙後端完全分離 Web 項目","uri":"/deploy_springboot_flask_vue_web/"},{"categories":["Linux"],"content":"結語 各位記得要實際去操作才能有經驗上的成長，如果只是看看我的這篇文章就以為自己懂了如何部署，這樣是根本不會部署的，所謂實踐出真知，就是這樣的道理。 ","date":"2020-12-21","objectID":"/deploy_springboot_flask_vue_web/:7:0","tags":["Vue","Vue-cli","Server","Web","npm","SpringBoot","Linux","Java","JDK","Maven","IntelliJ","IDEA","Jar","Nginx","Python","Flask"],"title":"部署 SpringBoot、Flask 與 Vue 前端與雙後端完全分離 Web 項目","uri":"/deploy_springboot_flask_vue_web/"},{"categories":["Linux"],"content":"Reference SpringBoot 项目部署到服务器的两种方式 - CSDN Linux Centos7 升级python2至python3 - 知乎 How to Install Python 3 on CentOS 7 指定端口启动Flask - CSDN Nginx命令大全 - CSDN 手把手教 Nginx 部署 Vue 项目 - 掘金 简单前后端分离项目部署 - HackMD How To Install MariaDB on Ubuntu 18.04 - Digital Ocean ","date":"2020-12-21","objectID":"/deploy_springboot_flask_vue_web/:8:0","tags":["Vue","Vue-cli","Server","Web","npm","SpringBoot","Linux","Java","JDK","Maven","IntelliJ","IDEA","Jar","Nginx","Python","Flask"],"title":"部署 SpringBoot、Flask 與 Vue 前端與雙後端完全分離 Web 項目","uri":"/deploy_springboot_flask_vue_web/"},{"categories":["C/C++"],"content":"前言 大一自己寫 C++ 時碰到的問題，一直沒發表文章，現在趁有空寫一下。 ","date":"2020-08-07","objectID":"/about_cpp_class_virtual_function/:1:0","tags":["C++","Class","Virtual","Function","虛函數","純虛函數","繼承"],"title":"C++ - 關於多態中的虛函數與純虛函數","uri":"/about_cpp_class_virtual_function/"},{"categories":["C/C++"],"content":"多態與虛函數 P.S. 大陸叫對象，台灣叫物件。 我的理解是多態就是一個類（class）演伸出多種物件（Object），父類相當於模板藍圖的功能。虛函數是用來子類繼承後能夠複寫的函數。 我們先看一下虛函數嘴臉長怎樣： 在下面的例子中是一個 Base Class（基類、父類），如果函數前面宣告有添加 virtual 就是虛函數。 class Shape { public: virtual string toString() const; virtual double getArea() const; } 下面是一個 Circle 子類（superclass）（超生類、派生類），引入 Circle 的 getArea() 和 toString() 是虛函數，我們現在是在子類中重寫（重定義）類的虛構函數（此時你可以將父類的虛構函數想像成模板）。 class Circle : public Shape { private: double radius; public: Circle(); Circle(double); double getRadius() const; void setRadius(double); double getArea() const; string toString() const; } 實際當我們在使用虛構函數時，是把它當作跳板，去自動便是哪個函式是哪個函式，e.g. 有多種圖形（園、三角），每種圖形都有面積，虛構函數是當你在使用引用或是指針 (Pointer) 指向基類時，它能根據類自動辨識是哪個圖形（很抽象）。 舉個例子，下面的 Code 引用上面例子的 Shape 類，在下面的 printShape() 傳入的 Shape 類型參數是一個子類繼承父類 Shape 的物件（對象），因為 Circle 或是 Triangle 都是繼承自 Shape 的類，所以當 Circle 和 Triangle 傳入該函數時，你不用特別指定是哪個子類中的 getArea() 函數，會自動判定是哪個子類的物件方法。 void printShape(const Shape \u0026s, double \u0026total) { total += s.getArea(); cout \u003c\u003c s.getArea() \u003c\u003c endl; } ","date":"2020-08-07","objectID":"/about_cpp_class_virtual_function/:2:0","tags":["C++","Class","Virtual","Function","虛函數","純虛函數","繼承"],"title":"C++ - 關於多態中的虛函數與純虛函數","uri":"/about_cpp_class_virtual_function/"},{"categories":["C/C++"],"content":"虛函數與純虛函數 先要有些概念： 定義一個函數為虛函數，不代表函數為不被實現的函數。 定義它為虛函數是為了允許父類的指針來調用子類這個函式。 定義一個函數為純虛函數，才代表函數沒有被實現。 下面是的例子中，加上 = 0 就代表它是純虛函數，無法創造 Shape 類型的對象，如果你在 main() 函數中打上 Shape shape; 聲明一個 Shape 類型的對象，編譯會報錯。 class Shape { public: virtual string toString() const = 0; virtual double getArea() const = 0; } 那為什麼我們要加上 = 0 變成純虛函數呢？你可以想像 “圖形” 是個抽象的總體概稱，圖形可以衍生出圓形、梯形…等，如果可以用 “圖形” 創造出對象，也就是一個對象類型是 “圖形”，那豈不是很荒謬？所以我們加入純虛函數使 “圖形” 無法創造對象，使其合理化*。 注意：上面 Code 中 const = 0，const 與 = 0 毫無關係，所以別誤解宣告純虛函數時一定要在 = 0 前面加上 const。 虛函數與純虛函數的差別就在這個類能不能被用來創造自己的物件（Object），都可以拿做父類繼承。 ","date":"2020-08-07","objectID":"/about_cpp_class_virtual_function/:3:0","tags":["C++","Class","Virtual","Function","虛函數","純虛函數","繼承"],"title":"C++ - 關於多態中的虛函數與純虛函數","uri":"/about_cpp_class_virtual_function/"},{"categories":["C/C++"],"content":"補充 如上的 Shape 父類，關於子類虛函數的寫法： 下面的子類虛函數前面加上 virtual 聲明。 class Circle : public Shape { private: double radius; public: Circle(); Circle(double); double getRadius() const; void setRadius(double); virtual double getArea() const; virtual string toString() const; } 有些人會疑惑子類有沒有 virtual 有差嗎？答案是沒有差，不管有沒有加上 virtual 都是繼承來的虛函數，兩種宣告法都可以，但是加上 virtual 能夠增加 Code 的易讀性，所以建議加上。 ","date":"2020-08-07","objectID":"/about_cpp_class_virtual_function/:4:0","tags":["C++","Class","Virtual","Function","虛函數","純虛函數","繼承"],"title":"C++ - 關於多態中的虛函數與純虛函數","uri":"/about_cpp_class_virtual_function/"},{"categories":["C/C++"],"content":"override override 保留字適用在子類的虛函數上，用來避免繼承錯誤。 沒加上 override 前： 我故意在 Circle 的 getArea() 故意改成 getArea233()，編譯器不會報錯，因為會被認為這不是繼承的。 class Shape { public: virtual string toString() const; virtual double getArea() const; } class Circle : public Shape { private: double radius; public: Circle(); Circle(double); double getRadius() const; void setRadius(double); virtual double getArea233() const; virtual string toString() const; } 但如果我加上 override 保留字： 編譯器會報錯，可以把 override 當成把這函數標示是繼承來的函數。 class Shape { public: virtual string toString() const; virtual double getArea() const; } class Circle : public Shape { private: double radius; public: Circle(); Circle(double); double getRadius() const; void setRadius(double); virtual double getArea233() const override; // 報錯 virtual string toString() const override; } ","date":"2020-08-07","objectID":"/about_cpp_class_virtual_function/:5:0","tags":["C++","Class","Virtual","Function","虛函數","純虛函數","繼承"],"title":"C++ - 關於多態中的虛函數與純虛函數","uri":"/about_cpp_class_virtual_function/"},{"categories":["LaTeX"],"content":"前言 紀錄一下我在 ArchLinux 上配置 LaTeX 的過程。 ","date":"2020-08-07","objectID":"/arhlinux_vscode_latex_install_configuration/:1:0","tags":["ArchLinux","VScode","LaTeX"],"title":"在 ArchLinux 上搭建 LaTeX 環境並使用 VScode 編寫","uri":"/arhlinux_vscode_latex_install_configuration/"},{"categories":["LaTeX"],"content":"安裝環境 你可以直接安裝集合包，texlive-most 包含很多 Tex Live 應用，但是這樣很佔空間，要安裝 2GB 的硬碟空間，所以你也可以選擇自己想要裝的部份，其中 texlive-core 是必裝的。texlive-langchinese 是中文宏包 CTeX，讓 LaTeX 支持中文。 sudo pacman -S texlive-most # 安裝約 12 個包 sudo pacman -S texlive-core # 只裝核心 sudo pacman -S texlive-langchinese # 安裝中文支持 ","date":"2020-08-07","objectID":"/arhlinux_vscode_latex_install_configuration/:2:0","tags":["ArchLinux","VScode","LaTeX"],"title":"在 ArchLinux 上搭建 LaTeX 環境並使用 VScode 編寫","uri":"/arhlinux_vscode_latex_install_configuration/"},{"categories":["LaTeX"],"content":"測試安裝 進入特定資料夾，輸入下面兩行指令測試是否安裝成功， tex '\\empty Hello world!\\bye' 會生成 texput.dvi 和 texput.log。 pdftex '\\empty Hello world!\\bye' 會生成 texput.pdf。 tex '\\empty Hello world!\\bye' pdftex '\\empty Hello world!\\bye' ","date":"2020-08-07","objectID":"/arhlinux_vscode_latex_install_configuration/:3:0","tags":["ArchLinux","VScode","LaTeX"],"title":"在 ArchLinux 上搭建 LaTeX 環境並使用 VScode 編寫","uri":"/arhlinux_vscode_latex_install_configuration/"},{"categories":["LaTeX"],"content":"VScode 配置 先安裝好 LaTeX Workshop 這擴充套件。 LaTeX Workshoplatex_workshop.png \" LaTeX Workshop 設定 接著按下 ctrl + , 進入 VScode 的使用者設置，並點擊右上角的設定文件（JSON），添加下面的設定： 下面設定需要修改的地方是要找到 xelatex、pdflatex、bibtex 裝在哪裡，並替換下面 latex-workshop.latex.tools 中每一項的 command，輸入以下指令可以找到位置： where xelatex # 輸出 /usr/bin/xelatex # 依此類推 跟在 Windows 上的設定差在 command，改成相對應的路徑。 設定 JSON： { // ... \"latex-workshop.latex.recipes\": [ { \"name\": \"xelatex\", \"tools\": [ \"xelatex\" ] }, { \"name\": \"pdflatex\", \"tools\": [ \"pdflatex\" ] }, { \"name\": \"xelatex-\u003ebibtex-\u003exelatex*2\", \"tools\": [ \"xelatex\", \"bibtex\", \"xelatex\", \"xelatex\" ] }, { \"name\": \"pdflatex-\u003ebibtex-\u003epdflatex*2\", \"tools\": [ \"pdflatex\", \"bibtex\", \"pdflatex\", \"pdflatex\" ] } ], \"latex-workshop.latex.tools\": [ { \"name\": \"xelatex\", \"command\": \"/usr/bin/xelatex\", \"args\": [ \"-synctex=1\", \"-interaction=nonstopmode\", \"-shell-escape\", \"%DOC%.tex\" ] }, { \"name\": \"pdflatex\", \"command\": \"/usr/bin/pdflatex\", \"args\": [ \"-synctex=1\", \"-interaction=nonstopmode\", \"-file-line-error\", \"%DOC%\" ] }, { \"name\": \"bibtex\", \"command\": \"/usr/bin/bibtex\", \"args\": [ \"%DOCFILE%\" ] } ], } 這邊主要使用兩個指令：xelatex 及 bibtex，平常都是使用 xelatex 來編譯，只有寫某些文章需要編譯 reference 時才會用到 bibtex。 為了方便何時該用哪種，上述 config 的 recipes 便派上用場，可以看到日常使用的部分我給此 recipe 取名 ”hw”，如果要編論文而需要 reference ，則會採用 ”thesis”，它會依序執行xelatex → bibtex → xelatex → xelatex，這是 LaTeX 中為了正確編出 reference 的用法。 ","date":"2020-08-07","objectID":"/arhlinux_vscode_latex_install_configuration/:4:0","tags":["ArchLinux","VScode","LaTeX"],"title":"在 ArchLinux 上搭建 LaTeX 環境並使用 VScode 編寫","uri":"/arhlinux_vscode_latex_install_configuration/"},{"categories":["LaTeX"],"content":"Hello World 下面是一個我擷取我之前寫的報告作為簡單例子，有我經常用的設定。 \\documentclass[12pt, a4paper]{report} \\usepackage{ctex} % 中文的宏包 \\usepackage{indentfirst} \\usepackage{graphicx} % 插入圖片的宏包 \\usepackage{float} % 設置圖片浮動位置的宏包 \\usepackage{subfigure} % 插入多圖時用子圖顯示宏包 \\usepackage{listings} % 代碼塊宏包 \\usepackage{color} % 代碼高亮 \\usepackage[colorlinks,linkcolor=blue]{hyperref} % URL 包 \\usepackage[pdf]{graphviz} \\usepackage{alphalph} \\renewcommand*{\\thesubfigure}{(\\arabic{subfigure})} \\definecolor{dkgreen}{rgb}{0,0.6,0} \\definecolor{gray}{rgb}{0.5,0.5,0.5} \\definecolor{mauve}{rgb}{0.58,0,0.82} \\lstset{ % %language=Octave, % the language of the code basicstyle=\\scriptsize\\Hack, % the size of the fonts that are used for the code numbers=none, % where to put the line-numbers numberstyle=\\tiny\\color{gray}, % the style that is used for the line-numbers stepnumber=2, % the step between two line-numbers. If it's 1, each line % will be numbered numbersep=3pt, % how far the line-numbers are from the code backgroundcolor=\\color{white}, % choose the background color. You must add \\usepackage{color} showspaces=false, % show spaces adding particular underscores showstringspaces=false, % underline spaces within strings showtabs=false, % show tabs within strings adding particular underscores frame=single, % adds a frame around the code rulecolor=\\color{black}, % if not set, the frame-color may be changed on line-breaks within not-black text (e.g. commens (green here)) tabsize=2, % sets default tabsize to 2 spaces captionpos=b, % sets the caption-position to bottom breaklines=true, % sets automatic line breaking breakatwhitespace=false, % sets if automatic breaks should only happen at whitespace title=\\lstname, % show the filename of files included with \\lstinputlisting; % also try caption instead of title keywordstyle=\\color{blue}, % keyword style commentstyle=\\color{dkgreen}, % comment style stringstyle=\\color{mauve}, % string literal style escapeinside={\\%*}{*}, % if you want to add LaTeX within your code morekeywords={*,...} % if you want to add more keywords to the set } \\setCJKmainfont{Noto Serif CJK TC} % 主要字體 Noto Serif \\newfontfamily\\Hack{Hack} % 代碼字體 \\author{Huang Po-Hsun} \\date{\\today} \\title{數據庫系統 SSD7 實驗報告} \\begin{document} \\maketitle \\tableofcontents \\part{實驗一、數據庫與表的基本操作} \\section{實驗目的} \\begin{itemize} \\item 熟练掌握一种DBMS的使用方法，完成数据库的创建、删除和连接；数据表的建立、删除；表结构的修改。 \\item 加深对表的实体完整性、参照完整性和用户自定义完整性的理解。 \\end{itemize} \\end{document} ","date":"2020-08-07","objectID":"/arhlinux_vscode_latex_install_configuration/:5:0","tags":["ArchLinux","VScode","LaTeX"],"title":"在 ArchLinux 上搭建 LaTeX 環境並使用 VScode 編寫","uri":"/arhlinux_vscode_latex_install_configuration/"},{"categories":["LaTeX"],"content":"畫面 這是實際寫 LaTeX 的畫面。 編寫畫面preview.png \" 編寫畫面 ","date":"2020-08-07","objectID":"/arhlinux_vscode_latex_install_configuration/:6:0","tags":["ArchLinux","VScode","LaTeX"],"title":"在 ArchLinux 上搭建 LaTeX 環境並使用 VScode 編寫","uri":"/arhlinux_vscode_latex_install_configuration/"},{"categories":["LaTeX"],"content":"Reference TeX Live (简体中文) - ArchWiki LaTeX Workshop – 在VSCode中編輯及編譯LaTeX ","date":"2020-08-07","objectID":"/arhlinux_vscode_latex_install_configuration/:7:0","tags":["ArchLinux","VScode","LaTeX"],"title":"在 ArchLinux 上搭建 LaTeX 環境並使用 VScode 編寫","uri":"/arhlinux_vscode_latex_install_configuration/"},{"categories":["Markdown"],"content":"前言 Markdown 我認為是非常好的語言，我每次寫 Blog 或是寫項目、作筆記，Markdown 是首選，LaTeX 比較適合拿來寫報告或是論文。我就在這篇寫一下 Markdown 基礎語法，也就是平常經常用到的語法，其實當初學 Markdown 只花了一小時，後面慢慢寫多就習慣了。 寫 Markdown 的工具： 我推薦下面幾個： Typora：跨平台的 Markdown 編輯器，簡直是利器。 Visual Studio Code：使用 VScode 也可以寫 Markdown，安裝 Markdown All in One 和 Markdown Preview Enhanced 延伸模組，就能夠舒服地寫筆記或文章。 HackMD：線上共筆平台，使用 Markdown，大家在共同寫文檔時可以使用這平台 ","date":"2020-08-07","objectID":"/markdown_learn_note_basic_syntax/:1:0","tags":["Markdown"],"title":"Markdown 學習筆記 - 基礎語法","uri":"/markdown_learn_note_basic_syntax/"},{"categories":["Markdown"],"content":"文本編寫標準 中文文案排版指北 [简体中文 ][繁体中文 ] ","date":"2020-08-07","objectID":"/markdown_learn_note_basic_syntax/:2:0","tags":["Markdown"],"title":"Markdown 學習筆記 - 基礎語法","uri":"/markdown_learn_note_basic_syntax/"},{"categories":["Markdown"],"content":"區塊元素 ","date":"2020-08-07","objectID":"/markdown_learn_note_basic_syntax/:3:0","tags":["Markdown"],"title":"Markdown 學習筆記 - 基礎語法","uri":"/markdown_learn_note_basic_syntax/"},{"categories":["Markdown"],"content":"標題 h1 - h6，h1 有兩種寫法。第一種是下一行添加 ===，第二種就是加上 #。 h1 標題 === # h1 標題 ## h2 標題 ### h3 標題 #### h4 標題 ##### h5 標題 ###### h6 標題 ","date":"2020-08-07","objectID":"/markdown_learn_note_basic_syntax/:3:1","tags":["Markdown"],"title":"Markdown 學習筆記 - 基礎語法","uri":"/markdown_learn_note_basic_syntax/"},{"categories":["Markdown"],"content":"註解 跟 HTML 一樣的用法使用 \u003c!-- --\u003e。 \u003c!-- 我是註解 --\u003e ","date":"2020-08-07","objectID":"/markdown_learn_note_basic_syntax/:3:2","tags":["Markdown"],"title":"Markdown 學習筆記 - 基礎語法","uri":"/markdown_learn_note_basic_syntax/"},{"categories":["Markdown"],"content":"引言 Markdown使用email形式的區塊引言，使用 \u003e 的方式添加引言，\u003e \u003e 是二級引言，引言內也可以使用其他 MD 語法。P.S. 二級引言我平時寫文章或筆記都用不到。 \u003e This is a blockquote with two paragraphs. Lorem ipsum dolor sit amet, \u003e consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus. \u003e Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus. \u003e \u003e Donec sit amet nisl. Aliquam semper ipsum sit amet velit. Suspendisse \u003e \u003e id sem consectetuer libero luctus adipiscing. \u003e ## This is a header. \u003e \u003e 1. This is the first list item. \u003e 2. This is the second list item. 輸出如下： 因為上面的二級標題會影響我這篇文章的標題，我這 Blog 是使用 Markdown 寫的，所以就沒有加到輸出效果。 This is a blockquote with two paragraphs. Lorem ipsum dolor sit amet, consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus. Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus. Donec sit amet nisl. Aliquam semper ipsum sit amet velit. Suspendisse id sem consectetuer libero luctus adipiscing. This is the first list item. This is the second list item. ","date":"2020-08-07","objectID":"/markdown_learn_note_basic_syntax/:3:3","tags":["Markdown"],"title":"Markdown 學習筆記 - 基礎語法","uri":"/markdown_learn_note_basic_syntax/"},{"categories":["Markdown"],"content":"清單 List 無序清單 使用 *、+、- 皆可輸出無序清單，但是我比較長使用 -，因為 * 和 + 需要按住 shift 鍵。清單可以多層，二層清單是在下一行空兩格繼續寫清單。 * Red * Green * Blue + Red + Green + Blue - Red - Green - Blue \u003c!-- 二層清單 --\u003e * Nulla volutpat aliquam velit * Phasellus iaculis neque * Purus sodales ultricies 輸出如下： Red Green Blue Red Green Blue Red Green Blue Nulla volutpat aliquam velit Phasellus iaculis neque Purus sodales ultricies 有序清單 使用數字接著一個英文句點： 1. Bird 2. McHale 3. Parish 輸出如下： Bird McHale Parish 注意 你在清單標記上使用的數字並不會影響輸出的HTML結果。 e.g. 下面的 Code： 1. Bird 1. McHale 1. Parish 3. Bird 1. McHale 8. Parish 輸出： Bird McHale Parish Bird McHale Parish 清單項目可以包含多個段落，每個項目下的段落都必須縮排 4 個空白或是一個 Tab： 1. This is a list item with two paragraphs. Lorem ipsum dolor sit amet, consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus. Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus. Donec sit amet nisl. Aliquam semper ipsum sit amet velit. 2. Suspendisse id sem consectetuer libero luctus adipiscing. 當然，項目清單很可能會不小心產生，像是下面這樣的寫法： 1986. What a great season. 換句話說，也就是在行首出現數字－句點－空白，要避免這樣的狀況，你可以在句點前面加上反斜線。 1986\\. What a great season. ","date":"2020-08-07","objectID":"/markdown_learn_note_basic_syntax/:3:4","tags":["Markdown"],"title":"Markdown 學習筆記 - 基礎語法","uri":"/markdown_learn_note_basic_syntax/"},{"categories":["Markdown"],"content":"程式碼區塊 縮排 4 個空白或是 1 個 Tab 就可以簡單達到 Code 區塊。 print('Hello') 輸出如下： print('Hello') 但是我不建議這樣的寫法，正確的寫法應該如下： ```python print(‘Hello’) ``` 輸出結果如下： print('Hello') 使用 ``` 將 Code 區塊包起來，並在開頭寫明是哪種語言，以方便語法高亮，行內 Code 區塊使用如下： 我是 `行內 Code` 喔！ 輸出如下： 我是 行內 Code 喔！ ","date":"2020-08-07","objectID":"/markdown_learn_note_basic_syntax/:3:5","tags":["Markdown"],"title":"Markdown 學習筆記 - 基礎語法","uri":"/markdown_learn_note_basic_syntax/"},{"categories":["Markdown"],"content":"分隔線 你可以在一行中用三個或以上的星號、減號、底線來建立一個分隔線，行內不能有其他東西。你也可以在星號中間插入空白。下面每種寫法都可以建立分隔線： * * * *** ***** - - - --------------------------------------- 輸出如下： P.S 這輸出效果有點模糊呀 (;3;) ","date":"2020-08-07","objectID":"/markdown_learn_note_basic_syntax/:3:6","tags":["Markdown"],"title":"Markdown 學習筆記 - 基礎語法","uri":"/markdown_learn_note_basic_syntax/"},{"categories":["Markdown"],"content":"區段元素 ","date":"2020-08-07","objectID":"/markdown_learn_note_basic_syntax/:4:0","tags":["Markdown"],"title":"Markdown 學習筆記 - 基礎語法","uri":"/markdown_learn_note_basic_syntax/"},{"categories":["Markdown"],"content":"連結 Markdown支援兩種形式的連結語法：行內和參考兩種形式。 不管是哪一種，連結的文字都是用 [方括號] 來標記。 然而這裡我就只使用行內的形式，所以只需要會行內就好，但你如果喜歡參考的形式也是可以。 行內 你可以使用 [Google](https://www.google.com) 搜索引擎 參考 你可以使用 [Google][] 搜索引擎 [Google]: http://google.com/ ","date":"2020-08-07","objectID":"/markdown_learn_note_basic_syntax/:4:1","tags":["Markdown"],"title":"Markdown 學習筆記 - 基礎語法","uri":"/markdown_learn_note_basic_syntax/"},{"categories":["Markdown"],"content":"強調 斜體與粗體，我都使用 * 和 **，看個人習慣使用哪個符號。 *single asterisks* _single underscores_ **double asterisks** __double underscores__ 輸出如下： single asterisks single underscores double asterisks double underscores ","date":"2020-08-07","objectID":"/markdown_learn_note_basic_syntax/:4:2","tags":["Markdown"],"title":"Markdown 學習筆記 - 基礎語法","uri":"/markdown_learn_note_basic_syntax/"},{"categories":["Markdown"],"content":"圖片 一個驚嘆號 !。 接著一個方括號，裡面放上圖片的替代文字。 接著一個普通括號，裡面放上圖片的網址，最後還可以用引號包住並加上選擇性的’title’文字。 ![Alt text](/path/to/img.jpg) ![Alt text](/path/to/img.jpg \"Optional title\") ","date":"2020-08-07","objectID":"/markdown_learn_note_basic_syntax/:4:3","tags":["Markdown"],"title":"Markdown 學習筆記 - 基礎語法","uri":"/markdown_learn_note_basic_syntax/"},{"categories":["Markdown"],"content":"跳脫字元 Markdown 可以利用反斜線來插入一些在語法中有其他意義的符號，例如：如果你想要用星號加在文字旁邊的方式來做出強調效果（但不用 \u003cem\u003e 標籤），你可以在星號的前面加上反斜線： \\*literal asterisks\\* Markdown支援在下面這些符號前面加上反斜線來幫助插入普通的符號： \\ 反斜線 ` 反引號 * 星號 _ 底線 {} 大括號 [] 方括號 () 括號 # 井字號 + 加號 - 減號 . 英文句點 ! 驚嘆號 ","date":"2020-08-07","objectID":"/markdown_learn_note_basic_syntax/:5:0","tags":["Markdown"],"title":"Markdown 學習筆記 - 基礎語法","uri":"/markdown_learn_note_basic_syntax/"},{"categories":["Markdown"],"content":"Table Markdown 的表格需要注意的是他的對齊方式。第二行可以進行對齊。 ---：預設靠左 :---：向左靠齊 ---:：向右靠齊 :---:：居中對齊 | 列表1 | 列表2 | 列表 3 | 列表4 | | --- | :--- | ---: | :---: | | ... | ... | ... | --- | | ... | ... | ... | --- | 輸出結果： 列表1 列表2 列表 3 列表4 … … … — … … … — ","date":"2020-08-07","objectID":"/markdown_learn_note_basic_syntax/:6:0","tags":["Markdown"],"title":"Markdown 學習筆記 - 基礎語法","uri":"/markdown_learn_note_basic_syntax/"},{"categories":["Markdown"],"content":"Reference Markdown 語法說明 ","date":"2020-08-07","objectID":"/markdown_learn_note_basic_syntax/:7:0","tags":["Markdown"],"title":"Markdown 學習筆記 - 基礎語法","uri":"/markdown_learn_note_basic_syntax/"},{"categories":["前端"],"content":"關於我遇到的問題 這是我在寫小 DEMO 發現的，關於 JS 的賦值問題，這裡涉及到了 Pointer。 下面是我用簡單的 Code 描述我遇到的問題，object 是一個 Object Array，然後傳入函數進行局域變量賦值。 let object = [ { name: \"John\", age: 18 }, { name: \"Amy\", age: 20 }, ] function Test(object) { let newOne = object; for (let i = 0; i \u003c newOne.length; i++) { newOne[i].name = \"Rose\"; } } Test(object) console.log(object) 結果輸出如下： // object [ { name: \"Rose\", age: 18 }, { name: \"Rose\", age: 20 }, ] 從這個輸出結果來看，我們可以判定，這個函式修改 newOne 這個局部變量時，也修改到了 object。 我網上爬了文，大致知道這是 JS 的一個像是語法 Bug 的問題，賦值給 newOne 時其實是給了指針位置，所以導致修改 newOne 時也修改到了 object。 所以要改寫成下面的寫法： 利用聲明一個臨時局部變量然後賦值，再 Push 進 Array。 let object = [ { name: \"John\", age: 18 }, { name: \"Amy\", age: 20 }, ] function Test(object) { let newOne = []; for (let i = 0; i \u003c object.length; i++) { let temp = { name: \"Rose\", age: object[i].age } newOne.push(temp); } } Test(object) console.log(object) 輸出結果： // object [ { name: \"John\", age: 18 }, { name: \"Amy\", age: 20 }, ] ","date":"2020-08-06","objectID":"/js_pointer_object_array_variable_assignment/:1:0","tags":["JS","前端","Pointer","Variable","Object","Assignment","Array"],"title":"JS - Object Array 賦值問題","uri":"/js_pointer_object_array_variable_assignment/"},{"categories":["前端"],"content":"前言 在這篇文章筆記紀錄一下 JS 的 Array 屬性。 ","date":"2020-08-06","objectID":"/js_array_prototype/:1:0","tags":["JS","前端","forEach","map","filter","reduce","循環遍歷","Array"],"title":"JS - forEach()、map()、filter()、reduce()、循環遍歷","uri":"/js_array_prototype/"},{"categories":["前端"],"content":"forEach() forEach 是對每一項的操作，會影響原來的 array，不會有回傳值，即使強制寫 return，也會是空值，例子如下。 // JS forEach 與 map // forEach 是對每一項的操作，會影響原來的 array let arr = [1, 2, 3, 4, 5, 6] // 對數組直接進行循環，相當於 for，沒有返回值 // result 不會有返回值 即使寫了 return 也是 undefined let result = arr.forEach((item, index, arr) =\u003e { console.log(item) console.log(index) console.log(arr) return item }) console.log(result) ","date":"2020-08-06","objectID":"/js_array_prototype/:2:0","tags":["JS","前端","forEach","map","filter","reduce","循環遍歷","Array"],"title":"JS - forEach()、map()、filter()、reduce()、循環遍歷","uri":"/js_array_prototype/"},{"categories":["前端"],"content":"map() map 則是不會影響原來的 array 值，而是生成新的值返回給新的數組。對 Array 每一項進行加工，加工完成之後返回一個新的數組。 // map 對數組每一項進行加工，加工完成之後返回一個新的數組 arr.map((item, index, arr) =\u003e { let str = index + item + index return str; }) console.log(arr) ","date":"2020-08-06","objectID":"/js_array_prototype/:3:0","tags":["JS","前端","forEach","map","filter","reduce","循環遍歷","Array"],"title":"JS - forEach()、map()、filter()、reduce()、循環遍歷","uri":"/js_array_prototype/"},{"categories":["前端"],"content":"filter() 顧名思義，過濾，filter 將想要的內容進行篩選，不想要的過濾，最終得到想要的內容。 // filter 過濾，將想要的內容進行篩選，不想要的過濾，最終得到想要的內容 let result2 = arr.filter((item, index) =\u003e { // 通過返回 true 或是 false 進行選擇 // true 是要，false 是不要 if (item % 2 === 0) { return true } else { return false } }) console.log(result2) ","date":"2020-08-06","objectID":"/js_array_prototype/:4:0","tags":["JS","前端","forEach","map","filter","reduce","循環遍歷","Array"],"title":"JS - forEach()、map()、filter()、reduce()、循環遍歷","uri":"/js_array_prototype/"},{"categories":["前端"],"content":"reduce() reduce 是對整個 Array 進行整合， // reduce 是對整個數組進行整合 // 比如你要做一個將術組裡所有的數字進行相加 // 將數組每一項內容整合後，返回一個內容 let arr2 = [1, 2, 3, 4, 5, 6, 7, 8, 9] let arr4 = arr2.reduce((pre, next, index) =\u003e { console.log(pre) console.log(next) console.log(index) return pre + next }, 0) // 這裡尾部的 0 是初始值，因為弟一個參數 沒有 pre console.log(arr4) 使用箭頭函數進行整合。 const array1 = [1, 2, 3, 4]; const reducer = (accumulator, currentValue) =\u003e accumulator + currentValue; // 1 + 2 + 3 + 4 console.log(array1.reduce(reducer)); // expected output: 10 // 5 + 1 + 2 + 3 + 4 console.log(array1.reduce(reducer, 5)); // expected output: 15 ","date":"2020-08-06","objectID":"/js_array_prototype/:5:0","tags":["JS","前端","forEach","map","filter","reduce","循環遍歷","Array"],"title":"JS - forEach()、map()、filter()、reduce()、循環遍歷","uri":"/js_array_prototype/"},{"categories":["前端"],"content":"For 循環 for…in…主要用於遍歷對象（Object），不適用遍歷數組。 for…of…可以用來遍歷 Array，類數組對象，字符串，set/map, generator。 // for...in...主要用於遍歷對象，不適用遍歷數組 // for...of...可以用來遍歷數組，類數組對象，字符串，set/map, generator // for(key of obj) 裡面的是每一項 let obj = { name: \"Huang\", type: \"handsome\", content: \"front end\" } for(key in obj) { console.log(\"key: \" + key + \", value: \" + obj[key]) } // 循環每一項 for (let item of arr2) { console.log(item) } ","date":"2020-08-06","objectID":"/js_array_prototype/:6:0","tags":["JS","前端","forEach","map","filter","reduce","循環遍歷","Array"],"title":"JS - forEach()、map()、filter()、reduce()、循環遍歷","uri":"/js_array_prototype/"},{"categories":["前端"],"content":"Reference Array.prototype.reduce() - MDN ","date":"2020-08-06","objectID":"/js_array_prototype/:7:0","tags":["JS","前端","forEach","map","filter","reduce","循環遍歷","Array"],"title":"JS - forEach()、map()、filter()、reduce()、循環遍歷","uri":"/js_array_prototype/"},{"categories":["前端"],"content":"前言 因為我前段時間學了 React，我會在這邊文章紀錄我學到的內容。 ","date":"2020-08-05","objectID":"/react_learn_note/:1:0","tags":["React","前端","npm","JSX","JS","Redux","ReactRouter","Web"],"title":"React 學習筆記 - JSX、組件、渲染、路由、Redux","uri":"/react_learn_note/"},{"categories":["前端"],"content":"建立一個 Hello World 在終端機輸入下面的指令，會在該目錄下生成一個名為 my-app 的 React 應用目錄。 註：npx 是 npm 5.2+ 或更高版本附帶的包運行器工具。 npx npx create-react-app my-app npm npm init react-app my-app Yarn Yarn 0.25+ 才能使用 yarn create \u003cstarter-kit-package\u003e yarn create react-app my-app ","date":"2020-08-05","objectID":"/react_learn_note/:2:0","tags":["React","前端","npm","JSX","JS","Redux","ReactRouter","Web"],"title":"React 學習筆記 - JSX、組件、渲染、路由、Redux","uri":"/react_learn_note/"},{"categories":["前端"],"content":"Project 結構 my-app ├── README.md ├── node_modules ├── package.json ├── .gitignore ├── public │ ├── favicon.ico │ ├── index.html │ └── manifest.json └── src ├── App.css ├── App.js ├── App.test.js ├── index.css ├── index.js ├── logo.svg ├── serviceWorker.js └── setupTests.js 這部份跟 Vue-cli 蠻相似的，只是在目錄結構上不如 Vue-cli。 檔案或文件 用途 node_modules/ 依賴 package.json 包管理文件 public/ 公共資源目錄 src/ 源碼 src/index.js 根頁面 我這裡是建議 src/ 改成跟 Vue-cli 初始化時相同的結構。可以自己定義想要怎麼樣的結構，所以不一定要像我下面寫的一樣。 my-app ├── README.md ├── node_modules ├── package.json ├── .gitignore ├── public │ ├── favicon.ico │ ├── index.html │ └── manifest.json └── src ├── components │ └── App │ ├── App.css │ ├── App.js │ └── App.test.js ├── index.css ├── index.js ├── router │ └── index.js ├── store │ └── index.js ├── static │ ├── css │ ├── img │ │ └── logo.svg │ └── js ├── serviceWorker.js ├── setupTests.js └── views ├── Home │ ├── Home.css │ └── Home.js └── About ├── About.css └── About.js ","date":"2020-08-05","objectID":"/react_learn_note/:3:0","tags":["React","前端","npm","JSX","JS","Redux","ReactRouter","Web"],"title":"React 學習筆記 - JSX、組件、渲染、路由、Redux","uri":"/react_learn_note/"},{"categories":["前端"],"content":"指令 下面兩個之一的指令可以運行項目。 npm start yarn start 下面是打包指令 npm run build yarn build ","date":"2020-08-05","objectID":"/react_learn_note/:4:0","tags":["React","前端","npm","JSX","JS","Redux","ReactRouter","Web"],"title":"React 學習筆記 - JSX、組件、渲染、路由、Redux","uri":"/react_learn_note/"},{"categories":["前端"],"content":"JSX ","date":"2020-08-05","objectID":"/react_learn_note/:5:0","tags":["React","前端","npm","JSX","JS","Redux","ReactRouter","Web"],"title":"React 學習筆記 - JSX、組件、渲染、路由、Redux","uri":"/react_learn_note/"},{"categories":["前端"],"content":"語法 JSX 就是一種可以用 JS 寫 HTML 的語法，最後編譯會轉成 HTML，光是可以用 JS 寫網頁就可以使開發上更加靈活。 下面是一個 JS 的普通對象，包括一開始初始化項目的 App.js 也是對象。可以改造成下面例子的樣子。 對象與組件是不同的東西，組件命名開頭必須是大寫，對象則不用，element = \u003ch1\u003e你好，世界！\u003c/h1\u003e; 可以想像成是變量與值，element 被賦值組件值。 import React, { Children } from \"react\"; import ReactDOM from \"react-dom\"; import \"./index.css\"; import App from \"./App\"; const element = \u003ch1\u003e你好，世界！\u003c/h1\u003e; // \u003cApp /\u003e 普通對象 let root = document.getElementById(\"root\"); ReactDOM.render(element, root); ","date":"2020-08-05","objectID":"/react_learn_note/:5:1","tags":["React","前端","npm","JSX","JS","Redux","ReactRouter","Web"],"title":"React 學習筆記 - JSX、組件、渲染、路由、Redux","uri":"/react_learn_note/"},{"categories":["前端"],"content":"簡單的 Clock 實例 這例子是使用間隔函數不斷重新渲染頁面，但是因為根頁面渲染被限制住了，所以不適合。 註：在選取元素 ID 不一定要用 document.getElementById(\"root\") 也可以使用 document.querySelector('#root') 方式操作 DOM。 function clock() { let time = new Date().toLocaleTimeString(); let element = \u003ch1\u003eCurrent Time: { time }\u003c/h1\u003e; let root = document.querySelector('#root') ReactDOM.render(element, root) } clock(); // 間隔函數 setInterval(clock, 1000); 下面的例子是上面的改版，是函數式組件。 註：組件名稱都必須是開頭大寫，不然無法被 JSX 語法識別。 // react 函數式組件 // 組件開頭必須大寫 function Clock(props) { return ( \u003ch1\u003eCurrent Time: { props.date.toLocaleTimeString() }\u003c/h1\u003e ); } function run() { // date 傳參 ReactDOM.render( \u003cClock date={ new Date() } /\u003e, document.querySelector('#root') ) } setInterval(run, 1000); ","date":"2020-08-05","objectID":"/react_learn_note/:5:2","tags":["React","前端","npm","JSX","JS","Redux","ReactRouter","Web"],"title":"React 學習筆記 - JSX、組件、渲染、路由、Redux","uri":"/react_learn_note/"},{"categories":["前端"],"content":"Style 寫 Style 對象時參數是駝峰命名法，當然也可以使用像是 \"background-img\": \"url(https...)\" 的方法表示樣式參數，雖然可以使用原來的命名，但是不建議用這方法，因為 Code 的規範。 因為 class 在 JS 中表示類，是 Keyword，所以要改用 className 表示 HTML 元素中的類樣式，兩者是不同的概念。 在 JSX 語法中要寫註解的話，分成 HTML 使用 {/* */} 這方法，因為 {} 是放 JS 語法的地方，JS 中就直接 //。 // 駝峰命名 // style 中如果存在多個單字的屬性組合，第二個單字開始，首字母大寫。 // 可以不首字母大寫，但要換寫法 let exampleStyle = { background: \"skyblue\", borderBottom: \"1px solid red\", // 不用首字母大寫的方法 e.g. // \"background-img\": \"url(https...)\" } let element = ( \u003cdiv\u003e \u003ch1 style={exampleStyle}\u003eHello World\u003c/h1\u003e \u003c/div\u003e ) // class 在 Js 中是關鍵字，所以要改成 className // className 和 style 等屬性不能是 string，必須是對象參數 // 不能有多個 className 或是多個 style，會被自動刪掉剩一個 // className 可以用 string 相加的方式 let classStr = \"abc\" let element1 = ( \u003cdiv\u003e \u003ch1 className={\"cba \" + classStr}\u003eHello World\u003c/h1\u003e \u003c/div\u003e ) // react 中 className array 無法像 Vue 一樣可以自動拆解 // 所以要加上 join 去做間隔 let classArray = ['abc', 'cba'].join(\" \"); let elementArrayClass = ( \u003cdiv\u003e {/* 在 HTML 寫註釋 */} \u003ch1 className={classArray}\u003eHello World\u003c/h1\u003e \u003c/div\u003e // 在 JS 寫註釋 ) ReactDOM.render( element1, document.querySelector('#root') ) ","date":"2020-08-05","objectID":"/react_learn_note/:5:3","tags":["React","前端","npm","JSX","JS","Redux","ReactRouter","Web"],"title":"React 學習筆記 - JSX、組件、渲染、路由、Redux","uri":"/react_learn_note/"},{"categories":["前端"],"content":"組件 命名開頭都必須是大寫。 函數式組件 下面是前面簡單 Clock 實例的函數式組件，傳參進行渲染。 函數式組件是靜態組件，頂多傳參數。 函數式組件 stateless 無生命週期。 function Clock(props) { return ( \u003ch1\u003eCurrent Time: { props.date.toLocaleTimeString() }\u003c/h1\u003e ); } 類組件 下面是最簡單的類組件 類組件可以定義方法。 類組件 stateful 有生命週期。 類組件中可以在包含組件 -\u003e 複合組件。 // 類組件 - 可以定義方法 // 有事件或是動態的 使用類組件：e.g. 點擊事件 // 函數式組件是靜態組件，頂多傳參數 // 函數式組件 stateless 無生命週期 // 類組件 stateful 有生命週期 // 類組件中可以在包含組件 -\u003e 複合組件 class HelloWorld extends React.Component { render(){ console.log(this) return ( \u003cdiv\u003e \u003ch1\u003e類組件 Hello World\u003c/h1\u003e {/* 類組件傳參 */} {/* \u003ch2\u003ehello: {this.props.name}\u003c/h2\u003e */} \u003c/div\u003e ) } } ReactDOM.render( \u003cHelloWorld /\u003e, document.querySelector('#root') ) 類組件實現簡單 Clock 實例 React State 相當於 Vue 的 Data。** React 類組件中要修改 State 的話，不能直接修改，要使用 this.setState() 方法進行修改。 constructor() 是構造函數，render() 是渲染函數。 super() 是繼承父類的方法，props 可以用來傳參。 下面的例子只是簡單實現的 Clock 顯示，這裡只是舉個例子讓你了解怎麼使用類組件。下面例子最尾部的註解是因為一開始我們沒有使用生命周期函數 componentDidMount() 去做時間的更新，後面因為用到了生命周期函數，所以要將原本的註解掉，算是錯誤示範。 // React State 相當於 Vue 的 Data // 用類組件實現 class ClockClass extends React.Component { // 構造函數 constructor(props) { super(props) // 狀態 (數據) -\u003e View this.state = { time: new Date().toLocaleTimeString() } } render() { // this.state.time = new Date().toLocaleTimeString(); return ( \u003cdiv\u003e \u003ch1\u003e{this.state.time}\u003c/h1\u003e \u003c/div\u003e ) } // 生命周期函數 // 組件渲染完成時調用的函數 componentDidMount() { setInterval(() =\u003e { // 錯誤的改變方式 // this.state.time = new Date().toLocaleTimeString(); // 正確的修改，使用 setState // 切勿直接修改 state 數據，直接 state 重新渲染內容，需使用 setState // setState 是異步 // 通過 this.setState 修改完數據後，並不會立即修改 DOM 裡面的內容 // react 會在這個修改函數內容所有設置改變後，統一對比虛擬 DOM 對象，然後再統一修改，提升性能 this.setState({ time: new Date().toLocaleTimeString() }) }, 1000) } } ReactDOM.render( \u003cClockClass /\u003e, document.querySelector('#root') ) // 不推薦的方法，因為跟組件 Dom 渲染綁在一起 // setInterval(() =\u003e { // ReactDOM.render( // \u003cClockClass /\u003e, // document.querySelector('#root') // ) // }, 1000) 類組件方法綁定 類的方法需要進行綁定 this 才能進行使用，也可以使用箭頭函數，箭頭函數直接就是指向父類的 this。 class Tab extends React.Component { constructor(props) { super(props) // 設置狀態和數據 this.state = { isActive: \"\", strClass: \"\" } this.clickEvent = this.clickEvent.bind(this) } clickEvent() { console.log(\"click event\") } render() { return ( \u003cdiv\u003e \u003cbutton onClick={this.clickEvent}\u003econtent 1\u003c/button\u003e \u003cbutton\u003econtent 2\u003c/button\u003e \u003cdiv className=\"content active\"\u003e \u003ch1\u003econtent 1\u003c/h1\u003e \u003c/div\u003e \u003cdiv className=\"content\"\u003e \u003ch1\u003econtent 2\u003c/h1\u003e \u003c/div\u003e \u003c/div\u003e ) } } ","date":"2020-08-05","objectID":"/react_learn_note/:5:4","tags":["React","前端","npm","JSX","JS","Redux","ReactRouter","Web"],"title":"React 學習筆記 - JSX、組件、渲染、路由、Redux","uri":"/react_learn_note/"},{"categories":["前端"],"content":"組件傳值 父傳子 在 JSX 中，只能父傳子組件數據，單向流動，不能子傳父。 注意：props 可以傳遞函數，props 可以傳遞父函數的元素，就可以去修改父元素的 state，從而達到子組件傳遞數據給父元素。 // Props // 父傳子組件數據，單向流動，不能子傳父 // props 可以設置默認值 // 注意：props 可以傳遞函數，props 可以傳遞父函數的元素，就可以去修改父元素的 state，從而達到傳遞數據給父元素 // 在父元素中使用 state 去控制子元素 props 的從而達到父元素數據傳遞給子元素 class ParentCom extends React.Component { constructor(props) { super(props) this.state = { isAction: true } // 綁定事件 this.changeShow = this.changeShow.bind(this) } render() { return ( \u003cdiv\u003e \u003cbutton onClick={this.changeShow}\u003e控制子元素顯示\u003c/button\u003e \u003cChildrenCom isAction={this.state.isAction}/\u003e \u003c/div\u003e ) } changeShow() { this.setState({ isAction: !this.state.isAction }) } } class ChildrenCom extends React.Component { constructor(props) { super(props) } render() { let strClass = null; if(this.props.isAction) { strClass = 'active' } else { strClass = '' } return ( \u003cdiv className={\"content \" + strClass}\u003e \u003ch1\u003e我是子元素\u003c/h1\u003e \u003c/div\u003e ) } } ReactDOM.render( \u003cParentCom /\u003e, document.querySelector('#root') ) 子傳父 調用父元素的函數從而操作子元素的數據，從而實現 子 -\u003e 父。 // 子傳父 // 調用父元素的函數從而操作子元素的數據，從而實現 子 -\u003e 父 class ParentCom2 extends React.Component { constructor(props) { super(props) this.state = { childData: null } } render() { return ( \u003cdiv\u003e \u003ch1\u003e子傳父的數據：{this.state.childData}\u003c/h1\u003e {/* 傳遞函式給子組件 */} \u003cChildrenCom2 setChildData={this.setChildData}/\u003e \u003c/div\u003e ) } setChildData = (data) =\u003e { this.setState({ childData: data }) } } class ChildrenCom2 extends React.Component { constructor(props) { super(props) this.state = { msg: \"hello\" } } render() { return ( \u003cdiv\u003e \u003cbutton onClick={this.sendData}\u003e傳遞 hello 給父元素\u003c/button\u003e {/* 更簡單的方法 */} \u003cbutton onClick={ () =\u003e {this.props.setChildData('直接傳')}}\u003e傳遞 hello 給父元素\u003c/button\u003e \u003c/div\u003e ) } // 搞成箭頭函數 sendData = () =\u003e { console.log(this.state.msg) // 用 props 拿到父組件的函數 // 將子元素數據傳遞給父元素 this.props.setChildData(this.state.msg) } } ReactDOM.render( \u003cParentCom2 /\u003e, document.querySelector('#root') ) ","date":"2020-08-05","objectID":"/react_learn_note/:5:5","tags":["React","前端","npm","JSX","JS","Redux","ReactRouter","Web"],"title":"React 學習筆記 - JSX、組件、渲染、路由、Redux","uri":"/react_learn_note/"},{"categories":["前端"],"content":"Event 事件綁定 onClick 用來綁定事件，在綁定的時候不能像 Vue 中 @click=\"...\" 一樣使用 String，要使用 {} 傳入一個函數。下面的事件使用的箭頭函數，這樣就不需要在構造函數寫綁定。 // React event // 綁定事件使用駝峰命名法 // {} 傳入一個函數，不是 String // 原生 js 阻止默認行為時，可以直接返回 return false // react 中，阻止默認必須使用 e.preventDefault(); class ClickCom extends React.Component { render() { return ( \u003cdiv\u003e \u003cform action=\"https://www.google.com\" target=\"_blank\"\u003e \u003cbutton onClick={this.preventEvent}\u003esubmit\u003c/button\u003e \u003c/form\u003e {/* es6 箭頭函數 */} \u003cbutton onClick={(e) =\u003e { this.preventEvent1(\"msg: 123\", e); }} \u003e submit \u003c/button\u003e {/* 不使用 es6 箭頭函數傳遞多個參數的方式 */} \u003cbutton onClick={function (e) { this.preventEvent1(\"msg: 123\", e); }.bind(this)} \u003e submit \u003c/button\u003e \u003c/div\u003e ); } preventEvent = (e) =\u003e { console.log(e.preventDefault); e.preventDefault(); // js 原生寫法 // return false }; preventEvent1 = (msg, e) =\u003e { console.log(msg); // js 原生寫法 // return false }; } ReactDOM.render(\u003cClickCom /\u003e, document.querySelector(\"#root\")); ","date":"2020-08-05","objectID":"/react_learn_note/:5:6","tags":["React","前端","npm","JSX","JS","Redux","ReactRouter","Web"],"title":"React 學習筆記 - JSX、組件、渲染、路由、Redux","uri":"/react_learn_note/"},{"categories":["前端"],"content":"條件渲染 下面是簡單的條件渲染，情況二因為可以是三元運算式，直接透過運算賦值給一個變量成一個 JSX 對象，所以在這裡沒有寫，以下面情況一的例子就是 let element = this.state.isLogin ? \u003cUserGreet/\u003e : \u003cUserLogin/\u003e 然後 return element，差別不大。 // React 條件渲染 // 1. 直接通過條件運算返回要渲染的 JSX 對象 // 2. 通過條件運算得出 JSX 對象，將對象渲染到模板 // 情況一 function UserGreet(params) { return (\u003ch1\u003ewelcome to sign in\u003c/h1\u003e) } function UserLogin(params) { return (\u003ch1\u003e請先登入\u003c/h1\u003e) } class ParentCom extends React.Component { constructor(props) { super(props) this.state = { isLogin: false } } render() { if(this.state.isLogin) { return (\u003cUserGreet/\u003e) } else { return (\u003cUserLogin/\u003e) } } } ReactDOM.render(\u003cParentCom /\u003e, document.querySelector(\"#root\")); // 情況二 // 自己類推 ","date":"2020-08-05","objectID":"/react_learn_note/:5:7","tags":["React","前端","npm","JSX","JS","Redux","ReactRouter","Web"],"title":"React 學習筆記 - JSX、組件、渲染、路由、Redux","uri":"/react_learn_note/"},{"categories":["前端"],"content":"List 渲染（循環渲染） 下面是簡單的 List 渲染例子： arrayHTML 是 JSX 對象 Array。但是這個例子因為使用上不夠優雅靈活，所以不適合，應該要使用像是傳參動態渲染的方法。 // List 渲染 let array = [\"banana\", \"apple\", \"peach\"]; let arrayHTML = [\u003cli\u003ebanana\u003c/li\u003e, \u003cli\u003eapple\u003c/li\u003e, \u003cli\u003epeach\u003c/li\u003e] class Welcome extends React.Component { constructor(props) { super(props) } render() { return ( \u003cdiv\u003e \u003cul\u003e {array} {arrayHTML} \u003c/ul\u003e \u003c/div\u003e ) } } ReactDOM.render(\u003cWelcome /\u003e, document.querySelector(\"#root\")); 下面是更進的改造版，將一部份作為函式數組件，傳入參數可以進行渲染，相當於模板。 // 作為模板 function ListItem(props) { return ( \u003cli key={props.index}\u003e \u003ch3\u003e {props.index} : {props.data.title} \u003c/h3\u003e \u003cp\u003e{props.data.content}\u003c/p\u003e \u003c/li\u003e ); } // 有動態事件的方式 class ListItem2 extends React.Component { constructor(props) { super(props); } render() { return ( \u003cli key={this.props.index} onClick={(event) =\u003e { this.clickEvent(this.props.index, this.props.data.title, event); }} \u003e \u003ch3\u003e {this.props.index} : {this.props.data.title} \u003c/h3\u003e \u003cp\u003e{this.props.data.content}\u003c/p\u003e \u003c/li\u003e ); } clickEvent = (index, title, event) =\u003e { alert(index + \" - \" + title); }; } class Welcome extends React.Component { constructor(props) { super(props); this.state = { list: [ { title: \"NO1 111\", content: \"11111\", }, { title: \"NO2 222\", content: \"222\", }, { title: \"NO3 333\", content: \"333\", }, ], }; } render() { // 最原始方法 // let listArr = []; // for(let i = 0; i \u003c this.state.list.length; i++) { // let item = ( // \u003cul\u003e // \u003cli\u003e\u003ch3\u003e{this.state.list[i].title}\u003c/h3\u003e\u003c/li\u003e // \u003cli\u003e\u003ch5\u003e{this.state.list[i].content}\u003c/h5\u003e\u003c/li\u003e // \u003c/ul\u003e // ) // listArr.push(item); // } // 使用數組 map 方法，對每一項數據進行 JSX 的形式進行加工， // 最終得到 1 個每一項都是 JSX 對象的數組，將數組渲染到模板。 // Key 需要放入每一項中 let listArr = this.state.list.map((item, index) =\u003e { return ( // \u003cli key={index}\u003e // \u003ch3\u003e{index} : { item.title }\u003c/h3\u003e // \u003cp\u003e{ item.content }\u003c/p\u003e // \u003c/li\u003e // \u003cListItem data={item} index={index} key={index} /\u003e \u003cListItem2 data={item} index={index} key={index} /\u003e ); }); return ( \u003cdiv\u003e {/* 最原始方式 */} {/* {listArr} */} \u003cul\u003e{listArr}\u003c/ul\u003e \u003c/div\u003e ); } } ReactDOM.render(\u003cWelcome /\u003e, document.querySelector(\"#root\")); ","date":"2020-08-05","objectID":"/react_learn_note/:5:8","tags":["React","前端","npm","JSX","JS","Redux","ReactRouter","Web"],"title":"React 學習筆記 - JSX、組件、渲染、路由、Redux","uri":"/react_learn_note/"},{"categories":["前端"],"content":"組件生命週期 組件從實例化到最終從頁面銷毀，整個過程就是生命週期，在這生命週期中，我們有許多可以調用的方法，俗稱鉤子函數。 三個狀態 Mounting 將組件插入到 DOM 中 Updating 將數據更新到 DOM 中 UnMounting 將組件移除 DOM 生命周其中的鉤子函數（方法、事件） ComponentWillMount：組件將要渲染（已過時，不能用） ComponentDidMount：組件渲染完畢 ComponentWillReceiveProps：組件將要接受 props 數據（已過時，不能用） ShouldComponentUpdate：組件接收到新的 state 或是 props，判斷是否更新，返回布爾值 ComponentWillUpdate：組件將要更新（已過時，不能用） ComponentDidUpdate：組件已經更新完畢 ComponentWillUnMount：組件將要卸載 // 可以解構 // 這樣就不用每次都寫 react.Component import { Component } from 'react' class ComLife extends Component { constructor(props) { super(props) // 調用繼承 Component 的 構造函數 this.state = { msg: \"hello world msg\" } console.log(\"constructor 構造函數\") } componentWillMount() { // 已過時 // 通常用來 ajax 請求 // 添加動畫前的類 console.log(\"ComponentWillMount 組件將要渲染\") } componentDidMount() { // 用來渲染動畫 console.log(\"ComponentDidMount 組件渲染完畢\") } componentWillReceiveProps() { // 已過時 // 用來查看 props 內容是什麼 console.log(\"ComponentWillReceiveProps 組件將要接受 props 數據\") } componentWillUpdate() { // 已過時 console.log(\"ComponentWillUpdate 組件將要更新\") } componentDidUpdate() { console.log(\"ComponentDidUpdate 組件已經更新完畢\") } componentWillUnmount() { console.log(\"ComponentWillUnMount 組件將要卸載\") } render() { console.log(\"render 渲染函數\") return ( \u003cdiv\u003e \u003ch1\u003ehello\u003c/h1\u003e \u003c/div\u003e ) } } ","date":"2020-08-05","objectID":"/react_learn_note/:5:9","tags":["React","前端","npm","JSX","JS","Redux","ReactRouter","Web"],"title":"React 學習筆記 - JSX、組件、渲染、路由、Redux","uri":"/react_learn_note/"},{"categories":["前端"],"content":"插槽 組件中寫入內容，這些內容可以被識別和控制。React 需要自己開發支持插槽功能。 原理：組件中寫入的 HTML，可以傳入到 props 中。 註：這裡的 data-{ name } 是 HTML 中自定義屬性。e.g. 下面例子中的 data-position 和 data-index。 // 組件中寫入內容，這些內容可以被識別和控制。React 需要自己開發支持插槽功能 // 原理：組件中寫入的 HTML，可以傳入到 props 中 class ParentCom extends React.Component { constructor(props) { super(props); this.state = { arr: [1, 2, 3], }; } render() { console.log(this.props); return ( \u003cdiv\u003e \u003ch1\u003e組件插槽\u003c/h1\u003e {this.props.children} \u003cChildCom\u003e \u003ch1 data-position=\"header\"\u003e這是放置到頭部的內容\u003c/h1\u003e \u003ch1 data-position=\"main\"\u003e這是放置到主要的內容\u003c/h1\u003e \u003ch1 data-position=\"footer\"\u003e這是放置到尾部的內容\u003c/h1\u003e \u003c/ChildCom\u003e \u003c/div\u003e ); } } class ChildCom extends React.Component { render() { let headerCom, mainCom, footerCom; this.props.children.forEach((item, index) =\u003e { if (item.props[\"data-position\"] === \"header\") { headerCom = item; } else if (item.props[\"data-position\"] === \"main\") { mainCom = item; } else { footerCom = item; } }); return ( \u003cdiv\u003e \u003cdiv className=\"header\"\u003e{headerCom}\u003c/div\u003e \u003cdiv className=\"main\"\u003e{mainCom}\u003c/div\u003e \u003cdiv className=\"footer\"\u003e{footerCom}\u003c/div\u003e \u003c/div\u003e ); } } class RootCom extends React.Component { render() { return ( \u003cParentCom\u003e {/* 插槽 */} {/* 添加 data 屬性可以傳參，data- 後面接想要取的屬性名 */} \u003ch2 data-name=\"a\" data-index={this.state.arr[0]}\u003e 子組件一 \u003c/h2\u003e \u003ch2 data-name=\"b\" data-index={this.state.arr[1]}\u003e 子組件二 \u003c/h2\u003e \u003ch2 data-name=\"c\" data-index={this.state.arr[2]}\u003e 子組件三 \u003c/h2\u003e \u003c/ParentCom\u003e ); } } ReactDOM.render(\u003cRootCom /\u003e, document.querySelector(\"#root\")); ","date":"2020-08-05","objectID":"/react_learn_note/:5:10","tags":["React","前端","npm","JSX","JS","Redux","ReactRouter","Web"],"title":"React 學習筆記 - JSX、組件、渲染、路由、Redux","uri":"/react_learn_note/"},{"categories":["前端"],"content":"React Router 路由 根據不同的路徑，顯示不同的組件(內容)，React 使用庫 react-router-dom。 ","date":"2020-08-05","objectID":"/react_learn_note/:6:0","tags":["React","前端","npm","JSX","JS","Redux","ReactRouter","Web"],"title":"React 學習筆記 - JSX、組件、渲染、路由、Redux","uri":"/react_learn_note/"},{"categories":["前端"],"content":"安裝 npm install react-router-dom ","date":"2020-08-05","objectID":"/react_learn_note/:6:1","tags":["React","前端","npm","JSX","JS","Redux","ReactRouter","Web"],"title":"React 學習筆記 - JSX、組件、渲染、路由、Redux","uri":"/react_learn_note/"},{"categories":["前端"],"content":"使用 ReactRouter 三大組件 Router：所有路由組件的根組件(底層組件)，包裏路由規則的最外層容器 Route：路由規則匹配組件，顯示當前規則對應的組件 Link：路由跳轉組件 注意：如果要精準匹配，那麼可以在 route 上設置 exact 屬性。精準匹配的意思就是完整路徑包含父路徑。 Hash 與 History 模式，Hash 就是有 ‘#’ 符號，我們使用 History。 引入 // hash 模式 // as 是取別名 // import { HashRouter as router, Link, Route } from 'react-router-dom' // History 模式 / 後端匹配使用 import { BrowserRouter as Router, Link, Route } from \"react-router-dom\"; 基本使用 \u003cLink\u003e\u003c/Link\u003e 相當於 Vue 中的 \u003croute-link\u003e\u003c/route-link\u003e，用於路由跳轉。 \u003cRouter\u003e\u003c/Router\u003e 路由配置，可以設置基本路徑（Base Path），裡面包 \u003cRoute\u003e\u003c/Route\u003e，\u003cRoute\u003e\u003c/Route\u003e是路由，component 指定路由對應的組件。 \u003cLink replace\u003e\u003c/Link\u003e 的 replace 屬性可以進行路由的取代替換，取代當前瀏覽器路由地址並跳轉。 動態路由：\u003cRoute path=\"/news/:id\" component={News}\u003e\u003c/Route\u003e。 function Home(params) { return ( \u003cdiv\u003e \u003ch1\u003eadmin首頁\u003c/h1\u003e \u003c/div\u003e ); } function Me(params) { console.log(params); return ( \u003cdiv\u003e \u003ch1\u003eadmin個人頁面\u003c/h1\u003e \u003c/div\u003e ); } function Product(params) { return ( \u003cdiv\u003e \u003ch1\u003eadmin產品頁面\u003c/h1\u003e \u003c/div\u003e ); } function News(params) { console.log(params) return ( \u003cdiv\u003e 新聞頁 新聞 id: {params.match.params.id} \u003c/div\u003e ) } class App extends React.Component { render() { // 這裡的 search 是 query string // 可以傳 state let meObj = { pathname: \"/me\", // 路徑 search: \"?username=admin\", // get 請求參數 hash: \"#abc\", // 設置 hash 錨值 state: { msg: \"helloWorld\" }, // 傳入組件的數據 }; return ( \u003cdiv id=\"app\"\u003e {/* 全局 */} \u003cdiv\u003e所有頁面都顯示的內容\u003c/div\u003e {/* Router 可以在一個組件中寫多個 */} {/* \u003cRouter\u003e \u003cRoute path=\"/\" exact component={() =\u003e (\u003cdiv\u003e首頁\u003c/div\u003e)}\u003e\u003c/Route\u003e \u003cRoute path=\"/me\" component={() =\u003e (\u003cdiv\u003eme\u003c/div\u003e)}\u003e\u003c/Route\u003e \u003cRoute path=\"/product\" component={() =\u003e (\u003cdiv\u003eproduct\u003c/div\u003e)}\u003e\u003c/Route\u003e \u003c/Router\u003e */} {/* Router 設置基礎路徑 basename */} \u003cRouter basename=\"/admin\"\u003e \u003cdiv className=\"nav\"\u003e \u003cLink to=\"/\"\u003e首頁\u003c/Link\u003e \u003cLink to=\"/product\"\u003e產品\u003c/Link\u003e {/* Link 可以設置 to 屬性進行頁面跳轉，to 屬性可以直接寫路徑的字符串，也可以通過 1 個對象，進行路進的配置 */} {/* replace 屬性 將新地址制換成歷史訪問紀錄的原地址 */} \u003cLink to={meObj} replace\u003e個人中心\u003c/Link\u003e {/* 動態路由 */} \u003cLink to=\"/news/456789\"\u003enews\u003c/Link\u003e \u003c/div\u003e \u003cRoute path=\"/\" exact component={Home}\u003e\u003c/Route\u003e \u003cRoute path=\"/product\" exact component={Product}\u003e\u003c/Route\u003e \u003cRoute path=\"/me\" exact component={Me}\u003e\u003c/Route\u003e {/* 動態路由 */} \u003cRoute path=\"/news/:id\" component={News}\u003e\u003c/Route\u003e \u003c/Router\u003e \u003c/div\u003e ); } } export default App; 重定向組件與 Switch 組件 重定向組件：如果訪問某個組件時，如果有重定向組件，那麼就會修改頁面路徑，使得頁面內容顯示為所定向路徑的內容。 Switch 組件：讓 Switch 組件內容的 Route 只匹配一個，只要匹配到了，剩餘的規則就不再匹配。 建議配置路由時要使用 Switch 組件，這樣路由的配置邏輯比較謹慎。 // 重定向組件 // 如果訪問某個組件時，如果有重定向組件，那麼就會修改頁面路徑，使得頁面內容顯示為所定向路徑的內容 // Switch 組件 // 讓 Switch 組件內容的 Route 只匹配一個，只要匹配到了，剩餘的規則就不再匹配 import { Redirect, Switch } from \"react-router-dom\"; function LoginInfo(params) { // params.loginSuccess = 'success' // params.loginSuccess = 'fail if (params.location.state.loginState === \"success\") { return ( // 重定向組件 \u003cRedirect to=\"/admin\"\u003e\u003c/Redirect\u003e ); } else { return \u003cRedirect to=\"/login\"\u003e\u003c/Redirect\u003e; } } let formCom = () =\u003e { let pathObj = { pathname: \"/loginInfo\", state: { loginState: \"success\", }, }; return ( \u003cdiv\u003e \u003ch1\u003e表單驗證\u003c/h1\u003e \u003cLink to={pathObj}\u003e登入後表單驗證\u003c/Link\u003e \u003c/div\u003e ); }; class ChildCom extends React.Component { constructor(props) { super(props); } render() { return ( \u003cdiv\u003e \u003cbutton onClick={this.clickEvent}\u003e跳轉到首頁\u003c/button\u003e \u003c/div\u003e ); } clickEvent = () =\u003e { console.log(this.props); // 可以傳值 // this.props.history.push(\"/\", {msg: \"這是由 ChildCom 發給首頁的數據\"}) // this.props.history.replace(\"/\", {msg: \"這是由 ChildCom 發給首頁的數據\"}) // 前進 this.props.history.go(1); this.props.history.goForward(); // 後退 this.props.history.go(-1); this.props.history.goBack(); }; } class App extends React.Component { render() { return ( \u003cdiv\u003e \u003cRouter\u003e \u003cSwitch\u003e \u003cRoute path=\"/\" exact component={(props) =\u003e { console.log(props); return \u003ch1\u003e首頁\u003c/h1\u003e; }} \u003e\u003c/Route\u003e \u003cRoute path=\"/form\" exact component={formCom}\u003e\u003c/Route\u003e \u003cRoute path=\"/login\" exact component={() =\u003e \u003ch1\u003e登入頁\u003c/h1\u003e} \u003e\u003c/Route\u003e \u003cRoute path=\"/loginInfo\" exact component={LoginInfo}\u003e\u003c/Route\u003e \u003cRoute path=\"/admin\" exact component={() =\u003e \u003ch1\u003eAdmin\u003c/h1\u003e}\u003e\u003c/Route\u003e {/* Router 會全部匹配，所以如果有兩個相同的 path 會兩個都匹配 */} {/* 所以需要用到 Switch 去匹配，匹配到一個成功就不會繼續匹配 */} \u003cRoute path=\"/abc\" exact component={() =\u003e \u003ch1\u003eabc1\u003c/h1\u003e}\u003e\u003c/Route\u003e \u003cRoute path=\"/","date":"2020-08-05","objectID":"/react_learn_note/:6:2","tags":["React","前端","npm","JSX","JS","Redux","ReactRouter","Web"],"title":"React 學習筆記 - JSX、組件、渲染、路由、Redux","uri":"/react_learn_note/"},{"categories":["前端"],"content":"狀態管理 解決 React 數據管理（狀態管理），用於中大型項目，數據量龐大，組件之間數據交互較多的情況下使用。 如果你不知道是否需要使用 Redux ，那麼你就不需要用他。Redux 是個給 JavaScript 應用程式所使用的可預測 state 容器，Redux 跟 React 並沒有關係，你可以用 React、Angular、Ember、jQuery 或甚至原生 JavaScript 來撰寫 Redux 應用程式。 功能 解決組件的數據通信 解決數據和交互較多的應用 ","date":"2020-08-05","objectID":"/react_learn_note/:7:0","tags":["React","前端","npm","JSX","JS","Redux","ReactRouter","Web"],"title":"React 學習筆記 - JSX、組件、渲染、路由、Redux","uri":"/react_learn_note/"},{"categories":["前端"],"content":"redux 安裝 npm install --save redux 工具 store: 數據倉庫，保存數據的地方 State: state 是一個對象，這個對象包含整個應用所需要的數據 Action: 一個動作，觸發數據改變的方法 Dispatch: 將動作觸發成方法 Reducer: 是一個函數，通過獲取動作，改變數據，生成一個新的狀態，從而改變頁面 使用 import { createStore } from \"redux\"; // 用於通過動作，創建新的 state // reduce 有兩個作用，一個釋初始化數據，第二個是通過獲取動作，改變數據 const reducer = function (state = { num: 0 }, action) { switch (action.type) { case \"add\": state.num++; break; case \"decrement\": state.num--; break; default: break; } return { ...state }; // 相當於對象的 COPY }; // 創建倉庫 const store = createStore(reducer); function add() { // 通過倉庫的方法 dispatch 進數據修改 // dispatch 觸發 reducer store.dispatch({ type: \"add\" }); console.log(store.getState()); } function decrement() { store.dispatch({ type: \"decrement\" }); console.log(store.getState()); } const Counter = function () { let state = store.getState(); return ( \u003cdiv\u003e \u003ch1\u003e計數數量：{state.num}\u003c/h1\u003e \u003cbutton onClick={add}\u003e+1\u003c/button\u003e \u003cbutton onClick={decrement}\u003e-1\u003c/button\u003e \u003c/div\u003e ); }; ReactDOM.render(\u003cCounter /\u003e, document.querySelector(\"#root\")); // 監聽數據變化，重新渲染 // 當數據改變時觸發 store.subscribe(() =\u003e { ReactDOM.render(\u003cCounter /\u003e, document.querySelector(\"#root\")); }); ","date":"2020-08-05","objectID":"/react_learn_note/:7:1","tags":["React","前端","npm","JSX","JS","Redux","ReactRouter","Web"],"title":"React 學習筆記 - JSX、組件、渲染、路由、Redux","uri":"/react_learn_note/"},{"categories":["前端"],"content":"react-redux react-redux 是 redux 的擴展套件，用來綁定 redux。 安裝 npm install --save react-redux 工具 Provider：自動將 store 裡的 state 和組件進行關聯 connect：將數據倉庫的 state 和修改 state 的方法映射到組件上，形成新的組件 使用 import { createStore } from \"redux\"; import { Provider, connect } from 'react-redux' class Counter extends React.Component { render() { // 計數，通過 store 的 state 傳給 props，直接通過 props 就可以將 state 的數據獲取 const value = this.props.value; // 將修改數據的事件或者方法傳入到 props const onAddClick = this.props.onAddClick; // 等同於 VueX 的 mapMutation mapState return ( \u003cdiv\u003e \u003ch1\u003e計數數量：{value}\u003c/h1\u003e \u003cbutton onClick={onAddClick}\u003e+1\u003c/button\u003e \u003c/div\u003e ) } } // 動作 const addAction = { type: 'add' } const reducer = function (state = { num: 0 }, action) { switch (action.type) { case \"add\": state.num++; break; case \"decrement\": state.num--; break; default: break; } return { ...state }; // 相當於對象的 COPY }; const store = createStore(reducer); // 將 state 映射到 props 函數 function mapStateToProps(state) { return { value: state.num } } // 將修改 state 數據的方法，映射到 props，默認會傳入 store 裡的 dispatch 方法 function mapDispatchToProps(dispatch) { return { onAddClick: () =\u003e { dispatch(addAction) } } } // 將上面的這兩個方法，將數據倉庫的 state 和修改 state 的方法映射到組件上，形成新的組件 const NewApp = connect( mapStateToProps, mapDispatchToProps )(Counter) // Provider 組件：自動將 store 裡的 state 和組件進行關聯 ReactDOM.render( \u003cProvider store={store}\u003e \u003cNewApp\u003e\u003c/NewApp\u003e \u003c/Provider\u003e, document.querySelector(\"#root\") ) ","date":"2020-08-05","objectID":"/react_learn_note/:7:2","tags":["React","前端","npm","JSX","JS","Redux","ReactRouter","Web"],"title":"React 學習筆記 - JSX、組件、渲染、路由、Redux","uri":"/react_learn_note/"},{"categories":["前端"],"content":"Reference 2020最新前端_React实战教学【老陈打码】- BiliBili React Create React App - Github Redux ","date":"2020-08-05","objectID":"/react_learn_note/:8:0","tags":["React","前端","npm","JSX","JS","Redux","ReactRouter","Web"],"title":"React 學習筆記 - JSX、組件、渲染、路由、Redux","uri":"/react_learn_note/"},{"categories":["Python"],"content":"前言 關於 Flask 跨域接收請求的設置真的蠻好配置的，我想並不難，但我還是稍微寫一下，避免新手不知道怎麼做。 ","date":"2020-08-05","objectID":"/flask_cors/:1:0","tags":["Python","Flask","CORS","跨域","Web"],"title":"Flask 跨域設置","uri":"/flask_cors/"},{"categories":["Python"],"content":"安裝 跨域有 flask_cors 這個工具。 pip install flask_cors ","date":"2020-08-05","objectID":"/flask_cors/:2:0","tags":["Python","Flask","CORS","跨域","Web"],"title":"Flask 跨域設置","uri":"/flask_cors/"},{"categories":["Python"],"content":"配置 from flask import Flask, jsonify, request from flask_cors import CORS app = Flask(__name__) # enable CORS CORS(app) if __name__ == \"__main__\": app.run(debug=True) ","date":"2020-08-05","objectID":"/flask_cors/:3:0","tags":["Python","Flask","CORS","跨域","Web"],"title":"Flask 跨域設置","uri":"/flask_cors/"},{"categories":["Python"],"content":"前言 因為我寫的上一篇文章是\"Flask 中使用 MySQL\"，文章內容有提及 JWT 的使用，這篇就是寫一下我在 JWT 上的使用。 ","date":"2020-08-05","objectID":"/flask_jwt/:1:0","tags":["Python","Flask","JWT","Token","Web"],"title":"Flask 中使用 JWT","uri":"/flask_jwt/"},{"categories":["Python"],"content":"Cookie Session Cookie 和 LocalStorage 最大的區別是 Cookie 可以設置時效性，而LocalStorage 不行。 在 JWT 授權認證技術還沒出來之前，我們是使用 Cookie 和 Session 來做驗證，分別是前端（Front End）和後端（Back End）的本地存儲。過程如下： ","date":"2020-08-05","objectID":"/flask_jwt/:2:0","tags":["Python","Flask","JWT","Token","Web"],"title":"Flask 中使用 JWT","uri":"/flask_jwt/"},{"categories":["Python"],"content":"JWT ","date":"2020-08-05","objectID":"/flask_jwt/:3:0","tags":["Python","Flask","JWT","Token","Web"],"title":"Flask 中使用 JWT","uri":"/flask_jwt/"},{"categories":["Python"],"content":"理論部份 因為 Cookie Session 這種方式太過繁瑣，所以出來了 JWT 這樣的技術，原名 (JSON Web Tokens)，就是帶時效的 Token。主要差別是，Server 端不需要存 Session，大致情形如下： JWT 主要分為三段，個別為 header、payload 與 signature，中間以 . 做區隔，每一段都是透過 Base64Url 去編碼，中間的 payload 有時候會加密。 e.g. eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9. eyJlbWFpbCI6Imhpcm9AZ21haWwuY29tIn0. WAKjPd_0qcEG3dA9pEwAiw-0ADb8VwqFlSWiIYJTymo header 存放 token 型別與加密方式 。 { \"alg\": \"HS256\", // 加密方式 \"typ\": \"JWT\" // token 型別 } payload 存放需要傳遞的訊息。因為只透過編碼轉換「未經過加密」，不建議在裡面放重要資訊。 另外官方有提供一些可以用的屬性大概分為： iss: 發行人 exp: 到期日 sub: 主題 aud: 收件人 nbf: 不接受早於…日期/時間 iat: 發行時間 jti: 唯一識別符，JWT 只能使用一次 signature 最後的部分，有點像是我們平常買東西條碼上最後的檢查碼，首先會先取得 header 裡的加密方式 SHA256，再透過以下方式產生： HMACSHA256( base64UrlEncode(header) + \".\" + base64UrlEncode(payload), secret ) secret 則是可以打上自己要打的，最後一樣會轉換成 Base64Url： 再把三段加在一起就算是 JWT 了！ ","date":"2020-08-05","objectID":"/flask_jwt/:3:1","tags":["Python","Flask","JWT","Token","Web"],"title":"Flask 中使用 JWT","uri":"/flask_jwt/"},{"categories":["Python"],"content":"使用時機 JWT 的主要目的只是「 確立資料來源以及可信度 」。因此在應用上也會限制較多。以下是較常被使用的時機： 跨伺服器下的請求 可以參考運作原理的圖，如果我們同時擁有許多伺服器，可以把身份驗證伺服器獨立出來，登入後使用 JWT 就可以在不同伺服器遊走。 一次性、時效短的請求 因為 JWT 不能主動撤銷，一般用於會員身份驗證會不太適合，多用於一次性下載檔案，或是時間限制內更改密碼等等… APP 身份驗證 一般 APP 是不存在 Session 的，所以在持續身份驗證上可以使用 JWT，但要確保使用者的執行環境是安全的 ","date":"2020-08-05","objectID":"/flask_jwt/:3:2","tags":["Python","Flask","JWT","Token","Web"],"title":"Flask 中使用 JWT","uri":"/flask_jwt/"},{"categories":["Python"],"content":"實作部份 安裝 pip install flask-jwt-extended 引入與基本使用 為了快速了解怎麼用，例子中只會顯示重要核心代碼。 注意點： @jwt_required 裝飾器是用來判斷請求 Header 是否帶有 Token。 下面例子的 /login 使用 create_access_token() 生成 Token。 /protected 是獲取放在 請求 Header 的 Token 判是否正確，相對的，可以看 /user/update/phone。 前端請求需要在 Header 添加 Authorization: Bearer \u003caccess_token\u003e，關於 Axios 怎麼在請求 Header 添加 Token 我之前有在 Vue 技巧與經驗 這篇文章的請求部份寫到。 生成 Token 的依據（identity）不能是密碼，可以是 UserName 或是 UserID。 一般 Token 的時效是 15 分鐘左右，如果想要延長可以設置。 get_jwt_identity() 獲取之前 Token 生成依據的內容。 from flask import Flask, jsonify, request # 引入 JWT from flask_jwt_extended import ( JWTManager, jwt_required, create_access_token, get_jwt_identity ) app = Flask(__name__) # Setup the Flask-JWT-Extended extension app.config['JWT_SECRET_KEY'] = 'super-secret' # Change this! jwt = JWTManager(app) # ... # Provide a method to create access tokens. The create_access_token() # function is used to actually generate the token, and you can return # it to the caller however you choose. # 用戶登入 @app.route('/user/login', methods=['GET', 'POST']) def user_login(): if request.method == 'POST': response_object = {'status': 'success'} response_object['code'] = 200 requestEmail = request.form.get('email') requestPassword = request.form.get('password') sqlSearchResult = [] # 查詢資料庫 cursor.execute( \"SELECT id, username, email, password FROM user WHERE email = %s;\", (requestEmail,)) for (id, username, email, password) in cursor: sqlSearchResult.append({ \"id\": id, \"username\": username, \"email\": email, \"password\": password }) # md5 加密轉換 transferPassword = hashlib.md5(requestPassword.encode()) print(transferPassword.hexdigest()) print(sqlSearchResult) # 如果沒有資料 if cursor.rowcount \u003c 1: response_object['message'] = 'This Account not exist.' response_object['data'] = False # 如果有資料 else: # 如果密碼正確 if str(transferPassword.hexdigest()) == str(sqlSearchResult[0]['password']): print('password: ' + password + ', resultPWD: ' + sqlSearchResult[0]['password']) response_object['message'] = 'Sign in success.' response_object['data'] = True response_object['user_id'] = sqlSearchResult[0]['id'] # Identity can be any data that is json serializable # 產生 jwt_token, 並將 token 的 expires 取消 response_object['jwt_token'] = create_access_token( identity=sqlSearchResult[0]['id'], expires_delta=False) else: response_object['message'] = 'Password is not true.' response_object['data'] = False return jsonify(response_object) # Protect a view with jwt_required, which requires a valid access token # in the request to access. @app.route('/protected', methods=['GET']) @jwt_required def protected(): # Access the identity of the current user with get_jwt_identity current_user = get_jwt_identity() return jsonify(logged_in_as=current_user), 200 # 修改更新用戶 phone 資料 # 這裡前端要先判斷輸入的新 Phone 是否跟原本的一樣，如果相同就不准請求 @app.route(\"/user/update/phone\", methods=['GET', 'POST']) @jwt_required def user_update_phone(): if request.method == 'POST': response_object = {'status': 'success'} response_object['code'] = 200 # 請求資料 requestId = request.form.get('id') requestPhone = request.form.get('phone') # 驗證 jwt_token current_user = get_jwt_identity() # 驗證失敗 回傳失敗 if not current_user: response_object['message'] = 'anonymous user' response_object['data'] = False return jsonify(response_object) # 用 id 查詢用戶的 phone cursor.execute( \"SELECT id, phone FROM user WHERE id = %s;\", (requestId,)) # 有找到資料 if cursor.rowcount \u003e 0: # 更新資料 sql = \"UPDATE user SET phone = %sWHERE id = %s;\" cursor.execute(sql, (requestPhone, requestId)) # 確認資料有存入資料庫 connection.commit() response_object['message'] = 'Update phone success.' response_object['data'] = True # 沒有找到資料 else: response_object['message'] = 'Update phone fail.' response_object['data'] = False return jsonify(response_object) if __name__ == '__main__': app.run() ","date":"2020-08-05","objectID":"/flask_jwt/:3:3","tags":["Python","Flask","JWT","Token","Web"],"title":"Flask 中使用 JWT","uri":"/flask_jwt/"},{"categories":["Python"],"content":"部份保護 route @jwt_required 裝飾器是該 route 接收到的請求 Header 必須要有 JWT Token，jwt_optional() 裝飾器，可以使需要保護的數據與不被保護的數據同時在 route 中使用（官方說法），但跟 @jwt_required 裝飾器一樣是 Token 如果失效會回傳失效訊息。 from flask import Flask, jsonify, request from flask_jwt_extended import ( JWTManager, jwt_optional, create_access_token, get_jwt_identity ) app = Flask(__name__) # Setup the Flask-JWT-Extended extension app.config['JWT_SECRET_KEY'] = 'super-secret' # Change this! jwt = JWTManager(app) @app.route('/login', methods=['POST']) def login(): username = request.json.get('username', None) password = request.json.get('password', None) if not username: return jsonify({\"msg\": \"Missing username parameter\"}), 400 if not password: return jsonify({\"msg\": \"Missing password parameter\"}), 400 if username != 'test' or password != 'test': return jsonify({\"msg\": \"Bad username or password\"}), 401 access_token = create_access_token(identity=username) return jsonify(access_token=access_token), 200 @app.route('/partially-protected', methods=['GET']) @jwt_optional def partially_protected(): # If no JWT is sent in with the request, get_jwt_identity() # will return None current_user = get_jwt_identity() if current_user: return jsonify(logged_in_as=current_user), 200 else: return jsonify(logged_in_as='anonymous user'), 200 if __name__ == '__main__': app.run() ","date":"2020-08-05","objectID":"/flask_jwt/:3:4","tags":["Python","Flask","JWT","Token","Web"],"title":"Flask 中使用 JWT","uri":"/flask_jwt/"},{"categories":["Python"],"content":"黑名單（Black List） 應用場景是當我們之前的 Token 錯誤或失效（如果有設置自動登入，一般 Token 會設置 7 天有效），或是登出、重新登入、登入等，都需要將舊的 Token 加入黑名單。 from flask import Flask, request, jsonify from flask_jwt_extended import ( JWTManager, jwt_required, get_jwt_identity, create_access_token, create_refresh_token, jwt_refresh_token_required, get_raw_jwt ) # Setup flask app = Flask(__name__) # Enable blacklisting and specify what kind of tokens to check # against the blacklist app.config['JWT_SECRET_KEY'] = 'super-secret' # Change this! app.config['JWT_BLACKLIST_ENABLED'] = True app.config['JWT_BLACKLIST_TOKEN_CHECKS'] = ['access', 'refresh'] jwt = JWTManager(app) # A storage engine to save revoked tokens. In production if # speed is the primary concern, redis is a good bet. If data # persistence is more important for you, postgres is another # great option. In this example, we will be using an in memory # store, just to show you how this might work. For more # complete examples, check out these: # https://github.com/vimalloc/flask-jwt-extended/blob/master/examples/redis_blacklist.py # https://github.com/vimalloc/flask-jwt-extended/tree/master/examples/database_blacklist blacklist = set() # For this example, we are just checking if the tokens jti # (unique identifier) is in the blacklist set. This could # be made more complex, for example storing all tokens # into the blacklist with a revoked status when created, # and returning the revoked status in this call. This # would allow you to have a list of all created tokens, # and to consider tokens that aren't in the blacklist # (aka tokens you didn't create) as revoked. These are # just two options, and this can be tailored to whatever # your application needs. @jwt.token_in_blacklist_loader def check_if_token_in_blacklist(decrypted_token): jti = decrypted_token['jti'] return jti in blacklist # Standard login endpoint @app.route('/login', methods=['POST']) def login(): username = request.json.get('username', None) password = request.json.get('password', None) if username != 'test' or password != 'test': return jsonify({\"msg\": \"Bad username or password\"}), 401 ret = { 'access_token': create_access_token(identity=username), 'refresh_token': create_refresh_token(identity=username) } return jsonify(ret), 200 # Standard refresh endpoint. A blacklisted refresh token # will not be able to access this endpoint @app.route('/refresh', methods=['POST']) @jwt_refresh_token_required def refresh(): current_user = get_jwt_identity() ret = { 'access_token': create_access_token(identity=current_user) } return jsonify(ret), 200 # Endpoint for revoking the current users access token @app.route('/logout', methods=['DELETE']) @jwt_required def logout(): jti = get_raw_jwt()['jti'] blacklist.add(jti) return jsonify({\"msg\": \"Successfully logged out\"}), 200 # Endpoint for revoking the current users refresh token @app.route('/logout2', methods=['DELETE']) @jwt_refresh_token_required def logout2(): jti = get_raw_jwt()['jti'] blacklist.add(jti) return jsonify({\"msg\": \"Successfully logged out\"}), 200 # This will now prevent users with blacklisted tokens from # accessing this endpoint @app.route('/protected', methods=['GET']) @jwt_required def protected(): return jsonify({'hello': 'world'}) if __name__ == '__main__': app.run() ","date":"2020-08-05","objectID":"/flask_jwt/:3:5","tags":["Python","Flask","JWT","Token","Web"],"title":"Flask 中使用 JWT","uri":"/flask_jwt/"},{"categories":["Python"],"content":"Reference Flask-JWT-Extended’s Documentation 淺談 Session 與 JWT 差異 ","date":"2020-08-05","objectID":"/flask_jwt/:4:0","tags":["Python","Flask","JWT","Token","Web"],"title":"Flask 中使用 JWT","uri":"/flask_jwt/"},{"categories":["Python"],"content":"前言 我一開始學 Flask 時是看 Flask 的官方教學學的，不得不說Flask 官方文檔寫得很好。因為 Flask 官方教學是使用 Sqlite 做為數據庫，但是我想要使用 MySQL，在自己網上搜索，加上自己的鑽研手做，這裡紀錄我摸索的結果。因為我偏好使用原生 SQL 語法，所以下面的數據庫操作都是原生語句，例子也是我之前做的某個項目裡面拿出來的。 ","date":"2020-08-04","objectID":"/flask_mysql/:1:0","tags":["Python","Flask","MySQL","Database","數據庫","Web"],"title":"Flask 中使用 MySQL","uri":"/flask_mysql/"},{"categories":["Python"],"content":"安裝 pip install mysql-connector-python ","date":"2020-08-04","objectID":"/flask_mysql/:2:0","tags":["Python","Flask","MySQL","Database","數據庫","Web"],"title":"Flask 中使用 MySQL","uri":"/flask_mysql/"},{"categories":["Python"],"content":"引入、連接數據庫 因為是 MySQL，所以自己要在自己的電腦本地數據庫寫好要用的數據庫。下面的連接參數要自己改。 import mysql.connector from mysql.connector import Error # 連接 MySQL 資料庫 connection = mysql.connector.connect( host='localhost', # 主機名稱 database='myTelegram', # 資料庫名稱 user='Rem', # 帳號 password='') # 密碼 cursor = connection.cursor(buffered=True) cursor.execute(\"SELECT DATABASE();\") record = cursor.fetchone() ","date":"2020-08-04","objectID":"/flask_mysql/:3:0","tags":["Python","Flask","MySQL","Database","數據庫","Web"],"title":"Flask 中使用 MySQL","uri":"/flask_mysql/"},{"categories":["Python"],"content":"CRUD CRUD 就是 Create（新增）、Read（讀取）、Update（更新）、Delete（刪除），數據庫基本操作。 ","date":"2020-08-04","objectID":"/flask_mysql/:4:0","tags":["Python","Flask","MySQL","Database","數據庫","Web"],"title":"Flask 中使用 MySQL","uri":"/flask_mysql/"},{"categories":["Python"],"content":"Create 新增 以註冊帳戶並驗證完 Email Captcha 後，將帳戶資料增入 Database 為例子。這裡的設計概念是註冊後不會將帳戶資料寫入數據庫，註冊完會將暫時的帳戶資料存到數據庫，註冊的下一步是驗證 Email，驗證完發送到 Email 的 Captcha 就可以存入數據庫。關於發送 Email，我會另外寫一篇文章。 註：因為 Flask 可以寫 Restful，所以會出現判斷請求方法是不是 POST 或是 GET，增加複用性。 from flask import Flask, jsonify, request from flask_cors import CORS import mysql.connector from mysql.connector import Error # 引入 string import string app = Flask(__name__) # enable CORS CORS(app) # 註冊 email 驗證後的緩存 registerTempData = { \"id\": \"\", \"username\": \"\", \"email\": \"\", \"phone\": \"\", \"password\": \"\", } # 全局驗證碼 captcha = 0 # 驗證 註冊的 Email @app.route(\"/user/validateEmail\", methods=['GET', 'POST']) def user_register_email_validate(): if request.method == 'POST': response_object = {'status': 'success'} response_object['code'] = 200 requestCaptcha = request.form.get('captcha') print(\"requestCaptcha: \" + str(requestCaptcha)) print(\"captcha: \" + str(captcha)) # 如果驗證碼相同 if str(requestCaptcha) == str(captcha): global registerTempData # 新增資料 sql = \"INSERT INTO user (id, username, email, phone, password) VALUES (%s, %s, %s, %s, %s);\" # 將緩存的註冊資料加入 new_data = (registerTempData[\"id\"], registerTempData[\"username\"], registerTempData[\"email\"], registerTempData[\"phone\"], registerTempData[\"password\"]) print(new_data) cursor = connection.cursor() cursor.execute(sql, new_data) # 確認資料有存入資料庫 connection.commit() response_object['message'] = 'Your account is activated!' response_object['data'] = True # 初始化 registerTempData = { \"id\": \"\", \"username\": \"\", \"email\": \"\", \"phone\": \"\", \"password\": \"\", } else: response_object['message'] = 'The captcha is not true!' response_object['data'] = False return jsonify(response_object) 上面的 Code 需要注意的地方是全局變量如果要在局部函數中使用，就需要使用 global 聲明全局變量，像上面例子的 global registerTempData ","date":"2020-08-04","objectID":"/flask_mysql/:4:1","tags":["Python","Flask","MySQL","Database","數據庫","Web"],"title":"Flask 中使用 MySQL","uri":"/flask_mysql/"},{"categories":["Python"],"content":"Read 讀取 ","date":"2020-08-04","objectID":"/flask_mysql/:5:0","tags":["Python","Flask","MySQL","Database","數據庫","Web"],"title":"Flask 中使用 MySQL","uri":"/flask_mysql/"},{"categories":["Python"],"content":"普通查詢 就是 “查\"，這裡以返回某帳戶資訊為例： 下面的 @jwt_optional 是關於 JWT 的使用，因為不在這文章的討論範疇，所以不會細講。 # 返回用戶資訊 @app.route(\"/user/getDetail\", methods=['GET', 'POST']) @jwt_optional def user_getDetail(): if request.method == 'POST': response_object = {'status': 'success'} response_object['code'] = 200 requestId = request.form.get('id') sqlSearchResult = [] # 驗證 jwt_token current_user = get_jwt_identity() # 驗證失敗 回傳失敗 if not current_user: response_object['message'] = 'anonymous user' response_object['data'] = False return jsonify(response_object) # 用 id 查詢用戶資訊 cursor.execute( \"SELECT id, username, email, phone, password FROM user WHERE id = %s;\", (requestId,)) for (id, username, email, phone, password) in cursor: sqlSearchResult.append({ \"id\": id, \"username\": username, \"email\": email, \"phone\": phone, \"password\": password }) print(sqlSearchResult) # 如果有資料 if cursor.rowcount \u003e 0: response_object['message'] = 'Searching is Success. Have Data' response_object['data'] = True # 將搜到的數據添入 response_object response_object.update({ 'userData': { 'id': sqlSearchResult[0]['id'], 'username': sqlSearchResult[0]['username'], 'email': sqlSearchResult[0]['email'], 'phone': sqlSearchResult[0]['phone'], 'password': sqlSearchResult[0]['password'] } }) # 如果沒有資料 else: response_object['message'] = 'There is not this account in the database.' response_object['data'] = False return jsonify(response_object) ","date":"2020-08-04","objectID":"/flask_mysql/:5:1","tags":["Python","Flask","MySQL","Database","數據庫","Web"],"title":"Flask 中使用 MySQL","uri":"/flask_mysql/"},{"categories":["Python"],"content":"模糊搜索 糊糊搜索最關鍵的地方就是如何將 Keyword 加入 SQL 語句，下面是個實際例子： # 模糊搜索 所有 channelType 是 group 的群 @app.route(\"/user/channels/searchChannels\", methods=['GET', 'POST']) @jwt_optional def user_channels_search_channels(): if request.method == 'POST': response_object = {'status': 'success'} response_object['code'] = 200 requestKeyword = request.form.get('keyword') sqlSearchResult = [] # 驗證 jwt_token current_user = get_jwt_identity() # 驗證失敗 回傳失敗 if not current_user: response_object['message'] = 'anonymous user' response_object['data'] = False return jsonify(response_object) # 用 keyword 模糊查詢 所有 channel (channelType = group) cursor.execute( \"SELECT id, channelType, adminId, channelName FROM channel WHERE channelType = 'group' \\ AND (id LIKE CONCAT('%', %s, '%') OR adminId LIKE CONCAT('%', %s, '%') OR \\ channelName LIKE CONCAT('%', %s, '%')) GROUP BY id;\", (requestKeyword, requestKeyword, requestKeyword)) for (id, channelType, adminId, channelName) in cursor: sqlSearchResult.append({ \"id\": id, \"channelType\": channelType, \"adminId\": adminId, \"channelName\": channelName, }) # 如果有 資料 if cursor.rowcount \u003e 0: response_object['message'] = 'Get the channel List success.' response_object['data'] = True # 將資料添加到 response_object response_object.update({ 'searchResult': sqlSearchResult }) # 沒有 message else: response_object['message'] = 'There is no data.' response_object['data'] = False return jsonify(response_object) ","date":"2020-08-04","objectID":"/flask_mysql/:5:2","tags":["Python","Flask","MySQL","Database","數據庫","Web"],"title":"Flask 中使用 MySQL","uri":"/flask_mysql/"},{"categories":["Python"],"content":"Update 更新 以些改某個帳戶資料為例 # 修改更新用戶 phone 資料 # 這裡前端要先判斷輸入的新 Phone 是否跟原本的一樣，如果相同就不准請求 @app.route(\"/user/update/phone\", methods=['GET', 'POST']) @jwt_optional def user_update_phone(): if request.method == 'POST': response_object = {'status': 'success'} response_object['code'] = 200 # 請求資料 requestId = request.form.get('id') requestPhone = request.form.get('phone') # 驗證 jwt_token current_user = get_jwt_identity() # 驗證失敗 回傳失敗 if not current_user: response_object['message'] = 'anonymous user' response_object['data'] = False return jsonify(response_object) # 用 id 查詢用戶的 phone cursor.execute( \"SELECT id, phone FROM user WHERE id = %s;\", (requestId,)) # 有找到資料 if cursor.rowcount \u003e 0: # 更新資料 sql = \"UPDATE user SET phone = %sWHERE id = %s;\" cursor.execute(sql, (requestPhone, requestId)) # 確認資料有存入資料庫 connection.commit() response_object['message'] = 'Update phone success.' response_object['data'] = True # 沒有找到資料 else: response_object['message'] = 'Update phone fail.' response_object['data'] = False return jsonify(response_object) ","date":"2020-08-04","objectID":"/flask_mysql/:6:0","tags":["Python","Flask","MySQL","Database","數據庫","Web"],"title":"Flask 中使用 MySQL","uri":"/flask_mysql/"},{"categories":["Python"],"content":"Delete 刪除 以刪除某帳戶為例： # 刪除帳戶 @app.route(\"/user/delete\", methods=['GET', 'POST']) @jwt_optional def user_delete_account(): if request.method == 'POST': response_object = {'status': 'success'} response_object['code'] = 200 # 請求資料 requestId = request.form.get('id') requestPassword = request.form.get('password') sqlSearchResult = [] # 驗證 jwt_token current_user = get_jwt_identity() # 驗證失敗 回傳失敗 if not current_user: response_object['message'] = 'anonymous user' response_object['data'] = False return jsonify(response_object) # 用請求 id 查詢該 id 是否存在 cursor.execute( \"SELECT id, username FROM user WHERE id = %s;\", (requestId,)) # 如果沒找到該 id if cursor.rowcount \u003c 1: response_object['message'] = 'This account is not exist.' response_object['data'] = False return jsonify(response_object) # 先判斷 requestPassword 是否跟原來的密碼相符 cursor.execute( \"SELECT id, password FROM user WHERE id = %s;\", (requestId,)) for (id, password) in cursor: sqlSearchResult.append({ \"id\": id, \"password\": password }) # md5 加密轉換 transferPassword = hashlib.md5(requestPassword.encode()) # 如果密碼相等 if transferPassword.hexdigest() == sqlSearchResult[0]['password']: # 更新資料 # 刪除用戶的基本資料 sql = \"DELETE FROM user WHERE id = %s;\" cursor.execute(sql, (requestId,)) # 確認資料有存入資料庫 connection.commit() # 刪除用戶的好友資料 # 用 id 查詢用戶的朋友 id 統計好友數 cursor.execute( \"SELECT id, friendId FROM friend WHERE id = %s;\", (requestId,)) # 有好友 if cursor.rowcount \u003e 0: # 循環刪除 for i in range(0, cursor.rowcount * 2): sql = \"DELETE FROM friend WHERE id = %sor friendId = %s;\" cursor.execute(sql, (requestId, requestId)) # 確認資料有存入資料庫 connection.commit() # token 加入黑名單 jti = get_raw_jwt()['jti'] blacklist.add(jti) response_object['message'] = 'Delete the account success.' response_object['data'] = True else: response_object['message'] = 'Delete the account fail. The password is not true.' response_object['data'] = False return jsonify(response_object) ","date":"2020-08-04","objectID":"/flask_mysql/:7:0","tags":["Python","Flask","MySQL","Database","數據庫","Web"],"title":"Flask 中使用 MySQL","uri":"/flask_mysql/"},{"categories":["Python"],"content":"Reference Python 使用 MySQL Connector 操作 MySQL/MariaDB 資料庫教學與範例 ","date":"2020-08-04","objectID":"/flask_mysql/:8:0","tags":["Python","Flask","MySQL","Database","數據庫","Web"],"title":"Flask 中使用 MySQL","uri":"/flask_mysql/"},{"categories":["Moment"],"content":"學習態度 讀萬卷書不如行萬里路。 我認為學習工程相關最重要的莫過於要親身去實踐手作，而非靠一堆理論知識和小實驗去學習，做項目讓自己有經驗莫過於看一堆理論知識以及為考試或光鮮亮麗的文憑。切記，實作是刻印在人的身體。 再者，學習是靠興趣的，想要學好軟件工程，需要愛上編程，如果只是像學校老師或學長姊得學習步調走，而不自己主動去學習並實作自己感興趣部份，你將永遠不會學會編程。 ","date":"2020-08-04","objectID":"/how_to_learn_cs/:1:0","tags":["CS","計算機科學","軟件工程","工程學"],"title":"關於學習軟件工程、計算機科學與技術的方法","uri":"/how_to_learn_cs/"},{"categories":["Moment"],"content":"學習步調 學習一門技術分幾個階段： 初步認識，了解原理等理論知識。 會寫 Hello world，學會基礎使用語法。 熟練該門語言，並能自己使用這技術開發中小型 Demo 與項目。 精通該語言，能駕馭該門技術，開發大型項目。 不要學到了 Hello world 就認為自己已經精通了，你還隻是菜鳥。不要還沒學會爬就想跑步，除非你自認天才。 ","date":"2020-08-04","objectID":"/how_to_learn_cs/:2:0","tags":["CS","計算機科學","軟件工程","工程學"],"title":"關於學習軟件工程、計算機科學與技術的方法","uri":"/how_to_learn_cs/"},{"categories":["Moment"],"content":"關於文檔 我自己認為文檔在開發項目的比重並沒有很重要，要求文檔的前提是整體隊伍有一定的水平實力能去實現，不然寫出來的文檔也無法實現。做項目的是人不是文字，文檔頂多起到開發輔助的效用。然而，現在學校很多比賽卻是重視文檔，各種 PPT 大賽到 PS、PR 編程，這事實讓人痛心，使很多有實力的人因為文檔的繁文縟節而退卻。要真正做到的是項目不是靠文字或嘴巴或白嫖網上開源代碼……等方法實現，而是靠自己紮實編寫的代碼。 ","date":"2020-08-04","objectID":"/how_to_learn_cs/:3:0","tags":["CS","計算機科學","軟件工程","工程學"],"title":"關於學習軟件工程、計算機科學與技術的方法","uri":"/how_to_learn_cs/"},{"categories":["Moment"],"content":"代碼技巧與學習管道 我認為有幾個技能是一個程序員必備的： 學會使用搜索引擎關鍵字。 翻牆使用 Google、Github、Stackoverflow、Youtube…等學習網頁。 官方文檔有時是最好的選擇。 編程注意註解，還有變量函數命名、代碼編排，儘可能讓代碼精簡。 要捨得花時間學習新知識。 Git、Github、Markdown 的使用，寫正式報告建議使用 LaTeX。文檔交 PDF 格式。 自己的 Blog，用來創造發表自己的想法與技巧。 保持上進心、好奇心與謙虛，要勇於探索新事物，且人上有人，天外有天。 最後希望大家能擇你所愛，愛你所擇，如果敲代碼是你的興趣，那恭喜你，你有自己的愛好。 ","date":"2020-08-04","objectID":"/how_to_learn_cs/:4:0","tags":["CS","計算機科學","軟件工程","工程學"],"title":"關於學習軟件工程、計算機科學與技術的方法","uri":"/how_to_learn_cs/"},{"categories":["前端"],"content":"前言 經過許久寫 VueJS 的經驗，實在是有些技巧我想要紀錄下來，畢竟當時我摸索了很久，從一開始的不擅長到後面的熟練，經歷的 Project 很多。希望能幫助新手快速掌握 VueJS。 這文章不會教你 Vue 基礎語法等詳細的基礎部份。所以在看這篇文章時需要一些 Vue 基礎。 如果因為沒有範例觀摩的話，可以看我在 2020/06/30 - 2020/07/17 暑假實訓寫的個人空間系統 - Blog 前端。 ","date":"2020-07-31","objectID":"/vue_skill/:1:0","tags":["Vue","Vue-cli","前端","npm","Vuex","Vue-Router","Request","Axios","Web"],"title":"Vue 技巧與經驗 - 項目構建、組件、路由、請求","uri":"/vue_skill/"},{"categories":["前端"],"content":"Vue-cli 腳手架使用 ","date":"2020-07-31","objectID":"/vue_skill/:2:0","tags":["Vue","Vue-cli","前端","npm","Vuex","Vue-Router","Request","Axios","Web"],"title":"Vue 技巧與經驗 - 項目構建、組件、路由、請求","uri":"/vue_skill/"},{"categories":["前端"],"content":"創建應用 用了 CDN 引入就不能用 Vue-cli 了，整個的結構差太多，通常 CDN 引入就是 Demo 或是很小的專案某部分用來代替 JQuery 用。 大部分開發還是使用 Vue-cli 比較方便。關於使用 Vue-cli 現在使用 npm 可以自己選擇要裝哪些東西，使用越來越方便，通常我是建議自定義，因為 eslint 的標準太高了，每次打開瀏覽器 Console 就一堆警告。所以在後面的選擇將 Linter / Formatter 這一項按空白鍵（Space）去掉。目前我開發項目初始構建只需要下列三個就暫時夠用了： Babel：自由開源的 JavaScript 編譯器、轉譯器。 Router：Vue 的路由。 Vuex：組件狀態管理。 關於怎麼裝 npm 和 vue-cli，我想 npm 就網上下載安裝，vue-cli 就執行 npm install -g @vue/cli 指令進行安裝。 vue create demo # 創建一個 vue-cli 應用 # 按下 Down 再按 Enter 選擇第二項自定義 Vue CLI v4.4.6 ? Please pick a preset: default (babel, eslint) ❯ Manually select features # 用空白鍵選擇下面的三個，並按 Enter ? Please pick a preset: Manually select features ? Check the features needed for your project: ◉ Babel ◯ TypeScript ◯ Progressive Web App (PWA) Support ❯◉ Router ◉ Vuex ◯ CSS Pre-processors ◯ Linter / Formatter ◯ Unit Testing ◯ E2E Testing 如果這裡沒有選擇裝 Router 和 Vuex 的話，沒關係，我這篇文章後面會教這兩個的基本使用也會教怎麼自己導入，畢竟幾個月前是需要自己另外裝的。感覺是被 npm 被 Github 合併之後變這麼方便。 後面的選項如果都沒特別需求就一直按 Enter 就好。 ","date":"2020-07-31","objectID":"/vue_skill/:2:1","tags":["Vue","Vue-cli","前端","npm","Vuex","Vue-Router","Request","Axios","Web"],"title":"Vue 技巧與經驗 - 項目構建、組件、路由、請求","uri":"/vue_skill/"},{"categories":["前端"],"content":"Project 結構 . ├── babel.config.js ├── .browserslistrc ├── .git ├── .gitignore ├── node_modules ├── package.json ├── package-lock.json ├── public │ ├── favicon.ico │ └── index.html ├── README.md └── src ├── App.vue ├── assets │ └── logo.png ├── components │ └── HelloWorld.vue ├── main.js ├── router │ └── index.js ├── store │ └── index.js └── views ├── About.vue └── Home.vue 上面是創建完應用後會出現的 Project 結構。這裡 npm 真的很貼心，連 .git、.gitignore、README.md 都幫你新建好了。 這裡比較需要注意的是 package.json 和 src 目錄，package.json 可以幫助你查看當前依賴版本和管理依賴，所有安裝依賴都會放到 node_modules 資料夾，所以如果出現依賴問題就將 node_modules 砍了，然後重新執行 npm install 指令，如果要升級依賴套件就執行 npm update 就能一次更新 Project 中的所有套件。如果再有問題，建議直接將 Error 訊息用 Google 搜索一下，大部分解決辦法都在 Stack Overflow 和 Github issues 等地方找到解決辦法。 ","date":"2020-07-31","objectID":"/vue_skill/:2:2","tags":["Vue","Vue-cli","前端","npm","Vuex","Vue-Router","Request","Axios","Web"],"title":"Vue 技巧與經驗 - 項目構建、組件、路由、請求","uri":"/vue_skill/"},{"categories":["前端"],"content":"src 目錄 檔案或文件 用途 App.vue 作為所有 SPA 頁面的起始根頁面 assets/ 靜態資源 e.g. CSS JS IMG components/ 自定義組件 main.js 作為所有 SPA 頁面的全局 JS 文件 router/ 路由配置文件 store/ Vuex 的狀態管理 views/ 頁面或子頁面 src 目錄是我們最主要寫項目時編輯的地方，目前最新版的 vue-cli 所生成的目錄長這樣（雖然之前不是這樣），總之用途都幫你分類好了。 ","date":"2020-07-31","objectID":"/vue_skill/:2:3","tags":["Vue","Vue-cli","前端","npm","Vuex","Vue-Router","Request","Axios","Web"],"title":"Vue 技巧與經驗 - 項目構建、組件、路由、請求","uri":"/vue_skill/"},{"categories":["前端"],"content":"編寫習慣 1 引入依賴 引入依賴的判斷，通常如果只是單一個頁面或有特殊需求的頁面要引入使用一個組件，我會建議直接在這個頁面的 *.vue 直接引入註冊組件，如果是像是很多頁面都要用的組件就需要在 main.js 全局引入註冊組件，e.g. UI 庫框架。 2 Components 與 Views 的區別 通常我很少會去動 Components 這目錄，除非需要我自己寫組件，雖然 Components 和 Views 裡面裝的 *.vue 都是組件，但最大的區別是Components 是不具有配置 router 的一般組件，Views 裡面是有配置 router 的子組件，所以在頁面跳轉時我們會是跳轉到 Views 目錄下的組件。 3 子頁面 註：不管哪個頁面，源碼中 \u003ctemplate\u003e\u003c/template\u003e 裡面中必須先用一個 \u003cdiv\u003e\u003c/div\u003e 往裡面包一層，因為只能有一個根父元素。 有些人會使用一般的組件然後用 v-if 或 v-on 判斷作為子頁面顯示，我是不建議這樣子做，因為這樣的頁面如果點了一下瀏覽器刷新頁面，所有頁面當前位置都會被重置，e.g 如果你有個頁面 Nav 上有購物車和商店，如果你購物車和商店的子頁面是上述所說的沒配置不具備路由屬性，在網址 URL 上相同都是 https://localhost:8080/，你刷新頁面整個頁面就會初始化，如果是有配置路由的子頁面會分別像是 https://localhost:8080/cart 和 https://localhost:8080/home，這樣才能保證你當前檢視的頁面刷新網址後不會改變目前正在檢視子頁面。 4 關於是否需要用到 JQuery 或是其他前端 JS 框架 我一開始也會有這樣的疑惑，明明用了 Vue 會試著想去混著使用 JQuery，但現在我的建議很明確，沒必要混著用，兩者都是可以用自己的方式實現相關功能，像是 Vue 網上就有豐富的組件庫，JQuery 勢必是會被淘汰的產物。比如說好了，像是之前我要做一個點擊按鈕頁面滑動到特定 #id 元素的效果，而我一開始死命去找 Vue 有沒有相關 JS 代碼實現，然後卻一直找不到，自己用純 Js 實現也報錯，Google 搜到的大多都是 JQuery 實現，後面我發現原來是我沒用好 Keyword 去搜，其實是有相關組件實現的。 5 關於組件之間的傳值 直接說結論：Vuex 去管理，網上會看到很多人教 Vue 使用一定會教怎麼父子組件互相傳值，我一開始也是用這方法傳值，但是當你使用的是子頁面 router 時，恰好這些父子組件傳值根本沒用，你只能用 query string 傳參，但是這樣只能傳一個參數，所以除非是你要自己寫組件給別人或自己設計組件用，不然是不需要用到父子組件傳值方式，相對的使用 Vuex 才是更為方便的方式。 6 Vuex 使用的場景 目前使用 Vuex 最大需要注意的點是如果你點擊瀏覽器刷新頁面，所有的 State 都會被初始化，所以不能只依據 Vuex 去存數據，像是 Jwt token 應該放在 localsStorage 或 Cookie，每個頁面在初始化時就要異步請求數據，也就是每刷新一次頁面就會請求一次或多次數據，這是必須的，沒有簡便的方法，Vuex 侷限性也很多，一般我是建議將請求的 URL 存在 Vuex 的 State，如果後端改了 URL 前端也好一次搞好所有請求 URL，加上一個請求可能需要在多個子頁面中會使用到，為了增加複用性和方便，HTTP 請求 URL 用 Vuex 引入。 7 請求 我自己寫前端 HTTP 請求都是寫異步請求，至於後端要怎樣的請求方式，前端真的無法決定，只是如果是需要測試數據，我建議是使用 MockJS 作為前端測試數據用，這樣也不需要前端一直填測試數據，被後端侷限。這篇文章後面我會寫一下 Axios 請求的方式。 8 Static Source 既然我們要寫 CSS Style，那我們就要統一使用 Class 或 Id 去編寫元素樣式，Inline Style 並不好加以管理，也不好發現錯誤，有時摳 CSS 摳不出自己想要的效果會讓我很煩躁。 9 駝峰命名法與註解 這部份應該不用我多說明，除了這些，你的 Code 也需要規範化，變量命名也需要有意義，不是純粹的英文字母。Code 的易讀性真的很重要。 10 CSS Position Fixed 我相信有些頁面經常會用 Fixed 來固定某些元素，然而在這部份，我是建議要盡可能的少使用這方法，因為在排版上，如果沒有指定特定的長寬，會造成走版， 11 export default 與 new Vue 相信一開始都有人有這問題，當然網上搜也是一大把結果，我就在這裡簡略說一下： new Vue：這是應用程序的根 Vue 實例。 new Vue({ el: '#app', data () { return {} } }) \u003chtml\u003e ... \u003cbody\u003e \u003cdiv id=\"app\"\u003e\u003c/div\u003e \u003c/body\u003e \u003c/html\u003e export default：ES6 語法中的導出，也就是說這是聲明一個之後會被註冊使用的組件，創建一個本地可註冊的 Vue 組件。 // my-component.js export default { name: 'my-component', data () { return {} } } \u003c!-- another-component.js --\u003e \u003ctemplate\u003e \u003cmy-component\u003e\u003c/my-component\u003e \u003c/template\u003e \u003cscript\u003e import myComponent from 'my-component' export default { components: { myComponent }, data () { return {} } // ... } \u003c/script\u003e 12 調試端口 Port 一般預設調適端口是 8080，但有時也不是這樣，不過這部份也沒有什麼好改動的，畢竟後端也不需要知道前端是哪個 URL 發送的請求，除非自己有什麼強迫症非要改調試時的 Websocket 端口，不然沒必要去在意。這裡姑且還是寫一下改動調適端口的寫法。 在 demo/（也就是 Project 根目錄）下新建一個 vue.config.js 檔案，並寫入下列內容。 // vue.config.js module.exports = { devServer: { // 告訴 dev-server 在服務器啟動後打開瀏覽器，將其設置 true 為打開默認瀏覽器 open: true, // 運行的 host 和 port host: 'localhost', port: 8080, } } 13 Assets 與 Static 大家都會疑惑 Assets 與 Static 都是放靜態資源的目錄，但為什麼要有兩個？區別如下： Assets：在運行 npm run build 之後會隨著打包後進行資源壓縮體積，Code 格式化，打包完會生成放在 static/ 中隨 index.html 一起部署到服務器。 Static：打包時不會走打包的壓縮流程，打包效率高，但不會進行壓縮也意味著資源佔用大，影響頁面載入速度。 所以有如下規則： 我們自己寫頁面需要的靜態資源放到 assets/ 目錄下。 第三方的 JS 靜態資源因為是別人經過處理的，所以可以放到 static/。 14 推薦的 UI 框架 我不會推薦 Vuetify，拜託不要被他絢麗的外貌所吸引，坑很多的，建議的是 Ant design、Bootstrap-vue、Buefy。 ","date":"2020-07-31","objectID":"/vue_skill/:2:4","tags":["Vue","Vue-cli","前端","npm","Vuex","Vue-Router","Request","Axios","Web"],"title":"Vue 技巧與經驗 - 項目構建、組件、路由、請求","uri":"/vue_skill/"},{"categories":["前端"],"content":"Router Router 配置 安裝： npm install vue-router # 安裝 vue-router 配置說明： 如果沒有這些資料夾和檔案就自己新建。 如果你在一開始就有裝 Router，那你會在 src/router/index.js 發現如下內容，這裡引入 vue-router，並使用 Vue.use(VueRouter) 註冊該組件，然後聲明一個 routes 常量，並將 views/ 資料夾裡的組件引入到這裡且賦值給 routes Array Object。然後再賦值給一個 VueRouter Object，再導出該 Object，在 src/main.js 中引入。 註：引入的組件名稱可以自己定義，因為是 export default。ES6 語法中 import 和 export 可以有多個，但是 export default 只能有一個。 // src/router/index.js import Vue from 'vue' import VueRouter from 'vue-router' import Home from '../views/Home.vue' Vue.use(VueRouter) // 註冊陸游組件 // routes 常量 const routes = [ { path: '/', name: 'Home', component: Home }, { path: '/about', name: 'About', // route level code-splitting // this generates a separate chunk (about.[hash].js) for this route // which is lazy-loaded when the route is visited. component: () =\u003e import(/* webpackChunkName: \"about\" */ '../views/About.vue') } ] // VueRouter Object const router = new VueRouter({ mode: 'history', base: process.env.BASE_URL, routes }) // 導出 export default router // src/main.js import Vue from 'vue' import App from './App.vue' import router from './router' // 引入 router import store from './store' Vue.config.productionTip = false new Vue({ router, // 引入 store, render: h =\u003e h(App) }).$mount('#app') 在需要用道路由管理顯示的組件加入 \u003crouter-view/\u003e，\u003crouter-link\u003e\u003c/router-link\u003e 用於路由跳轉規則，就像一開始初始化的 src/App.vue： \u003ctemplate\u003e \u003cdiv id=\"app\"\u003e \u003cdiv id=\"nav\"\u003e \u003crouter-link to=\"/\"\u003eHome\u003c/router-link\u003e | \u003crouter-link to=\"/about\"\u003eAbout\u003c/router-link\u003e \u003c/div\u003e \u003crouter-view/\u003e \u003c/div\u003e \u003c/template\u003e \u003cstyle\u003e #app { font-family: Avenir, Helvetica, Arial, sans-serif; -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale; text-align: center; color: #2c3e50; } #nav { padding: 30px; } #nav a { font-weight: bold; color: #2c3e50; } #nav a.router-link-exact-active { color: #42b983; } \u003c/style\u003e Router 配置注意點 // 這裡 Home 組件是需要引入的，但是因為上面的例子有寫，這裡為了方便描述就不寫了 const routes = [ { path: '/', name: 'Home', component: Home }, { path: '/about', name: 'About', // route level code-splitting // this generates a separate chunk (about.[hash].js) for this route // which is lazy-loaded when the route is visited. component: () =\u003e import(/* webpackChunkName: \"about\" */ '../views/About.vue') } ] 首先就是 routes 這常量中的 Object 通常由 path、name、component 這些 Key 值所組成，分別代表的是：路徑、路由名、組件。如果 path: '/about'，在調試時就是 http://localhost:8080/about，name: 'About' 可以作為前端頁面路由跳轉時使用的判斷值，component 代表該路由所代表的組件，就是跳轉到該路由時會顯示的組件。 component 有兩種寫法：第一種是像上面例子中的 Home，直接賦值引入的組件，這種寫法，會在載入根頁面全部 JS 渲染完成。第二種是上面的 Home，懶加載，這種寫法可以避免如果頁面應用很大會花很久載入頁面（使用的是匿名函數），加載根頁面時會依據當前頁面所需要加載對應的 JS，不是當前頁面需要的不會在此加載。我是建議後者的寫法。 現在初始化路由時預設的 Router Mode 是 history，就是沒有錨點的方式，如果想要換回有錨點的可以改成 hash，但是我偏好是 history，這樣 URL 也比較乾淨。 子路由與重定向 我們可以給每個路由弄子路由，重定向就是如果跳轉到某個路由會特地跳到另一個路由，一般用於有多個子路由的對象，或是跳轉到 404 頁面，e.g. 註：父路由沒有一定需要有 component 的 value 值，也可以沒有。 const routes = [ { path: '/sign', name: 'Sign', component: () =\u003e import ( /* webpackChunkName: \"Sign\" */ '../views/sign/Sign.vue'), // 子路由 children: [{ path: '/sign/signIn', name: 'SignIn', component: () =\u003e import ( /* webpackChunkName: \"SignIn\" */ '../view/sign/SignIn.vue') }, { path: '/sign/signUp', name: 'SignUp', component: () =\u003e import ( /* webpackChunkName: \"SignUp\" */ '../view/sign/SignUp.vue') }, { path: '/sign/verifyEmail', name: 'VerifyEmail', component: () =\u003e import ( /* webpackChunkName: \"VerifyEmail\" */ '.views/sign/verifyEmail.vue') }, { path: '/sign/forgotPassword', name: 'ForgotPassword', component: () =\u003e import ( /* webpackChunkName: \"ForgotPassword\" */ '.views/sign/forgotPassword.vue') } ], //强制重定向 redirect: '/sign/signIn' }, ] 404 下面的寫法可以匹配 404 路由。 const routes = [ { path: '*', name: '404', component: () =\u003e import ( /* webpackChunkName: \"404\" */ '../views/error/pageNotFound.vue') } ] 動態路由 動態路由會攜帶一個參數，可以用來在初始化渲染組件時發送請求數據，會攜帶的參數代表的意義可以是 UserID 或是 UserName…等，e.g 像是 Github 在查看別人的空間時 URL 上會有使用者的 UserName，所以會根據那個參數請求數據。 const routes = [ { path: '/:id/admin', name: 'admin', component: () =\u003e import ( /* webpackChunkName: \"admin\" */ '../views/blog-admin/admin.vue'), children: [{ path","date":"2020-07-31","objectID":"/vue_skill/:2:5","tags":["Vue","Vue-cli","前端","npm","Vuex","Vue-Router","Request","Axios","Web"],"title":"Vue 技巧與經驗 - 項目構建、組件、路由、請求","uri":"/vue_skill/"},{"categories":["前端"],"content":"Vuex 其實很多人一開始看 Vuex 的官方文檔看不懂，我也不意外，因為太晦澀了，看不懂。但是我在看完某個 B 站上的教學影片後，我開竅了，因為用文字很難描述清楚，建議這影片長度全部看完才能真正理解 Vuex，這裡奉上影片位置。 ","date":"2020-07-31","objectID":"/vue_skill/:2:6","tags":["Vue","Vue-cli","前端","npm","Vuex","Vue-Router","Request","Axios","Web"],"title":"Vue 技巧與經驗 - 項目構建、組件、路由、請求","uri":"/vue_skill/"},{"categories":["前端"],"content":"Vue 的 Request 我使用 axios 前後端分離跨域請求數據。 安裝 npm i vue-axios 註冊組件 // src/main.js import Vue from 'vue' import axios from 'axios' import VueAxios from 'vue-axios' Vue.use(VueAxios, axios) 我通常使用三種方法請求： Params Form-data 放 Body 的純 Js 註：我會為了整齊與易用，會讓請求單獨放在一個獨立的 Function 作為異步請求使用，還有一個非常重要的點是 Axios 是異步的，所以不要在 Axios 請求 Code 後添加任何 Code Params import 'axios' from 'axios' export default { // ... methods: { // ... async checkEmail() { var params = new URLSearchParams(); params.append(\"email\", this.email); axios .post(this.checkSameEmailURL, params) .then(response =\u003e { console.log(response); console.log(response.data); if (response.data.data === false) { return false; } else { return true; } }) .catch(error =\u003e { console.log(error); }); } } } Form-data 這裡要換成這樣的寫法比較方便，這裡設置 Content-Type 為 'multipart/form-data'（'form-data' 也可以）。 import axios from 'axios' export default { // ... methods: { // ... async LoginRequest() { let data = new FormData(); data.append(\"email\", this.email); data.append(\"password\", this.password); axios .post(this.loginURL, data, { headers: { \"Content-Type\": \"form-data\" }, transformRequest: [(data, headers) =\u003e data], //預設值，不做任何轉換 }) .then((response) =\u003e { console.log(response); console.log(response.data); this.loginSuccess = response.data.data; this.openDialog = false; if (this.loginSuccess) { this.dialog = true; } }) .catch((error) =\u003e { console.log(error); this.openDialog = false; if (this.loginSuccess) { this.dialog = true; } }); } } } 純 Js import axios from 'axios' export default { // ... methods: { // ... async RegisterRequest() { axios({ method: \"post\", url: this.registerURL, headers: {}, data: { username: this.name, password: this.password, email: this.email, phone: this.phone, }, }) .then((response) =\u003e { console.log(response.data); this.registerSuccess = response.data.data; this.openDialog = false; this.dialog = true; }) .catch((error) =\u003e { console.log(error); }); }, } } Header 帶 Token 的請求 下面的例子中，在 header 添加 Authorization 參數，這裡要注意的是 header 與 data 的參數位置，不管 data 裡面有沒有內容，即使是空的也要添加上去。 import axios from 'axios' export default { // ... methods: { // ... async getAllChannels() { // 初始化 this.showChannels = []; let jwt_token = Vue.localStorage.get(\"jwt_token\"); let UserID = Vue.localStorage.get(\"user_id\"); let data = new FormData(); data.append(\"id\", UserID); axios .post(this.requestGetAllChannelsURL, data, { headers: { \"Content-Type\": \"form-data\", Authorization: `Bearer ${jwt_token}`, }, transformRequest: [(headers) =\u003e data], //預設值，不做任何轉換 }) .then((response) =\u003e { console.log(response.data); if (response.data.data === undefined) { // token 失效 // 移除 token 和 id Vue.localStorage.remove(\"jwt_token\"); Vue.localStorage.remove(\"user_id\"); // 重新登入 document.location.href = \"/\"; } else if (response.data.data) { // 有找到數據 this.showChannels = response.data.channels; // 推入 VueX this.$store.commit(UPDATE_ALL_CHANNELS, response.data.channels); console.log(this.showChannels); console.log(response.data.channels); // 請求 channel 的 message 並存入 VueX for (let i = 0; i \u003c this.showChannels.length; i++) { this.getAllMessage(this.showChannels[i].id); } } else { // 沒找到數據 } }) .catch((error) =\u003e { console.log(error); }); }, } } ","date":"2020-07-31","objectID":"/vue_skill/:2:7","tags":["Vue","Vue-cli","前端","npm","Vuex","Vue-Router","Request","Axios","Web"],"title":"Vue 技巧與經驗 - 項目構建、組件、路由、請求","uri":"/vue_skill/"},{"categories":["前端"],"content":"多頁面應用 應用場景 多頁面應用的概念就是如果你的 Web 網頁想要有多個面向不同需求的應用，或是想要將 PC 端和手機端的分開設計，想做不同風格的頁面，就可以使用多頁面應用實現。Web 端有不同需求的意思是假設你要做一個電商平台，卻又想要建一個社區論壇，這時就是不同的需求，需要使用多頁面應用。 多頁面應用配置 在 Project 根目錄的 vue.config.js 添加以下內容： 需要修改的地方是 devServer 配置首頁入口，改成自己要的。 let path = require('path') let glob = require('glob') // 用于筛选文件 // 工厂函数 - 配置pages实现多页面获取某文件夹下的html与js function handleEntry(entry) { let entries = {} let entryBaseName = '' let entryPathName = '' let entryTemplate = '' let applicationName = '' glob.sync(entry).forEach(item =\u003e { console.log('!!!', item) entryBaseName = path.basename(item, path.extname(item)) console.log('entryBaseName:', entryBaseName) entryTemplate = item.split('/').splice(-3) console.log('entryTemplate:', entryTemplate) entryPathName = entryBaseName // 正确输出js和html的路径 console.log('entryPathName', entryPathName) entries[entryPathName] = { entry: 'src/' + entryTemplate[0] + '/' + entryTemplate[1] + '/' + entryTemplate[1] + '.js', template: 'src/' + entryTemplate[0] + '/' + entryTemplate[1] + '/' + entryTemplate[2], title: entryTemplate[2], filename: entryTemplate[2] } }) return entries } let pages = handleEntry('./src/application/**?/*.html') console.log(pages) // 以下开始配置 module.exports = { // 引入 vuetify \"transpileDependencies\": [ \"vuetify\" ], lintOnSave: false, // 关掉eslint /** * baseUrl 从 3.3 起废用，使用 pubilcPath 代替 * 默认情况下，Vue CLI 会假设你的应用是被部署在一个域名的根路径上，例如 https://www.my-app.com/。如果应用被部署在一个子路径上，你就需要用这个选项指定这个子路径。例如，如果你的应用被部署在 https://www.my-app.com/my-app/，则设置 publicPath 为 /my-app/。 * 这个值也可以被设置为空字符串 ('') 或是相对路径 ('./')，这样所有的资源都会被链接为相对路径，这样打出来的包可以被部署在任意路径，也可以用在类似 Cordova hybrid 应用的文件系统中。 */ publicPath: process.env.NODE_ENV === \"production\" ? \"./\" : \"/\", productionSourceMap: false, // 入口设置 pages, devServer: { index: '/', // 运行时，默认打开application1页面 // 告诉dev-server在服务器启动后打开浏览器，将其设置true为打开默认浏览器 open: true, // host: 'localhost', // port: 8080, // https: false, hotOnly: false, // 配置首页 入口链接 before: app =\u003e { app.get('/', (req, res, next) =\u003e { for (let i in pages) { //res.write(`\u003ca target=\"_self\" href=\"/${i}\"\u003e/${i}\u003c/a\u003e\u003c/br\u003e`); if (i === 'introduce') { res.write(`\u003cscript\u003edocument.location.href=\"/${i}\";\u003c/script\u003e`); } } res.end() }); }, // proxy: { //配置跨域 // '/api': { // target: 'https://sm.ms/api/upload', //這裡後台的地址模擬的，應該填寫真實的後台api // ws: false, // 如果要代理 websockets // changOrigin: true, //允許跨域 // pathRewrite: { // '^/api': '' //請求的時候使用這個api就可以 // } // } // } }, } 接著弄多頁面應用的時候，在 src/ 下新建一個 application/ 目錄，然後如果我要新增的是電商平台寵物商店和論壇，應用名稱分別為 PetStore 和 Communication，就改造成如下目錄結構： . ├── babel.config.js ├── .browserslistrc ├── .git ├── .gitignore ├── node_modules ├── package.json ├── package-lock.json ├── public │ ├── favicon.ico │ └── index.html ├── README.md ├── src │ ├── PetStore │ │ ├── assets │ │ │ └── index.js │ │ ├── components │ │ │ └── HelloWorld.vue │ │ ├── router │ │ │ └── index.js │ │ ├── store │ │ │ └── index.js │ │ ├── views │ │ │ ├── About.vue │ │ │ └── Home.vue │ │ ├── PetStore.html │ │ ├── PetStore.js │ │ └── PetStore.vue │ └── Communication │ ├── assets │ │ └── index.js │ ├── components │ │ └── HelloWorld.vue │ ├── router │ │ └── index.js │ ├── store │ │ └── index.js │ ├── views │ │ ├── About.vue │ │ └── Home.vue │ ├── Communication.html │ ├── Communication.js │ └── Communication.vue └── vue.config.js 上面的 src/ 下就是將整個 SPA 單頁面應用重新整合成多頁面應用。PetStore.html 對應的內容是重構前的 public/index.html、PetStore.js 對應的是 src/main.js、PetStore.vue 對應的是 src/App.vue。 配置注意點 根據在 src/application 下的所有頁面應用中的所有的目錄名稱還有作為根組件的相關 File 名稱要跟頁面應用名稱一模一樣，因為在 vue.config.js 中的遍歷函數會用這樣的規則遍歷，如果想要改的話可以自己改。 這樣子配置之後，Project 根目錄中 public/ 相當於不會影響項目的目錄，當然要放靜態資源也是可以。 在 /public 同個圖片不能在不同的應用中使用。這部份我確認過，不知道是不是 Bug。 ","date":"2020-07-31","objectID":"/vue_skill/:2:8","tags":["Vue","Vue-cli","前端","npm","Vuex","Vue-Router","Request","Axios","Web"],"title":"Vue 技巧與經驗 - 項目構建、組件、路由、請求","uri":"/vue_skill/"},{"categories":["前端"],"content":"常見的問題 引入圖片 有時我們要用 js 引入相對位置圖片會失敗，像下面的例子： \u003ctemplate\u003e \u003cdiv\u003e \u003cimg :src=\"img\"/\u003e \u003c/div\u003e \u003c/template\u003e \u003cscript\u003e export default { data() { return { img: \"../assets/image/xxxxx.png\" } } } \u003c/script\u003e 之所以會失敗是因為，網頁把根域名當作相對路徑的根目錄，上面的 img: \"../assets/image/xxxxx.png\" 被識別為 img: \"http://localhost:8080/../assets/image/xxxxx.png\"，應該要改成如下方法 \u003ctemplate\u003e \u003cdiv\u003e \u003cimg :src=\"img\"/\u003e \u003c/div\u003e \u003c/template\u003e \u003cscript\u003e export default { data() { return { img: require(\"../assets/image/xxxxx.png\") } } } \u003c/script\u003e ","date":"2020-07-31","objectID":"/vue_skill/:2:9","tags":["Vue","Vue-cli","前端","npm","Vuex","Vue-Router","Request","Axios","Web"],"title":"Vue 技巧與經驗 - 項目構建、組件、路由、請求","uri":"/vue_skill/"},{"categories":["前端"],"content":"部署 關於部署，最後 Project 根目錄執行 npm run build，就能夠編譯生成最後的成品，就是 dist/ 目錄的生成，將 dist/ 目錄提出來部署到 Github Pages、Herokuv 或 Docker。 部署 - Vue CLI ","date":"2020-07-31","objectID":"/vue_skill/:2:10","tags":["Vue","Vue-cli","前端","npm","Vuex","Vue-Router","Request","Axios","Web"],"title":"Vue 技巧與經驗 - 項目構建、組件、路由、請求","uri":"/vue_skill/"},{"categories":["前端"],"content":"關於 NuxtJS NuxtJS 是 Vue-cli 的簡化集合版，也就是如果你很懶，你可以用 NuxtJS，但是運行起來的速度可想而知，真的很慢。如果想要在開發調試時好一些，建議就用 Vue-cli。 ","date":"2020-07-31","objectID":"/vue_skill/:3:0","tags":["Vue","Vue-cli","前端","npm","Vuex","Vue-Router","Request","Axios","Web"],"title":"Vue 技巧與經驗 - 項目構建、組件、路由、請求","uri":"/vue_skill/"},{"categories":["前端"],"content":"關於用 Vue 寫桌面應用和 Android 端 Vue 寫桌面應用是 Electron-vue，寫 Android 是 Vue Native。然而，不要嘗試使用任何 HTML 語言寫桌面應用和 Android 端，因為真的不如原生性能好，現在大前端（使用一種技術實現多種平台的前端）還不夠成熟，我想起我之前調試 Electron-vue 的恐懼，不知道多少次記憶體佔滿，強制關機 (´;ω;`) ","date":"2020-07-31","objectID":"/vue_skill/:4:0","tags":["Vue","Vue-cli","前端","npm","Vuex","Vue-Router","Request","Axios","Web"],"title":"Vue 技巧與經驗 - 項目構建、組件、路由、請求","uri":"/vue_skill/"},{"categories":["前端"],"content":"Reference Vue Router vue的export default 還是沒能理解它是什麼 - IT 邦幫忙 Vue ‘export default’ vs ‘new Vue’ - stack overflow Vue状态管理-Vuex简要教程 - BiliBili vue-axios - npm VUE.CLI 4.0 配置多页面入口礼包送你！ - 掘金 部署 - Vue CLI vue中assets和static的區別 Vue中img的src属性绑定与static文件夹 - 簡書 ","date":"2020-07-31","objectID":"/vue_skill/:5:0","tags":["Vue","Vue-cli","前端","npm","Vuex","Vue-Router","Request","Axios","Web"],"title":"Vue 技巧與經驗 - 項目構建、組件、路由、請求","uri":"/vue_skill/"},{"categories":["Moment"],"content":"感觸 我第一次接觸 Hugo 的時候，是我因為朋友的技術 Blog 所以感興趣，尤其因為當時剛開始接觸項目和比賽，所以學了 Git 和 Markdown 卻不熟練，笨手笨腳的，那時大一生的我實在是太菜了，現在想想已經過了兩年，已經到了升上大三，時光飛逝，年紀越大感觸越深。 我第一次學怎麼構建 Hugo + Github Pages 構建自己的 Blog 是看這篇文章，這篇文章真的寫得很好，我也推薦我室友看這篇文章，他也快速就上手了。我還記得當時我真的就是折騰在 Hugo 主題上，我第一次選的主題無法發表 Posts，是比較適合拿來做簡歷的主題，害我白搞了一天要換主題，第二次看中了 AllinOne 主題（不知道位為什麼現在這主題從 Hugo Theme 網站下架了），因為看這主題很酷炫，但這主題說真的配置起來很麻煩，最後配置完還發現手機端的顯示不正常，要自己去修 CSS，還有各種 Bug。 最近又因為發現自己很多文章中上傳到圖床的圖片很多被 404 了，我也不知道為什麼被 SM.MS 給 Block 了，加上我 AllinOne 這主題讓我的 Blog 載入速度過慢，直到前幾天，我經過好友的建議，終於決定要全面換新，我也考慮要換哪個主題找好久，好友推薦我 LoveIt 這主題，我也最終被這主題的界面打動，決定改用這個主題，一開始摸索這主題的配置參數弄了很久，加上這個主題沒有正體中文的界面，所以我自己去修 i18n 的文件內容，把自己所有文章的構造重新整理一次，將自己所有的文章要用圖片都使用 Tinypng 壓縮過再上傳到 imgpoi，最終成了現在的樣子。我很滿意 (,,・ω・,,) Rem BlogRemBlog.png \" Rem Blog ","date":"2020-07-31","objectID":"/hugo_theme_change/:1:0","tags":["Hugo","Theme","LoveIt","AllinOne","Blog"],"title":"Rem Blog 的構造改革過程心得","uri":"/hugo_theme_change/"},{"categories":["Moment"],"content":"Reference AllinOne LoveIt ","date":"2020-07-31","objectID":"/hugo_theme_change/:2:0","tags":["Hugo","Theme","LoveIt","AllinOne","Blog"],"title":"Rem Blog 的構造改革過程心得","uri":"/hugo_theme_change/"},{"categories":["Python"],"content":"前言 因為我家人正在學習寫 Python，我教導他去刷題庫，結果在高中生解題系統要解某個基礎題庫的題目時卡住了，我只好幫他解一下題目。 ","date":"2020-07-30","objectID":"/python_rome_number_programming/:1:0","tags":["Python","進制","演算法","NPSC","羅馬數字"],"title":"Python 解決羅馬數字轉換 NPSC 模擬試題","uri":"/python_rome_number_programming/"},{"categories":["Python"],"content":"題目 這是高中生解題系統基礎題庫裡的 a013 題目 ","date":"2020-07-30","objectID":"/python_rome_number_programming/:2:0","tags":["Python","進制","演算法","NPSC","羅馬數字"],"title":"Python 解決羅馬數字轉換 NPSC 模擬試題","uri":"/python_rome_number_programming/"},{"categories":["Python"],"content":"內容 如果生活在數世紀之前的古羅馬，你應該用過 V 來表示五。V 和 5 這兩個符號都可以用來表示數目五。用來表示數目的符號稱作數字。而羅馬人用來表示數目的符號就是羅馬數字。 以下是七個基本的羅馬數字︰ 羅馬數字 數目 I 1 V 5 X 10 L 50 C 100 D 500 M 1,000 所有其他的數目都是由這些數字組合而成。數目都是由左寫到右，通常值是等於組成的羅馬數字加起來。 例如十七可以表示為 X + V + I + I = XVII 10 + 5 + 1 + 1 = 17 表示羅馬數字可以使用減法來取代加法的規則。例如四可以不用四個一相加來表示 IIII，而採用五減一來表示 IV。利用這類規則，羅馬人能夠減化許多數目的表示方式，例如 IX 取代 VIIII 表示 9，及 CD 取代 CCCC 表示 400。 今日我們並不確定羅馬符號的起源為何。例如符號 V 的起源主要有兩個理論。有些學者認為五最早是用握拳、拇指在外的手勢來表示。最後以象形文字書寫而簡化為 V。 另一個理論認為 X 源自在 10 條線加上交叉線。因此五可以表示為 X 的一半，或是 V。 羅馬數字可以很容易地用來相加或相減，但算起乘除法就相當不順手。這就是為什麼現在羅馬數字並不常用的原因了。 問題 然而，羅馬數字還是經常用於書本章節及頁碼的編號。在這一題工作是讀入兩個正整數，然後輸出兩個數字差的絕對值。所有的數字都必須以羅馬數字來表示。而連續四個相同符號出現時，必須用減法規則來化簡之。 ","date":"2020-07-30","objectID":"/python_rome_number_programming/:2:1","tags":["Python","進制","演算法","NPSC","羅馬數字"],"title":"Python 解決羅馬數字轉換 NPSC 模擬試題","uri":"/python_rome_number_programming/"},{"categories":["Python"],"content":"問題 然而，羅馬數字還是經常用於書本章節及頁碼的編號。在這一題工作是讀入兩個正整數，然後輸出兩個數字差的絕對值。所有的數字都必須以羅馬數字來表示。而連續四個相同符號出現時，必須用減法規則來化簡之。 ","date":"2020-07-30","objectID":"/python_rome_number_programming/:2:2","tags":["Python","進制","演算法","NPSC","羅馬數字"],"title":"Python 解決羅馬數字轉換 NPSC 模擬試題","uri":"/python_rome_number_programming/"},{"categories":["Python"],"content":"輸入說明 每個輸入檔中會有一個或以上的測試資料。每一行由兩個數字組成一筆測試資料，且所有數字將會小於4,000。檔案最後會以符號 # 表示結束。 ","date":"2020-07-30","objectID":"/python_rome_number_programming/:2:3","tags":["Python","進制","演算法","NPSC","羅馬數字"],"title":"Python 解決羅馬數字轉換 NPSC 模擬試題","uri":"/python_rome_number_programming/"},{"categories":["Python"],"content":"輸出說明 每筆測試資料的答案必須輸出到檔案中，並且換行。如果答案為零，則須輸出字串 ZERO。 ","date":"2020-07-30","objectID":"/python_rome_number_programming/:2:4","tags":["Python","進制","演算法","NPSC","羅馬數字"],"title":"Python 解決羅馬數字轉換 NPSC 模擬試題","uri":"/python_rome_number_programming/"},{"categories":["Python"],"content":"測資資訊 記憶體限制： 512 MB 公開 測資點#0 (100%): 1.0s , \u003c1K ","date":"2020-07-30","objectID":"/python_rome_number_programming/:2:5","tags":["Python","進制","演算法","NPSC","羅馬數字"],"title":"Python 解決羅馬數字轉換 NPSC 模擬試題","uri":"/python_rome_number_programming/"},{"categories":["Python"],"content":"範例輸入輸出 Input I I MM II # Output ZERO MCMXCVIII ","date":"2020-07-30","objectID":"/python_rome_number_programming/:2:6","tags":["Python","進制","演算法","NPSC","羅馬數字"],"title":"Python 解決羅馬數字轉換 NPSC 模擬試題","uri":"/python_rome_number_programming/"},{"categories":["Python"],"content":"題目理解 首先我們仔細觀察輸出說明，雖然說要輸出到檔案，其實只要用 print() 輸出就好，然後根據測資，我們可以確定輸入輸出之間的 Code 是要我們寫羅馬數字相減後得到之差的絕對值，考我們羅馬數字與十進制數字之間的轉換，難度也沒用到什麼演算法，但是如果不熟悉就會出現邏輯錯誤。這題主要是可慮到細節的注意。 ","date":"2020-07-30","objectID":"/python_rome_number_programming/:3:0","tags":["Python","進制","演算法","NPSC","羅馬數字"],"title":"Python 解決羅馬數字轉換 NPSC 模擬試題","uri":"/python_rome_number_programming/"},{"categories":["Python"],"content":"程序設計思路 在轉換的過程要特別處理位數數字是 4 和 9 的位數，然後十進制轉換成羅馬數字時每個位數有不同的轉換標準，所以要另外聲明一個變量紀錄當前處理的位數。 當我們直觀將羅馬數字轉換成我們平常用的十進制數時，我們會從羅馬數字的尾部開始做計算轉換相加，所以我們在寫羅馬數字轉換成十進制數時，要先將羅馬數字字符串反轉（Reverse）。 Python 中 String 沒有 reverse() 方法，所以需要使用 string[::-1] 的方式轉換。 測資數字不超過 4000，所以不用考慮千位數上的 4 和 9。 羅馬數字轉成十進制數時為了 4 和 9 需要知道下一個字母是否比自己小，Python 對 Array 的 Index 會有 string index out of range 的問題，所以在處理前要用 If 判斷是否當前位數是否是字符串最後一個字符。 十進制數轉成羅馬數字時，需要注意一下如果位數數字是 0 的話就不做處理。 ","date":"2020-07-30","objectID":"/python_rome_number_programming/:4:0","tags":["Python","進制","演算法","NPSC","羅馬數字"],"title":"Python 解決羅馬數字轉換 NPSC 模擬試題","uri":"/python_rome_number_programming/"},{"categories":["Python"],"content":"Functions number_translate_rome(number)：十進制數轉成羅馬數字 rome_translate_number(rome)：羅馬數字轉成十進制 subtract(rome_list)：絕對值相減計算 main：主函式 ","date":"2020-07-30","objectID":"/python_rome_number_programming/:5:0","tags":["Python","進制","演算法","NPSC","羅馬數字"],"title":"Python 解決羅馬數字轉換 NPSC 模擬試題","uri":"/python_rome_number_programming/"},{"categories":["Python"],"content":"流程 在 Main 函式中輸入一個字符串，並使用 String 中的 split() 方法進行分割出兩個羅馬數字，這裡需要使用 While 迴圈，並判斷如果輸入的字符串是 # 就中止循環。 兩個羅馬數字轉成 List 類型後傳入 subtract() 進行相減。 將兩數字利用 rome_translate_number() 都轉成十進制，相減取絕對值，將絕對值傳入 number_translate_rome() 轉成數字。 將計算結果傳回 Main 函式並輸出。 ","date":"2020-07-30","objectID":"/python_rome_number_programming/:6:0","tags":["Python","進制","演算法","NPSC","羅馬數字"],"title":"Python 解決羅馬數字轉換 NPSC 模擬試題","uri":"/python_rome_number_programming/"},{"categories":["Python"],"content":"源碼 我這裡都有寫好註解喔 Σ(*ﾟдﾟﾉ)ﾉ # 題源： # https://zerojudge.tw/ShowProblem?problemid=a013 # 羅馬數字 # 羅馬數字代表的意思 I = 1 V = 5 X = 10 L = 50 C = 100 D = 500 M = 1000 # 數字轉羅馬 # 注意 4 和 9 要特別處理 def number_translate_rome(number): # 如果相減是 0 if number == 0: return \"ZERO\" # 轉換的結果 rome = \"\" # 紀錄正在處理的位數 times = 0 while number \u003e 0: # 取最小位 temp = int(number % 10) number = int(number - temp) # 當前位數 +1 times += 1 # 不同位有不同的處理方法 # 個位數 if times == 1: if temp != 0: # 1 - 4 if (temp / 5) \u003c 1: # 4 if temp == 4: rome = \"IV\" + rome # 1 - 3 else: for i in range(int(temp)): rome = \"I\" + rome # 5 - 9 else: # 9 if temp == 9: rome = \"IX\" + rome # 5 - 8 else: x = \"V\" for i in range(int(temp % 5)): x += \"I\" rome = x + rome # 十位數 elif times == 2: if temp != 0: # 10 - 40 if (temp / 5) \u003c 1: # 40 if temp == 4: rome = \"XL\" + rome # 10 - 30 else: for i in range(int(temp)): rome = \"X\" + rome # 50 - 90 else: # 90 if temp == 9: rome = \"XC\" + rome # 50 - 80 else: x = \"L\" for i in range(int(temp % 5)): x += \"X\" rome = x + rome # 百位數 elif times == 3: if temp != 0: # 100 - 400 if (temp / 5) \u003c 1: # 400 CD if temp == 4: rome = \"CD\" + rome # 100 - 300 else: for i in range(int(temp)): rome = \"C\" + rome # 500 - 900 else: # 900 CM if temp == 9: rome = \"CM\" + rome # 500 - 800 else: x = \"D\" for i in range(int(temp % 5)): x += \"C\" rome = x + rome # 千位數 elif times == 4: if temp != 0: # 測資不超過 4000 for i in range(int(temp)): rome = \"M\" + rome else: pass number /= 10 return rome # 羅馬轉數字 # 考慮到 4 和 9 的減位 # 注意 要先將字符串反轉 羅馬數字要從尾部開始計算 def rome_translate_number(rome): # 轉換結果 number = 0 # print(rome) # 反轉 string rome = rome[::-1] # 用 for 迴圈 i = 0 while i \u003c len(rome): if rome[i] == \"I\": number += 1 elif rome[i] == \"V\": # 避免 string index out of range if i != len(rome) - 1: # 4 IV if rome[i + 1] == \"I\": number += 4 # 將 I 也納入這次計算字符，跳過下一個字符的檢測 i += 1 else: number += 5 else: number += 5 elif rome[i] == \"X\": # 避免 string index out of range if i != len(rome) - 1: # 9 IX if rome[i + 1] == \"I\": number += 9 # 將 I 也納入這次計算字符，跳過下一個字符的檢測 i += 1 else: number += 10 else: number += 10 elif rome[i] == \"L\": # 避免 string index out of range if i != len(rome) - 1: # 40 XL if rome[i + 1] == \"X\": number += 40 # 將 X 也納入這次計算字符，跳過下一個字符的檢測 i += 1 else: number += 50 else: number += 50 elif rome[i] == \"C\": # 避免 string index out of range if i != len(rome) - 1: # 90 XC if rome[i + 1] == \"X\": number += 90 # 將 X 也納入這次計算字符，跳過下一個字符的檢測 i += 1 else: number += 100 else: number += 100 elif rome[i] == \"D\": # 避免 string index out of range if i != len(rome) - 1: # 400 CD if rome[i + 1] == \"C\": number += 400 # 將 C 也納入這次計算字符，跳過下一個字符的檢測 i += 1 else: number += 500 else: number += 500 elif rome[i] == \"M\": # 避免 string index out of range if i != len(rome) - 1: # 900 CM if rome[i + 1] == \"C\": number += 900 # 將 C 也納入這次計算字符，跳過下一個字符的檢測 i += 1 else: # print(rome[i + 1]) number += 1000 else: number += 1000 else: pass # 下一個 i += 1 # print(number) return number # 相減運算 def subtract(rome_list): rome_list[0] = rome_translate_number(rome_list[0]) rome_list[1] = rome_translate_number(rome_list[1]) # print(\"rome_list : %d, %d\" % (rome_list[0], rome_list[1])) # 數字相減 num_result = rome_list[0] - \\ rome_list[1] if rome_list[0] \u003e rome_list[1] else rome_list[1] - rome_list[0] # print(\"num_result: %d\" % num_result) return number_translate_rome(num_result) if __name__ == '__main__': while True: rome = input() # 結束 if rome == \"#\": break # string 分割 rome_list = rome.split() # print(\"rome1 %s , rome2 %s\" % (rome_list[0], rome_list[1])) result = subtract(rome_list) # print(\"end result: %s\" % result) print(\"%s\" % result) ","date":"2020-07-30","objectID":"/python_rome_number_programming/:7:0","tags":["Python","進制","演算法","NPSC","羅馬數字"],"title":"Python 解決羅馬數字轉換 NPSC 模擬試題","uri":"/python_rome_number_programming/"},{"categories":["Python"],"content":"運行結果 運行結果1.png \" 運行結果 ","date":"2020-07-30","objectID":"/python_rome_number_programming/:8:0","tags":["Python","進制","演算法","NPSC","羅馬數字"],"title":"Python 解決羅馬數字轉換 NPSC 模擬試題","uri":"/python_rome_number_programming/"},{"categories":["Python"],"content":"結論 其實我在高中剛接觸 Code 時，也寫過這題，當時怎麼寫就是寫不出來，明明測資輸入輸出都是正確的，我那時的邏輯思路沒有現在那麼好，現在因為接觸大量的 Code，所以寫 Code 都會具有強烈邏輯性和很多註解。祝各位也能順利解決這題，沒有你想像中的難。 ","date":"2020-07-30","objectID":"/python_rome_number_programming/:9:0","tags":["Python","進制","演算法","NPSC","羅馬數字"],"title":"Python 解決羅馬數字轉換 NPSC 模擬試題","uri":"/python_rome_number_programming/"},{"categories":["Python"],"content":"Reference 高中生解題系統 a013 題目 ","date":"2020-07-30","objectID":"/python_rome_number_programming/:10:0","tags":["Python","進制","演算法","NPSC","羅馬數字"],"title":"Python 解決羅馬數字轉換 NPSC 模擬試題","uri":"/python_rome_number_programming/"},{"categories":["Linux"],"content":"前言 npm（Node Package Manager）是 node 包管理器，是 Node.js 預設的、以 JavaScript 編寫的軟體套件管理系統。相信各位在開發 Vue 或是快應用等方面都會用到 npm，這裡我寫一下關於 npm 在 Linux 上的配置，因為在 Linux 使用 npm，因為在使用 npm 安裝套件時會發生權限不足問題還有下載源速度過慢，我將在這篇文章教大家如何配置 npm。 ","date":"2020-02-06","objectID":"/linux_npm_configuration/:1:0","tags":["ArchLinux","Linux","npm"],"title":"Linux 配置 npm","uri":"/linux_npm_configuration/"},{"categories":["Linux"],"content":"安裝 npm 裝 npm 時，會幫你也裝 nodeJS等相關依賴。 sudo pacman -S npm ","date":"2020-02-06","objectID":"/linux_npm_configuration/:2:0","tags":["ArchLinux","Linux","npm"],"title":"Linux 配置 npm","uri":"/linux_npm_configuration/"},{"categories":["Linux"],"content":"npm 本地化 在家目錄建立資料夾 mkdir ~/.npm-global 設置 npm 的目標資料夾 npm config set prefix '~/.npm-global' 加入本地環境變量 如果你有安裝使用 ZSH，也需要在 ~/.zshrc 引入環境變量。 vim ~/.profile # 編輯本地環境變量 vim ~/.zshrc 添加以下內容，如果沒有 ~/.profile 就自己新建。 export PATH=~/.npm-global/bin:$PATH # 加入的變量 重置環境變量 輸入以下指令後記得要重新登出登入電腦。 source ~/.profile source ~/.zshrc ","date":"2020-02-06","objectID":"/linux_npm_configuration/:3:0","tags":["ArchLinux","Linux","npm"],"title":"Linux 配置 npm","uri":"/linux_npm_configuration/"},{"categories":["Linux"],"content":"設置國內鏡像 在牆內使用國內鏡像資源會更方便。 淘寶源 # 臨時使用 # XXX 為你要安裝的套件代稱 npm --registry https://registry.npm.taobao.org install XXX # 永久使用 npm config set registry https://registry.npm.taobao.org cnpmjs 源 直接使用 cnpmjs 替代 npm。 # 透過淘寶源安裝 cnpm npm install -g cnpm --registry=https://registry.npm.taobao.org 使用 cnpm： cnpm install XXX # XXX 為你要安裝的套件代稱 ","date":"2020-02-06","objectID":"/linux_npm_configuration/:4:0","tags":["ArchLinux","Linux","npm"],"title":"Linux 配置 npm","uri":"/linux_npm_configuration/"},{"categories":["Linux"],"content":"結論 蠻簡單的，各位別想太複雜。 ","date":"2020-02-06","objectID":"/linux_npm_configuration/:5:0","tags":["ArchLinux","Linux","npm"],"title":"Linux 配置 npm","uri":"/linux_npm_configuration/"},{"categories":["Linux"],"content":"Reference Resolving EACCES permissions errors when installing packages globally - npmjs npm配置国内镜像资源+淘宝镜像 - CSDN ","date":"2020-02-06","objectID":"/linux_npm_configuration/:6:0","tags":["ArchLinux","Linux","npm"],"title":"Linux 配置 npm","uri":"/linux_npm_configuration/"},{"categories":["ArchLinux"],"content":"前言 這次之所以會有本次教學，是因為我大二上參加 2019 服創比賽，因為快應用開發 IDE 只有 *.deb 的 Ubuntu 版本，我當時將 *.deb 轉成 tar.gz 適用 Arch 發行版的包失敗，當時我是看這網站使用 Debtap 工具，雖然最後成功轉成 tar.gz，但是安裝時卻輸出該包的結構損壞，我也有在網上看到有建議 dkpg，然而實際上寫 PKGBUILD 才是最好的方法，當時是我朋友將快應用的官方 IDE 打包到 AUR 上，最後安裝成功，打包中途他也遇到很多坑，最後他寫了一篇 Arch Linux 打包教學，但他這篇卻沒有給出實例，讓大多數第一次打包的人看不懂，就跟看官方文檔一樣。網上詳細優質的打包教學少之又少，這次我藉著一個機會體會到打包的過程，為了紀錄這過程，我寫了這篇教學。 本次文章參考了 ArchWiki 的 Creating packages (简体中文)、PKGBUILD (简体中文) 和書術方隅。你可以認為我這篇是這三篇的綜合進化版。 ","date":"2020-01-31","objectID":"/archlinux_makepkg/:1:0","tags":["ArchLinux","Linux","PKGBUILD","Package","AUR"],"title":"Arch Linux 打包教學","uri":"/archlinux_makepkg/"},{"categories":["ArchLinux"],"content":"簡述 創建 PKGBUILD – 一個包創建描述文件，由 makepkg 使用來從原始碼創建二進位制包。Arch 套裝軟體標準包含當前規則和提高套裝軟體質量的方法。如果已經有了 PKGBUILD 文件，請參考 makepkg (簡體中文)。 打包前一定要先 Google 一下你要打包的軟體包是不是已經有人上傳到 AUR 了。 ","date":"2020-01-31","objectID":"/archlinux_makepkg/:2:0","tags":["ArchLinux","Linux","PKGBUILD","Package","AUR"],"title":"Arch Linux 打包教學","uri":"/archlinux_makepkg/"},{"categories":["ArchLinux"],"content":"準備工作 ","date":"2020-01-31","objectID":"/archlinux_makepkg/:3:0","tags":["ArchLinux","Linux","PKGBUILD","Package","AUR"],"title":"Arch Linux 打包教學","uri":"/archlinux_makepkg/"},{"categories":["ArchLinux"],"content":"必需的軟體包 首先，確定你已安裝必須的工具包。安裝 base-devel 應該足夠了；它包含 make 和 makepkg 其它一些從原始碼編譯時所需要的工具。 創建包的一個很重要的工具是 makepkg（由 pacman 提供），它主要做以下工作： 檢查相關依賴是否安裝。 從指定的伺服器下載源文件。 解壓源文件。 編譯軟體並將它安裝於偽 root 環境下。 刪除二進位制文件和庫文件的符號連接。 生成包的 meta 文件。 將偽 root 環境壓縮成一個包文件。 將生成的包文件保存到配置的文件夾中（預設為當前工作目錄）。 sudo pacman -S base-devel # 安裝 base-devel ","date":"2020-01-31","objectID":"/archlinux_makepkg/:3:1","tags":["ArchLinux","Linux","PKGBUILD","Package","AUR"],"title":"Arch Linux 打包教學","uri":"/archlinux_makepkg/"},{"categories":["ArchLinux"],"content":"下載與測試安裝 - 觀察紀錄 下載你想打包的軟體的原始碼壓縮包，解壓，按照作者所說的步驟安裝它。記錄下在編譯和安裝軟體過程中需要的所有命令或步驟。你將要在 PKGBUILD文件中重複這些命令和步驟。 大多數軟體作者遵循三步走的安裝慣例： ./configure make make install 註：這裡的意思是要你將包下載下來按照作者寫的使用說明試安裝這個包，並紀錄這個包的所有安裝指令與步驟。因為我們後面會在寫 PKGBUILD 裡面用到這些。 ","date":"2020-01-31","objectID":"/archlinux_makepkg/:3:2","tags":["ArchLinux","Linux","PKGBUILD","Package","AUR"],"title":"Arch Linux 打包教學","uri":"/archlinux_makepkg/"},{"categories":["ArchLinux"],"content":"創建PKGBUILD 當你運行 makepkg 時，它會在當前工作目錄尋找一個 PKGBUILD 文件。如果找到 PKGBUILD 文件，它會下載該軟體的原始碼，根據 PKGBUILD 文件中的指令編譯它。PKGBUILD 中的指令必須能完全被 Bash 解釋。成功完成後，最後的二進位制文件和包的元訊息（即包的版本、依賴）被一起打包在 pkgname.pkg.tar.xz 文件包中，這個文件包可以使用 pacman -U \u003cpackage file\u003e 來安裝。 要開始製作一個包，你應該先創建一個空工作目錄，進入該目錄，創建一個 PKGBUILD 文件。 註：假設我是在 ~ 新建工作資料夾名為 work 作為工作目錄。 cd ~ # 進入家目錄 mkdir work # 新增 work 資料夾 cd work/ # 進入 work 資料夾 touch PKGBUILD # 新增 PKGBUILG ","date":"2020-01-31","objectID":"/archlinux_makepkg/:4:0","tags":["ArchLinux","Linux","PKGBUILD","Package","AUR"],"title":"Arch Linux 打包教學","uri":"/archlinux_makepkg/"},{"categories":["ArchLinux"],"content":"依樣畫葫蘆 ","date":"2020-01-31","objectID":"/archlinux_makepkg/:5:0","tags":["ArchLinux","Linux","PKGBUILD","Package","AUR"],"title":"Arch Linux 打包教學","uri":"/archlinux_makepkg/"},{"categories":["ArchLinux"],"content":"模板 你可以複製 PKGBUILD 模板（位於 /usr/share/pacman/）到工作目錄，或者複製一個類似包的 PKGBUILD 也可以。如果你只想在別人的基礎上更改一些選項的話，後一種方法比較方便。 在 /usr/share/pacman/ 裡面有三份模板： 查看 PKGBUILD 模板1.png \" 查看 PKGBUILD 模板 PKGBUILD.proto: 經典原型。 PKGBUILD-split.proto: 分包原型。 PKGBUILD-vcs.proto: 如果你要打包的軟體原始碼上源來自 Git, SVN, Mercurial 這類版本控制系統(Version control systems, VCS)，請參考這份原型作為基礎。 我是直接將 PKGBUILD.proto 的內容複製然後貼到我的 ~/work/PKGBUILD 裡面，然後參考別人寫的 PKGBUILD。 ","date":"2020-01-31","objectID":"/archlinux_makepkg/:5:1","tags":["ArchLinux","Linux","PKGBUILD","Package","AUR"],"title":"Arch Linux 打包教學","uri":"/archlinux_makepkg/"},{"categories":["ArchLinux"],"content":"AUR PKGBUILD 範例 AUR 上有很用使用者上傳的包，可以參考他們寫的 PKGBUILD，這樣可以省去很多錯誤的寫法。在頁面的右側通常找一找都能找到。我就在這裡舉一些例子。 AUR 上的 PKGBUILD 範例02.png \" AUR 上的 PKGBUILD 範例 Upstream 包源是 .tar.xz kate Upstream 包源是 .deb quickapp-ide Upstream 源是零散文件 code 需要用 wine 模擬的軟體 foobar2000 ","date":"2020-01-31","objectID":"/archlinux_makepkg/:5:2","tags":["ArchLinux","Linux","PKGBUILD","Package","AUR"],"title":"Arch Linux 打包教學","uri":"/archlinux_makepkg/"},{"categories":["ArchLinux"],"content":"編寫 PKGBUILD 下面是我 usr/share/pacman/PKGBUILD.proto 的內容。 # This is an example PKGBUILD file. Use this as a start to creating your own, # and remove these comments. For more information, see 'man PKGBUILD'. # NOTE: Please fill out the license field for your package! If it is unknown, # then please put 'unknown'. # Maintainer: Your Name \u003cyouremail@domain.com\u003e pkgname=NAME pkgver=VERSION pkgrel=1 epoch= pkgdesc=\"\" arch=() url=\"\" license=('GPL') groups=() depends=() makedepends=() checkdepends=() optdepends=() provides=() conflicts=() replaces=() backup=() options=() install= changelog= source=(\"$pkgname-$pkgver.tar.gz\" \"$pkgname-$pkgver.patch\") noextract=() md5sums=() validpgpkeys=() prepare() { cd \"$pkgname-$pkgver\" patch -p1 -i \"$srcdir/$pkgname-$pkgver.patch\" } build() { cd \"$pkgname-$pkgver\" ./configure --prefix=/usr make } check() { cd \"$pkgname-$pkgver\" make -k check } package() { cd \"$pkgname-$pkgver\" make DESTDIR=\"$pkgdir/\" install } ","date":"2020-01-31","objectID":"/archlinux_makepkg/:6:0","tags":["ArchLinux","Linux","PKGBUILD","Package","AUR"],"title":"Arch Linux 打包教學","uri":"/archlinux_makepkg/"},{"categories":["ArchLinux"],"content":"PKGBUILD 通常需要修改的屬性變量 註：在修改變量時，如果覺得有些變量不知道怎麼填，像是 depends，你不知道這軟體需要哪些依賴，這個時候你需要查看一下他們說明文檔，也或者有些軟體包下載下來後 解壓會有相關說明文檔，像我就直接將我下下來的 *.deb 解壓，查看裡面的說明文件。 pkgname：套件的名稱，由小寫字母、數字和下面字符組成：@ . _ + -，不能以符號作為開頭。軟體名稱應要與來源壓縮檔相符。e.g. 檔名叫做 kate-19.12.1.tar.xz，則 pkgname=kate。 pkgver：套件版本，應與上游作者發行版本一致，可包含字母、數字、日期、下劃線，但不可包含連字符號(-)，如果有請替換成下劃線。e.g. pkgver=2.5、pkgver=2_5.5。 pkgrel：釋出號，一個正整數，當同個套件版本的 PKGBUILD 更新，釋出號增加 1，當套件發佈新版本時，釋出號重置 1。 pkgdesc：套件的描述，建議少於 80 字符，建議不要使用套件名稱，除非安裝的套件名稱與該應用程式名稱不同。可以填中文。e.g. pkgdesc=\"The Open Source build of Visual Studio Code (vscode) editor\"。 arch：應用程式支援的架構，Arch 官方僅支援 x86_64。 url：套件的上源發佈網址。e.g. url=\"https://www.quickapp.cn/docCenter/IDEPublicity\"。 license：該軟體、套件採用的發佈許可證，在 [core] 的 license 包中有常用的許可證，安裝後可在 /usr/share/licenses/common 找到這些許可證協議，如果套件使用的許可證是裡面其中一個，這個值應該被設為許可證的目錄名稱，如果套件使用的許可證沒有在裡面，值設為 custom。關於 license 詳細寫部份我在後面會補充說明。 depends：套件執行時所需的依賴列表，可以用比較運算符來限制依賴版本，如：depends=('foobar\u003e=1.8.0')，不需要列出二次依賴，舉例來說，gtk2 依賴 glibc 和 glib2，而 glib2 本來就依賴 glibc，glibc 就不用加入依賴列表。e.g. depends=(fontconfig libxtst gtk3 python cairo alsa-lib nss gcc-libs libnotify libxss 'glibc\u003e=2.28-4' lsof which)。 outdepends：不影響軟體主要功能，提供額外特性的軟體包，要簡要說明每個包提供的功能。e.g. optdepends=( 'cups: printing support' 'sane: scanners support' 'libgphoto2: digital cameras support' 'alsa-lib: sound support' 'giflib: GIF images support' 'libjpeg: JPEG images support' 'libpng: PNG images support' ) makedepends：編譯時所需的依賴，可以像 depends 指定依賴版本，編譯時會將 depends 的軟體包預設作為編譯依賴，使用 makepkg 構件時 base-devel 視為已安裝，base-devel 的成員不應該出現在列表中，可用下面指令檢查一個依賴關係是否已存在 base-devel 中。 LC_ALL=C pacman -Si $(pactree -rl ''package'') 2\u003e/dev/null | grep -q \"^Groups *:.*base-devel\" source：構件軟體的來源，通常是 HTTP 或 FTP 網址，可以調用前面的 pkgname 和 pkgver，就是需要填這軟體的下載源，其中包含了這軟件包的 license 檔案源，e.g. quickapp-ide 的下載源是 \"https://statres.quickapp.cn/quickapp/ide/quickapp-ide-1.5.0.deb\" license 檔案在 https://statres.quickapp.cn/quickapp/quickapp/201809/file/201809171830002525474.docx 所以我們應該在 source 填上： source=( \"https://statres.quickapp.cn/quickapp/ide/${pkgname}-${pkgver}.deb\" \"https://statres.quickapp.cn/quickapp/quickapp/201809/file/201809171830002525474.docx\" ) md5sums/sha1sums/sha256sums：source 所列檔案校驗和，不需要自己填寫，用 updpkgsums 產生，或是用 makepkg -g \u003e\u003e PKGBUILD 產生。這階段還不需要輸入該指令。 ","date":"2020-01-31","objectID":"/archlinux_makepkg/:6:1","tags":["ArchLinux","Linux","PKGBUILD","Package","AUR"],"title":"Arch Linux 打包教學","uri":"/archlinux_makepkg/"},{"categories":["ArchLinux"],"content":"PKGBUILD 變數 makepkg 定義了兩個變數，在寫構建、安裝過程指令中會用到，在 packge() 函數中用的多。 srcdir makepkg 會將來源檔案解壓縮到這個目錄，或著在此目錄產生指向 PKGBUILD 中 source 陣列中的軟連結。 pkgdir makepkg 會把此目錄當作系統根目錄，將軟體安裝在此目錄下。 ","date":"2020-01-31","objectID":"/archlinux_makepkg/:6:2","tags":["ArchLinux","Linux","PKGBUILD","Package","AUR"],"title":"Arch Linux 打包教學","uri":"/archlinux_makepkg/"},{"categories":["ArchLinux"],"content":"PKGBUILD 通常需要修改的函數 當構建一個軟體包，如果 PKGBUILD 有定義下面五個函數，makepkg 將會觸發它們，而 package() 是必須被定義的，其他沒定義的函數在構建時將會跳過。 prepare() 用來執行構建來源的指令，此函數執行在 build() 之前，軟體包解壓之後，可以用 makepkg --noextract 跳過此函數執行。通常是建立資料夾和解壓下載下來的軟體包。 pkgver() 構件 VSC 軟體包時，軟體的版本可能每隔幾小時就更新，這時用 pkgver()。 build() 這個函數使用通用 Bash 指令編譯軟體並建立軟體安裝目錄，在 build() 的第一步就是進入解壓縮原始碼後的目錄。makepkg 會在執行 build() 前進入 $srcdir，大多情況第一條指令是： cd \"$srcdir/$pkgname-$pkgver\" 接下來編寫編譯要用到的指令，build() 會在 fakeroot 環境下執行，如果你要打包的軟體使用到了配置指令碼 (configure script)，使用參數 --prefix=/usr 是個好習慣，很多軟體在手動編譯安裝的時候會安裝到 /usr/local，但所有的 Arch 包應該安裝到 /usr 目錄。 ./configure --prefix=/usr make check() 用來執行 make check 或其他例行測試的地方，建議用 check() 去檢查軟體是否正確編譯且能正常執行。 若使用者不需要這步可以在 PKGBUILD/makepkg.conf 加入 BUILDENV+=('!check') 禁用，或是在執行 makepkg 加上參數 --nocheck。 package() 最後一步就是把編譯好的檔案放到一個目錄讓 makepkg 可以檢索並打包，這個目錄通常是 pkg，一個 fakeroot 環境，pkg 目錄複製了軟體安裝根目錄的階層關係，如果你手動放置了一個檔案到根目錄，那你也要把檔案放在 pkg 中相同的層級結構中，假設你想要把檔案安裝到 /usr/bin，在 fakeroot 環境中對應的路徑應該是 $pkgdir/usr/bin，極少情況會需要使用者手動去安裝檔案，一般情況使用 make install 即可將軟體安裝到正確的路徑，最後一行通常這樣寫： make DESTDIR=\"$pkgdir/\" install makepkg --repackage 只執行 package()，不執行 build()，如果僅修改包的依賴可以用這個指令重新打包以節省時間。 ","date":"2020-01-31","objectID":"/archlinux_makepkg/:6:3","tags":["ArchLinux","Linux","PKGBUILD","Package","AUR"],"title":"Arch Linux 打包教學","uri":"/archlinux_makepkg/"},{"categories":["ArchLinux"],"content":"補充 deb 包 關於 *.deb 寫 PKGBUILD 時不需要寫 check() 和 build()，因為 *.deb 本身就是二進制包，所以不需要再編譯成二進制包。 license 關於 license 我獨立出來補充說明，通常關於該軟體的 license 可以在該 Upstream（包源）找的到，或是下載下來的軟體包說明文件裡有，如果作者沒有寫 license 就不能隨意上傳 AUR，然後如果你要上傳的軟體包的 license 屬性在 /usr/share/licenses/common 可以找到，則將其值設為該值，e.g. 我有一個準備要上傳的包裡面的作者說明的 license 填的是 GPL，我就只要在那欄填寫 GPL，有多個 license 就填多個，像是 license=('GPT' 'LGPL' 'FDL')，然後 不需要將該 license 下載下來，也就是填寫 source 的時候不需要將 license 源填上去，再次強調不需要下載下來，除非 /usr/share/licenses/common 找不到跟該軟體包相符的 license 時候才需要在 source 填寫 license 檔案源，並在後面將 license 下載下來，接著 license 那欄寫 custom。 # 通用許可證 $ ls /usr/share/licenses/common AGPL APACHE CCPL EPL FDL1.3 GPL3 LGPL3 MPL2 PSF W3C AGPL3 Artistic2.0 CDDL FDL GPL LGPL LPPL PerlArtistic RUBY ZPL Apache Boost CPL FDL1.2 GPL2 LGPL2.1 MPL PHP Unlicense 如果你的 license 需要下載下來，則授權要安裝到 /usr/share/licenses/pkgname/，把下面指令寫入 PKGBUILD 的 package()： install -Dm 644 LICENSE \"$pkgdir/usr/share/licenses/$pkgname/LICENSE\" e.g. quickapp-ide 寫的 PKGBUILD： package() { install -Dm 644 201809171830002525474.docx \"$pkgdir/usr/share/licenses/$pkgname/LICENSE.docx\" cd \"$pkgname-$pkgver\" # install -d opt/quickAppIDE # cp opt/quickAppIDE ${pkgdir} # make DESTDIR=\"$pkgdir/\" install cp -r ./ ${pkgdir}/ } ","date":"2020-01-31","objectID":"/archlinux_makepkg/:6:4","tags":["ArchLinux","Linux","PKGBUILD","Package","AUR"],"title":"Arch Linux 打包教學","uri":"/archlinux_makepkg/"},{"categories":["ArchLinux"],"content":"md5sums 當我們在 ~/work/PKGBUILD 寫完我們的 PKGBUILD 後，接下來就是更新校驗的值，這時我們又要回到上面看一下 PKGBUILD 有一個參數是 md5sums/sha1sums/sha256sums，這裡就是我們要填上他的時候，在 Konsole 進入 /work 目錄下輸入以下指令： makepkg -g \u003e\u003e PKGBUILD 接下來你就可以在你寫的 PKGBUILD 文件裡看到文件末以填上 md5sums 屬性的內容。 ","date":"2020-01-31","objectID":"/archlinux_makepkg/:7:0","tags":["ArchLinux","Linux","PKGBUILD","Package","AUR"],"title":"Arch Linux 打包教學","uri":"/archlinux_makepkg/"},{"categories":["ArchLinux"],"content":"構建軟體包 各位最艱辛的寫 PKGBUILD 已經結束了，接下來就是我們的打包時刻了。 ","date":"2020-01-31","objectID":"/archlinux_makepkg/:8:0","tags":["ArchLinux","Linux","PKGBUILD","Package","AUR"],"title":"Arch Linux 打包教學","uri":"/archlinux_makepkg/"},{"categories":["ArchLinux"],"content":"用 zstd 來取代 xz 算法 系統預設使用的壓縮演算法是 xz，速度比較慢，推薦使用 zstd 算法，雖然 xz 打包出來的檔案相對小一點，但是壓縮時間和解壓縮時間都比 zstd 長很多，官方目前也建議用 zstd 來發佈，如果只是自己電腦安裝的話可以選擇不壓縮直接安裝。 編輯 /etc/makepkg.conf，找到最下面的 PKGEXT 修改裡面的值。 不壓縮 PKGEXT='.pkg.tar' zstd 算法 PKGEXT='.pkg.tar.zst' ","date":"2020-01-31","objectID":"/archlinux_makepkg/:8:1","tags":["ArchLinux","Linux","PKGBUILD","Package","AUR"],"title":"Arch Linux 打包教學","uri":"/archlinux_makepkg/"},{"categories":["ArchLinux"],"content":"構建 第一次構建先直接執行 makepkg -s，如果報錯後修改 PKGBUILD，下一次再構建的時候傳入參數 --repackage 直接執行打包函數，這樣可以節省一些時間。 註：這裡蠻坑的，如果出一個錯造成構建失敗，就要重新來過，要將因構建過程產生的資料夾或文件全砍掉。 makepkg --repackage 構建完成後如果你是用 zstd 算法 你就可以在 /work 產生一個包名為$pkgname-$pkgver.pkg.tar.zst。 ","date":"2020-01-31","objectID":"/archlinux_makepkg/:8:2","tags":["ArchLinux","Linux","PKGBUILD","Package","AUR"],"title":"Arch Linux 打包教學","uri":"/archlinux_makepkg/"},{"categories":["ArchLinux"],"content":"測試 PKGBUILD 與上傳至 AUR 關於這部份我就支持一下我參考的作者的文章，接下來的教學部份請看他後續寫的篇章。我這篇算是補足他前面不完美的部份。 ","date":"2020-01-31","objectID":"/archlinux_makepkg/:8:3","tags":["ArchLinux","Linux","PKGBUILD","Package","AUR"],"title":"Arch Linux 打包教學","uri":"/archlinux_makepkg/"},{"categories":["ArchLinux"],"content":"Reference 将 DEB 软件包转换成 Arch Linux 软件包 - Linux 中國 Creating packages (简体中文) - ArchWiki PKGBUILD (简体中文) - ArchWiki Arch Linux 第一次打包就上手 - 書術方隅 makepkg (簡體中文) - ArchWiki ","date":"2020-01-31","objectID":"/archlinux_makepkg/:9:0","tags":["ArchLinux","Linux","PKGBUILD","Package","AUR"],"title":"Arch Linux 打包教學","uri":"/archlinux_makepkg/"},{"categories":["Linux"],"content":"前言 我在這篇會分享我是如何在 Arch 上配置 Java 的開發環境。再來我必須說的是，我這個適用於你的電腦的 Linux SSD (root) 空間不夠的情況，大部分的人是 Windows 與 Linux 雙系統，像我只能把 SSD 割 30GB 給我 Linux (這是因為我電腦上的 Windows 有被廠商更改過，限制了割出的量)，而虛擬硬碟卻可以割到 100GB 以上，我會教大家如何將 Java 環境裝到 /home。如果覺得自己 SSD 夠用，就直接從 AUR 上 yay 下來，直接略過此次教學 (ﾒ ﾟ皿ﾟ)ﾒ，畢竟會有人覺得我這樣的做法讓系統管理有點髒。不過關於環境變量的配置可以參考我這篇文章，不管是裝在 SSD 還是 HDD。 ","date":"2020-01-28","objectID":"/linux_java_tomcat_maven_intellijidea_install_configuration/:1:0","tags":["ArchLinux","Linux","Java","JDK","Tomcat","Maven","IntelliJ","IDEA"],"title":"在 Linux 配置 Java 開發環境到虛擬硬碟 - Java8、Tomcat8、Maven3、IntelliJ IDEA","uri":"/linux_java_tomcat_maven_intellijidea_install_configuration/"},{"categories":["Linux"],"content":"JDK 版本選擇 ","date":"2020-01-28","objectID":"/linux_java_tomcat_maven_intellijidea_install_configuration/:2:0","tags":["ArchLinux","Linux","Java","JDK","Tomcat","Maven","IntelliJ","IDEA"],"title":"在 Linux 配置 Java 開發環境到虛擬硬碟 - Java8、Tomcat8、Maven3、IntelliJ IDEA","uri":"/linux_java_tomcat_maven_intellijidea_install_configuration/"},{"categories":["Linux"],"content":"JDK 1.xxx 和 JDK xxx.0 比如 jdk 1.8 和 jdk 8 參考自這網站的介紹。 Sun 公司看別人的語言更新都更新到 xxx 了，自己的 Java 版本還是 1 點幾，讓人感覺很落後，所以在 jdk 1.6 的時候對外發布稱之為 jdk 6.0 ，讓人感覺更先進點。在寫 Java 的人眼裡都是叫 1.6 的，基本沒人說 6.0.。 ","date":"2020-01-28","objectID":"/linux_java_tomcat_maven_intellijidea_install_configuration/:2:1","tags":["ArchLinux","Linux","Java","JDK","Tomcat","Maven","IntelliJ","IDEA"],"title":"在 Linux 配置 Java 開發環境到虛擬硬碟 - Java8、Tomcat8、Maven3、IntelliJ IDEA","uri":"/linux_java_tomcat_maven_intellijidea_install_configuration/"},{"categories":["Linux"],"content":"推薦的 JDK 版本 參考自這篇文章。 我推薦的是 JDK 1.8 版本，也就是 Java 8，因為它足夠穩定，對一些套件的依賴與支持完整高，也是目前新手入門最好的 JDK 版本。至於 1.8 以前的版本都不推薦因為過於老舊，目前 JDK 1.8 以後的版本不怎麼穩定，但如果想要嘗試新的開源項目可以嘗試最版本。 ","date":"2020-01-28","objectID":"/linux_java_tomcat_maven_intellijidea_install_configuration/:2:2","tags":["ArchLinux","Linux","Java","JDK","Tomcat","Maven","IntelliJ","IDEA"],"title":"在 Linux 配置 Java 開發環境到虛擬硬碟 - Java8、Tomcat8、Maven3、IntelliJ IDEA","uri":"/linux_java_tomcat_maven_intellijidea_install_configuration/"},{"categories":["Linux"],"content":"下載 JDK 1.8 至 Oracle Java 下載處下載你要的 JDK 包，JDK 1.8。 註：下載需要註冊 Oracle 帳號，這裡要感謝網上的有些善心人士提供共享帳號。 Oracle 帳號：2696671285@qq.com Oracle 密碼：Oracle123 帳號來源 像我是下載這個。 JDK 1.8jdk.png \" JDK 1.8 下載下來 *.tar.gz 後將其解壓，將資料夾放入 ~/.local/usr/lib/jvm/ 路徑裡，如果沒有路徑資料夾就自己創建。 ","date":"2020-01-28","objectID":"/linux_java_tomcat_maven_intellijidea_install_configuration/:3:0","tags":["ArchLinux","Linux","Java","JDK","Tomcat","Maven","IntelliJ","IDEA"],"title":"在 Linux 配置 Java 開發環境到虛擬硬碟 - Java8、Tomcat8、Maven3、IntelliJ IDEA","uri":"/linux_java_tomcat_maven_intellijidea_install_configuration/"},{"categories":["Linux"],"content":"下載 Tomcat 8 Tomcat 這裡我目前也比較推薦 Tomcat 8，目前 Tomcat 最新版出到 9，但是我實際做項目的時候發現 Tomcat 9 對於代碼的規範要求很多，不按照 Tomcat 9 的規範走會有很多警告，也影響開發時的觀感。 下載 Tomcat 8 Tomcat 8tomcat.png \" Tomcat 8 解壓後將資料夾放入 ~/.local/opt/tomcat/。如果沒有路徑資料夾就自己創建。 ","date":"2020-01-28","objectID":"/linux_java_tomcat_maven_intellijidea_install_configuration/:4:0","tags":["ArchLinux","Linux","Java","JDK","Tomcat","Maven","IntelliJ","IDEA"],"title":"在 Linux 配置 Java 開發環境到虛擬硬碟 - Java8、Tomcat8、Maven3、IntelliJ IDEA","uri":"/linux_java_tomcat_maven_intellijidea_install_configuration/"},{"categories":["Linux"],"content":"下載 Maven 3 Maven 3 Maven 3maven.png \" Maven 3 解壓後將資料夾放入 ~/.local/opt/maven/。如果沒有路徑資料夾就自己創建。 ","date":"2020-01-28","objectID":"/linux_java_tomcat_maven_intellijidea_install_configuration/:5:0","tags":["ArchLinux","Linux","Java","JDK","Tomcat","Maven","IntelliJ","IDEA"],"title":"在 Linux 配置 Java 開發環境到虛擬硬碟 - Java8、Tomcat8、Maven3、IntelliJ IDEA","uri":"/linux_java_tomcat_maven_intellijidea_install_configuration/"},{"categories":["Linux"],"content":"編輯 Tomcat 假設你的 JDK 版本是 jdk1.8.0_241。Tomcat 是 apache-tomcat-8.5.47。Maven 是 apache-maven-3.6.2。如果你的版本跟我不一致，就自行修改版本號。 編輯 ~/.local/opt/tomcat/apache-tomcat-8.5.47/bin/startup.sh，於文件末添加 JDK、JRE 配置內容： #java8 export JAVA_HOME=~/.local/usr/lib/jvm/jdk1.8.0_241 export JRE_HOME=${JAVA_HOME}/jre export CLASSPATH=.:${JAVA_HOME}/lib:${JRE_HOME}/lib export PATH=${JAVA_HOME}/bin:$PATH #tomcat8 export TOMCAT_HOME=~/.local/opt/tomcat/apache-tomcat-8.5.47 ","date":"2020-01-28","objectID":"/linux_java_tomcat_maven_intellijidea_install_configuration/:6:0","tags":["ArchLinux","Linux","Java","JDK","Tomcat","Maven","IntelliJ","IDEA"],"title":"在 Linux 配置 Java 開發環境到虛擬硬碟 - Java8、Tomcat8、Maven3、IntelliJ IDEA","uri":"/linux_java_tomcat_maven_intellijidea_install_configuration/"},{"categories":["Linux"],"content":"編輯 .profile 在 ~/.profile 添加以下內容，編輯完後執行 source ~/.profile 重新加載環境變量，使配置生效。然後登出登入一次電腦。 #java8 export JAVA_HOME=~/.local/usr/lib/jvm/jdk1.8.0_241 export JRE_HOME=${JAVA_HOME}/jre export CLASSPATH=.:${JAVA_HOME}/lib:${JRE_HOME}/lib export PATH=${JAVA_HOME}/bin:$PATH #tomcat8 export CATALINA_HOME=~/.local/opt/tomcat export CLASSPATH=.:$JAVA_HOME/lib:$CATALINA_HOME/lib export PATH=$PATH:$CATALINA_HOME/bin export CLASSPATH=$CLASSPATH:%JAVA_HOME/lib/tools.jar export TOMCAT_HOME=~/.local/opt/tomcat/apache-tomcat-8.5.47 export CATALINA_HOME=$TOMCAT_HOME export PATH=$PATH:TOMCAT_HOME/bin #maven3 MAVEN_HOME=~/.local/opt/maven/apache-maven-3.6.2 export MAVEN_HOME export PATH=${PATH}:${MAVEN_HOME}/bin ","date":"2020-01-28","objectID":"/linux_java_tomcat_maven_intellijidea_install_configuration/:7:0","tags":["ArchLinux","Linux","Java","JDK","Tomcat","Maven","IntelliJ","IDEA"],"title":"在 Linux 配置 Java 開發環境到虛擬硬碟 - Java8、Tomcat8、Maven3、IntelliJ IDEA","uri":"/linux_java_tomcat_maven_intellijidea_install_configuration/"},{"categories":["Linux"],"content":"測試是否配置成功 ","date":"2020-01-28","objectID":"/linux_java_tomcat_maven_intellijidea_install_configuration/:8:0","tags":["ArchLinux","Linux","Java","JDK","Tomcat","Maven","IntelliJ","IDEA"],"title":"在 Linux 配置 Java 開發環境到虛擬硬碟 - Java8、Tomcat8、Maven3、IntelliJ IDEA","uri":"/linux_java_tomcat_maven_intellijidea_install_configuration/"},{"categories":["Linux"],"content":"JDK 在 Konsole 輸入 java -version 就會顯示 Java 版本。 Java 版本java_version.png \" Java 版本 ","date":"2020-01-28","objectID":"/linux_java_tomcat_maven_intellijidea_install_configuration/:8:1","tags":["ArchLinux","Linux","Java","JDK","Tomcat","Maven","IntelliJ","IDEA"],"title":"在 Linux 配置 Java 開發環境到虛擬硬碟 - Java8、Tomcat8、Maven3、IntelliJ IDEA","uri":"/linux_java_tomcat_maven_intellijidea_install_configuration/"},{"categories":["Linux"],"content":"Tomcat 於 ~/.local/opt/tomcat/apache-tomcat-8.5.47 目錄下打開 Konsole，啟動 Tomcat。 ./startup.sh Tomcat 運行tomcat_startup.png \" Tomcat 運行 接著打開瀏覽器輸入 http://127.0.0.1:8080/或http://localhost:8080/ 會出現以下畫面，此時代表已經配置成功。 Tomcat 運行結果tomcat_test.png \" Tomcat 運行結果 接下來輸入 ./shutdown.sh 中止 Tomcat。 中止 Tomcattomcat_shutdown.png \" 中止 Tomcat ","date":"2020-01-28","objectID":"/linux_java_tomcat_maven_intellijidea_install_configuration/:8:2","tags":["ArchLinux","Linux","Java","JDK","Tomcat","Maven","IntelliJ","IDEA"],"title":"在 Linux 配置 Java 開發環境到虛擬硬碟 - Java8、Tomcat8、Maven3、IntelliJ IDEA","uri":"/linux_java_tomcat_maven_intellijidea_install_configuration/"},{"categories":["Linux"],"content":"Maven 在 Konsole 輸入 mvn -v 就會顯示你的 Maven 版本。 Maven 版本maven_version.png \" Maven 版本 ","date":"2020-01-28","objectID":"/linux_java_tomcat_maven_intellijidea_install_configuration/:8:3","tags":["ArchLinux","Linux","Java","JDK","Tomcat","Maven","IntelliJ","IDEA"],"title":"在 Linux 配置 Java 開發環境到虛擬硬碟 - Java8、Tomcat8、Maven3、IntelliJ IDEA","uri":"/linux_java_tomcat_maven_intellijidea_install_configuration/"},{"categories":["Linux"],"content":"IntelliJ IDEA 透過國內阿里云鏡像加速建立 Maven 項目 關於如何使用 IntelliJ IDEA 建立 Tomcat 項目等我就不在這裡細說了，這些基礎的知識你們可以參考網上其它教學。 ","date":"2020-01-28","objectID":"/linux_java_tomcat_maven_intellijidea_install_configuration/:9:0","tags":["ArchLinux","Linux","Java","JDK","Tomcat","Maven","IntelliJ","IDEA"],"title":"在 Linux 配置 Java 開發環境到虛擬硬碟 - Java8、Tomcat8、Maven3、IntelliJ IDEA","uri":"/linux_java_tomcat_maven_intellijidea_install_configuration/"},{"categories":["Linux"],"content":"添加國內鏡像 編輯 ~/.local/opt/maven/apache-maven-3.6.2/conf/ 目錄下的 settings.xml，於文末添加以下內容。 \u003cmirror\u003e \u003cid\u003enexus-aliyun\u003c/id\u003e \u003cmirrorOf\u003e*\u003c/mirrorOf\u003e \u003cname\u003eNexus aliyun\u003c/name\u003e \u003curl\u003ehttp://maven.aliyun.com/nexus/content/groups/public\u003c/url\u003e \u003c/mirror\u003e ","date":"2020-01-28","objectID":"/linux_java_tomcat_maven_intellijidea_install_configuration/:9:1","tags":["ArchLinux","Linux","Java","JDK","Tomcat","Maven","IntelliJ","IDEA"],"title":"在 Linux 配置 Java 開發環境到虛擬硬碟 - Java8、Tomcat8、Maven3、IntelliJ IDEA","uri":"/linux_java_tomcat_maven_intellijidea_install_configuration/"},{"categories":["Linux"],"content":"IntelliJ IDEA 創建 Maven 項目 IntelliJ IDEA 創建 Maven 項目，如果是一般的 Maven 項目就在 Create fome archetype 選擇 maven-archetype-quickstart，如果是 Web 項目就選擇 maven-archetype-webapp。我這裡就演示建立 Web 項目。 建立項目 新建 Maven 項目IDEA_maven_create.png \" 新建 Maven 項目 項目目錄位置 設置 Project 位置IDEA_maven_location.png \" 設置 Project 位置 添加屬性 創建 Maven 項目時手動添加一個 archetypeCatalog 配置，其值設為 internal。 添加屬性IDEA_maven_property.png \" 添加屬性 Finish 後就建立好了一個 Maven Web 項目。 ","date":"2020-01-28","objectID":"/linux_java_tomcat_maven_intellijidea_install_configuration/:9:2","tags":["ArchLinux","Linux","Java","JDK","Tomcat","Maven","IntelliJ","IDEA"],"title":"在 Linux 配置 Java 開發環境到虛擬硬碟 - Java8、Tomcat8、Maven3、IntelliJ IDEA","uri":"/linux_java_tomcat_maven_intellijidea_install_configuration/"},{"categories":["Linux"],"content":"添加 Tomcat Server 在右上角的 add configuration 添加 Tomcat Server。 添加 Tomcat Server 設置IDEA_tomcat_config.png \" 添加 Tomcat Server 設置 ","date":"2020-01-28","objectID":"/linux_java_tomcat_maven_intellijidea_install_configuration/:10:0","tags":["ArchLinux","Linux","Java","JDK","Tomcat","Maven","IntelliJ","IDEA"],"title":"在 Linux 配置 Java 開發環境到虛擬硬碟 - Java8、Tomcat8、Maven3、IntelliJ IDEA","uri":"/linux_java_tomcat_maven_intellijidea_install_configuration/"},{"categories":["Linux"],"content":"Reference ubuntu16.04安装及配置tomcat,IDEA集成tomcat及部署web项目，IDEA通过阿里云镜像加速maven项目创建 java 版本區別，java SE是什麼，下載JDK時各個名稱的含義 jdk版本的选择（推荐1.8）- 知乎 Oracle官网登录下载资源账号密码共享 - AlanLee 博客園 Tomcat ( 三 )：測試 Tomcat ","date":"2020-01-28","objectID":"/linux_java_tomcat_maven_intellijidea_install_configuration/:11:0","tags":["ArchLinux","Linux","Java","JDK","Tomcat","Maven","IntelliJ","IDEA"],"title":"在 Linux 配置 Java 開發環境到虛擬硬碟 - Java8、Tomcat8、Maven3、IntelliJ IDEA","uri":"/linux_java_tomcat_maven_intellijidea_install_configuration/"},{"categories":["Linux"],"content":"前言 在 Linux 開發 Python 相關的項目，你是不是會碰到關於 Python 版本之類的問題？像是開發 Tensorflow 的時候碰到版本問題，原本 Python 3.7 可以支援 Tensorflow，但是忽然 Python 從 3.7 更新到 3.8.0，這時 Python 3.8 不支援 Tensorflow，你苦惱了，千辛萬苦的項目因為系統更新而導致版本不支援使項目暫停開發，這時 pyenv 將成為你的救星，如果你硬是不肯更新系統 Python 版本，你的系統將會得不到最新的體驗與安全並處於危險的不穩定狀態，系統更新真的很重要。 pyenv 是很棒的 Python 版本控制工具，讓你的電腦可以安裝多個 Python 版本。pyenv 是 Github 上的開源項目，關於使用須知該項目的 README.md 寫得很詳細。我這篇文章就分享一下我在 Arch Linux 的安裝方式。 ","date":"2020-01-27","objectID":"/linux_python_pyenv/:1:0","tags":["ArchLinux","Linux","Python","pyenv"],"title":"在 Linux 上控制 Python 版本 - pyenv","uri":"/linux_python_pyenv/"},{"categories":["Linux"],"content":"安裝 從 Github 倉庫上直接 clone 下來。你也可以選擇直接在瀏覽器上下來。然後壓縮包解壓將文件內的文件放入 ~/.pyenv。 註：如果你在國內網使用 Github 網速過於緩慢，建議開 Proxy，然後給 Git 設置代理。 ","date":"2020-01-27","objectID":"/linux_python_pyenv/:2:0","tags":["ArchLinux","Linux","Python","pyenv"],"title":"在 Linux 上控制 Python 版本 - pyenv","uri":"/linux_python_pyenv/"},{"categories":["Linux"],"content":"設置代理 # set http git config --global http.proxy 'socks5://127.0.0.1:1080' # set https git config --global https.proxy 'socks5://127.0.0.1:1080' # unset http git config --global --unset http.proxy # unset https git config --global --unset https.proxy npm config delete proxy ","date":"2020-01-27","objectID":"/linux_python_pyenv/:2:1","tags":["ArchLinux","Linux","Python","pyenv"],"title":"在 Linux 上控制 Python 版本 - pyenv","uri":"/linux_python_pyenv/"},{"categories":["Linux"],"content":"下載 git clone https://github.com/pyenv/pyenv.git ~/.pyenv # Basic GitHub Checkout ","date":"2020-01-27","objectID":"/linux_python_pyenv/:2:2","tags":["ArchLinux","Linux","Python","pyenv"],"title":"在 Linux 上控制 Python 版本 - pyenv","uri":"/linux_python_pyenv/"},{"categories":["Linux"],"content":"環境變量 ","date":"2020-01-27","objectID":"/linux_python_pyenv/:3:0","tags":["ArchLinux","Linux","Python","pyenv"],"title":"在 Linux 上控制 Python 版本 - pyenv","uri":"/linux_python_pyenv/"},{"categories":["Linux"],"content":"PYENV_ROOT 將 PYENV_ROOT 添加至環境變量。在 Konsole 輸入以下指令： 註：在 Arch 發行版中，~/.bash_profile 就是 ~/.profile。如果你 Shell 使用的是 ZSH，為了在 ZSH 中也能使用，記得也要寫入 ~/.zshrc。之所以要求要兩個都寫入是因為避免如果你如果換了其它 Shell 需要再重新設一次。 # .profile echo 'export PYENV_ROOT=\"$HOME/.pyenv\"' \u003e\u003e ~/.profile echo 'export PATH=\"$PYENV_ROOT/bin:$PATH\"' \u003e\u003e ~/.profile # .zshrc echo 'export PYENV_ROOT=\"$HOME/.pyenv\"' \u003e\u003e ~/.zshrc echo 'export PATH=\"$PYENV_ROOT/bin:$PATH\"' \u003e\u003e ~/.zshrc ","date":"2020-01-27","objectID":"/linux_python_pyenv/:3:1","tags":["ArchLinux","Linux","Python","pyenv"],"title":"在 Linux 上控制 Python 版本 - pyenv","uri":"/linux_python_pyenv/"},{"categories":["Linux"],"content":"pyenv init 將 pyenv init 添加到您的 Shell 中以啟用填充和自動補全功能。 請確保將 eval\" $（pyenv init-）\" 放在 Shell 配置文件的末尾，因為它在初始化期間會操縱 PATH 。 輸入以下指令： # .profile echo -e 'if command -v pyenv 1\u003e/dev/null 2\u003e\u00261; then\\n eval \"$(pyenv init -)\"\\nfi' \u003e\u003e ~/.profile # .zshrc echo -e 'if command -v pyenv 1\u003e/dev/null 2\u003e\u00261; then\\n eval \"$(pyenv init -)\"\\nfi' \u003e\u003e ~/.zshrc ","date":"2020-01-27","objectID":"/linux_python_pyenv/:3:2","tags":["ArchLinux","Linux","Python","pyenv"],"title":"在 Linux 上控制 Python 版本 - pyenv","uri":"/linux_python_pyenv/"},{"categories":["Linux"],"content":"重啟 SHELL 先重新加載環境變量文件後，重啟 Shell。 source ~/.profile source ~/.zshrc 接下來你輸入 pyenv version，應該就會顯示你目前 pyenv 使用的 Python 版本，輸入 pyenv versions 能顯示你 pyenv 中安裝的所有 Python 版本。 ","date":"2020-01-27","objectID":"/linux_python_pyenv/:4:0","tags":["ArchLinux","Linux","Python","pyenv"],"title":"在 Linux 上控制 Python 版本 - pyenv","uri":"/linux_python_pyenv/"},{"categories":["Linux"],"content":"安裝 Python 版本 我目前要使用 Python 3.7.6 的版本。 pyenv install 3.7.6 ","date":"2020-01-27","objectID":"/linux_python_pyenv/:5:0","tags":["ArchLinux","Linux","Python","pyenv"],"title":"在 Linux 上控制 Python 版本 - pyenv","uri":"/linux_python_pyenv/"},{"categories":["Linux"],"content":"設置 Shell 默認全局 Python 版本 pyenv global 3.7.6 接下來重新登出登入電腦。使用 python --version 查看 Python 版本就會發現版本已經變成 3.7.6 了。 ","date":"2020-01-27","objectID":"/linux_python_pyenv/:6:0","tags":["ArchLinux","Linux","Python","pyenv"],"title":"在 Linux 上控制 Python 版本 - pyenv","uri":"/linux_python_pyenv/"},{"categories":["Linux"],"content":"Reference pyenv / pyenv - Github Git 設置與取消代理 ","date":"2020-01-27","objectID":"/linux_python_pyenv/:7:0","tags":["ArchLinux","Linux","Python","pyenv"],"title":"在 Linux 上控制 Python 版本 - pyenv","uri":"/linux_python_pyenv/"},{"categories":["ArchLinux"],"content":"前言 Wallpapaer Engine 是非常優秀的動態桌布軟體，可惜的是這軟體不僅是需付費，也只支援 Windows，關於 KDE 動態桌布可能大家會有疑慮，Plasma KDE 究竟能不能實現動態桌布？答案是可以的，在這篇我將分享我完成動態桌布的過程。 當然，我也嘗試過使用 vlc 和 xwinwrap + mplayer，尤其是 xwinwrap 最折騰我，包括開機自啟，最後的效果都讓我不滿意。但是目前網上（包含 KDE 官網）所有關於 KDE 動態桌布的項目不是使用上不美觀或是沒效果（黑屏）。最後終於在一篇 Github 項目中看到黑屏的處理方法，無意間那些 KDE Video Wallpaper 插件都可以用了。 如果執意想使用 vlc 或是 xwinwrap + mplayer 的讀者可以參考某人的 Blog：设置 Linux 动态桌面的几种办法 - 簡書 ","date":"2020-01-15","objectID":"/archlinux_kde_video_wallpaper/:1:0","tags":["ArchLinux","Linux","kde","plasma","video","desktop","Wallpaper"],"title":"Archlinux KDE 動態桌布","uri":"/archlinux_kde_video_wallpaper/"},{"categories":["ArchLinux"],"content":"Plasma Video Wallpaper ","date":"2020-01-15","objectID":"/archlinux_kde_video_wallpaper/:2:0","tags":["ArchLinux","Linux","kde","plasma","video","desktop","Wallpaper"],"title":"Archlinux KDE 動態桌布","uri":"/archlinux_kde_video_wallpaper/"},{"categories":["ArchLinux"],"content":"WuSiYu / Plasma Video Wallpaper 這是 Github 上看到的項目，這也是因為我看到他在 B 站上的視頻才知道有這個項目。 完整項目使用過程他已經在他 Github 項目的 README.md 說得很清楚了。 先將項目下載解壓，進入項目目錄輸入以下指令： 如果沒有安裝 cmake、make 就裝一下，如果有權限問題就給權限。 sudo pacman -S cmake make # 安裝 cmake make cmake . make sudo make install 安裝完後重新登出登入重啟 Plasma。 特別注意：這個插件不能用來當鎖屏的動態桌布！我之前曾經試過利用這個將鎖屏設為動態壁紙，一開始還好好的，但是到後面慢慢出現程序問題，換回普通壁紙就好。 ","date":"2020-01-15","objectID":"/archlinux_kde_video_wallpaper/:2:1","tags":["ArchLinux","Linux","kde","plasma","video","desktop","Wallpaper"],"title":"Archlinux KDE 動態桌布","uri":"/archlinux_kde_video_wallpaper/"},{"categories":["ArchLinux"],"content":"halverneus / org.kde.video 這也是我一間發現的項目，號稱是鎖屏動態壁紙插件，但我為了執行內存空間上我還是沒用這個。但我也因為這個項目的 README.md 才發現黑屏原因。 ","date":"2020-01-15","objectID":"/archlinux_kde_video_wallpaper/:2:2","tags":["ArchLinux","Linux","kde","plasma","video","desktop","Wallpaper"],"title":"Archlinux KDE 動態桌布","uri":"/archlinux_kde_video_wallpaper/"},{"categories":["ArchLinux"],"content":"黑屏 面對黑屏怎麼辦？黑屏的原因是因為你有些插件沒有安裝。安裝 qt-gstreamer 和 gst-libav。 補充：KDE 是使用 Qt 實現的，所以系統軟體裡自帶 Qt，不能亂砍。 sudo pacman -S qt-gstreamer gst-libav 安裝完並重啟 Plasma 就可以了，我教我的幾位同學們安裝這兩個插件後動態桌布都可以實現了，不再是黑屏。 ","date":"2020-01-15","objectID":"/archlinux_kde_video_wallpaper/:3:0","tags":["ArchLinux","Linux","kde","plasma","video","desktop","Wallpaper"],"title":"Archlinux KDE 動態桌布","uri":"/archlinux_kde_video_wallpaper/"},{"categories":["ArchLinux"],"content":"桌面怖局 記的桌面布局要選擇桌面。如果選擇資料夾有可能顯示不出動態桌布。 設定動態桌布01.png \" 設定動態桌布 ","date":"2020-01-15","objectID":"/archlinux_kde_video_wallpaper/:4:0","tags":["ArchLinux","Linux","kde","plasma","video","desktop","Wallpaper"],"title":"Archlinux KDE 動態桌布","uri":"/archlinux_kde_video_wallpaper/"},{"categories":["ArchLinux"],"content":"重要補充 動態壁紙有時很吃電腦內存，如果內存小於 8GB 建議還是別使用動態桌布。 ","date":"2020-01-15","objectID":"/archlinux_kde_video_wallpaper/:5:0","tags":["ArchLinux","Linux","kde","plasma","video","desktop","Wallpaper"],"title":"Archlinux KDE 動態桌布","uri":"/archlinux_kde_video_wallpaper/"},{"categories":["ArchLinux"],"content":"Reference WuSiYu/Plasma Video Wallpaper 【原创】Linux KDE Plasma桌面 视频动态壁纸插件 设置 Linux 动态桌面的几种办法 halverneus / org.kde.video ","date":"2020-01-15","objectID":"/archlinux_kde_video_wallpaper/:6:0","tags":["ArchLinux","Linux","kde","plasma","video","desktop","Wallpaper"],"title":"Archlinux KDE 動態桌布","uri":"/archlinux_kde_video_wallpaper/"},{"categories":["ArchLinux"],"content":"前言 我想我在 Linux 上用最多也最重要的就是終端機 Konsole 了，我們默認的是 Bash，然而 bash 過於單調，也沒有自動補全，這時我們就需要開源項目 oh-my-zsh，在這篇教學我會寫一下，我配置 oh-my-zsh 的過程。 ","date":"2020-01-05","objectID":"/archlinux_install_part4_on_my_zsh/:1:0","tags":["ArchLinux","Linux","zsh","oh-my-zsh"],"title":"Archlinux 安裝 Part 4 - 程序員終端標配 oh-my-zsh","uri":"/archlinux_install_part4_on_my_zsh/"},{"categories":["ArchLinux"],"content":"我的 Konsole 我的終端機02.png \" 我的終端機 ","date":"2020-01-05","objectID":"/archlinux_install_part4_on_my_zsh/:2:0","tags":["ArchLinux","Linux","zsh","oh-my-zsh"],"title":"Archlinux 安裝 Part 4 - 程序員終端標配 oh-my-zsh","uri":"/archlinux_install_part4_on_my_zsh/"},{"categories":["ArchLinux"],"content":"Konsole 透明度設置 在標題欄點擊滑鼠右鍵。 設定透明度01.png \" 設定透明度 在外觀與修復中，可以調整透明度。我調成不透明度 80%。 ","date":"2020-01-05","objectID":"/archlinux_install_part4_on_my_zsh/:3:0","tags":["ArchLinux","Linux","zsh","oh-my-zsh"],"title":"Archlinux 安裝 Part 4 - 程序員終端標配 oh-my-zsh","uri":"/archlinux_install_part4_on_my_zsh/"},{"categories":["ArchLinux"],"content":"安裝 zsh sudo pacman -S zsh ","date":"2020-01-05","objectID":"/archlinux_install_part4_on_my_zsh/:4:0","tags":["ArchLinux","Linux","zsh","oh-my-zsh"],"title":"Archlinux 安裝 Part 4 - 程序員終端標配 oh-my-zsh","uri":"/archlinux_install_part4_on_my_zsh/"},{"categories":["ArchLinux"],"content":"查看系統當前使用的 Shell echo $SHELL # 查看指令 /bin/bash # 輸出結果 ","date":"2020-01-05","objectID":"/archlinux_install_part4_on_my_zsh/:5:0","tags":["ArchLinux","Linux","zsh","oh-my-zsh"],"title":"Archlinux 安裝 Part 4 - 程序員終端標配 oh-my-zsh","uri":"/archlinux_install_part4_on_my_zsh/"},{"categories":["ArchLinux"],"content":"看系統是否裝了 zsh cat /etc/shells # 輸入指令 # Pathnames of valid login shells. # See shells(5) for details. /bin/sh /bin/bash /usr/bin/git-shell /bin/zsh /usr/bin/zsh ","date":"2020-01-05","objectID":"/archlinux_install_part4_on_my_zsh/:6:0","tags":["ArchLinux","Linux","zsh","oh-my-zsh"],"title":"Archlinux 安裝 Part 4 - 程序員終端標配 oh-my-zsh","uri":"/archlinux_install_part4_on_my_zsh/"},{"categories":["ArchLinux"],"content":"切換 Shell 為 zsh 註：不需要加 sudo。 chsh -s /bin/zsh # 切換指令 # 輸出結果 Changing shell for root. Shell changed. 將所有終端機都關掉，或是登入登出一次，再次查看當前的 Shell 應該就是 zsh 了。 ","date":"2020-01-05","objectID":"/archlinux_install_part4_on_my_zsh/:7:0","tags":["ArchLinux","Linux","zsh","oh-my-zsh"],"title":"Archlinux 安裝 Part 4 - 程序員終端標配 oh-my-zsh","uri":"/archlinux_install_part4_on_my_zsh/"},{"categories":["ArchLinux"],"content":"安裝 oh-my-zsh 這裡或許看 github 官網會比較好。三種安裝方式，通常第一種就可以了。 ","date":"2020-01-05","objectID":"/archlinux_install_part4_on_my_zsh/:8:0","tags":["ArchLinux","Linux","zsh","oh-my-zsh"],"title":"Archlinux 安裝 Part 4 - 程序員終端標配 oh-my-zsh","uri":"/archlinux_install_part4_on_my_zsh/"},{"categories":["ArchLinux"],"content":"curl sh -c \"$(curl -fsSL https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh)\" ","date":"2020-01-05","objectID":"/archlinux_install_part4_on_my_zsh/:8:1","tags":["ArchLinux","Linux","zsh","oh-my-zsh"],"title":"Archlinux 安裝 Part 4 - 程序員終端標配 oh-my-zsh","uri":"/archlinux_install_part4_on_my_zsh/"},{"categories":["ArchLinux"],"content":"wget sh -c \"$(wget -O- https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh)\" ","date":"2020-01-05","objectID":"/archlinux_install_part4_on_my_zsh/:8:2","tags":["ArchLinux","Linux","zsh","oh-my-zsh"],"title":"Archlinux 安裝 Part 4 - 程序員終端標配 oh-my-zsh","uri":"/archlinux_install_part4_on_my_zsh/"},{"categories":["ArchLinux"],"content":"Manual inspection It’s a good idea to inspect the install script from projects you don’t yet know. You can do that by downloading the install script first, looking through it so everything looks normal, then running it: curl -Lo install.sh https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh sh install.sh ","date":"2020-01-05","objectID":"/archlinux_install_part4_on_my_zsh/:8:3","tags":["ArchLinux","Linux","zsh","oh-my-zsh"],"title":"Archlinux 安裝 Part 4 - 程序員終端標配 oh-my-zsh","uri":"/archlinux_install_part4_on_my_zsh/"},{"categories":["ArchLinux"],"content":"配置主題 我在這裡推薦的是 ys 主題。 編輯 ~/.zshrc。 vim ~/.zshrc 將 ZSH_THEME 改成 ys。 ZSH_THEME=\"ys\" ","date":"2020-01-05","objectID":"/archlinux_install_part4_on_my_zsh/:9:0","tags":["ArchLinux","Linux","zsh","oh-my-zsh"],"title":"Archlinux 安裝 Part 4 - 程序員終端標配 oh-my-zsh","uri":"/archlinux_install_part4_on_my_zsh/"},{"categories":["ArchLinux"],"content":"推薦插件 插件依然需要編輯 ~/.zshrc ，找到 plugins=，然後在裡面寫需要的插件名，有些插件可能還需要安裝。 注意：只要改了此文件，重啟終端后有效或使用 source ~/.zshrc 更新配置。 ","date":"2020-01-05","objectID":"/archlinux_install_part4_on_my_zsh/:10:0","tags":["ArchLinux","Linux","zsh","oh-my-zsh"],"title":"Archlinux 安裝 Part 4 - 程序員終端標配 oh-my-zsh","uri":"/archlinux_install_part4_on_my_zsh/"},{"categories":["ArchLinux"],"content":"extract 用來解壓縮文件，用起來很爽，根本不需要去記憶各種解壓縮指令，一套 x filmname 直接幫你解壓好。 當然，如果你想要用 tar 命令，可以使用 tar - 加 tab 鍵，zsh 會列出參數的含義。 這插件預設安裝就有，不需要額外安裝。 plugins=(其他的插件 extract) ","date":"2020-01-05","objectID":"/archlinux_install_part4_on_my_zsh/:10:1","tags":["ArchLinux","Linux","zsh","oh-my-zsh"],"title":"Archlinux 安裝 Part 4 - 程序員終端標配 oh-my-zsh","uri":"/archlinux_install_part4_on_my_zsh/"},{"categories":["ArchLinux"],"content":"zsh-autosuggestion 自動補全。可記錄之前輸過的指令。 git clone git://github.com/zsh-users/zsh-autosuggestions $ZSH_CUSTOM/plugins/zsh-autosuggestions plugins=(其他的插件 zsh-autosuggestion) ","date":"2020-01-05","objectID":"/archlinux_install_part4_on_my_zsh/:10:2","tags":["ArchLinux","Linux","zsh","oh-my-zsh"],"title":"Archlinux 安裝 Part 4 - 程序員終端標配 oh-my-zsh","uri":"/archlinux_install_part4_on_my_zsh/"},{"categories":["ArchLinux"],"content":"zsh-syntax-highlighting 終端字體高亮。 git clone https://github.com/zsh-users/zsh-syntax-highlighting.git ${ZSH_CUSTOM:-~/.oh-my-zsh/custom}/plugins/zsh-syntax-highlighting plugins=(其他的插件 zsh-syntax-highlighting) ","date":"2020-01-05","objectID":"/archlinux_install_part4_on_my_zsh/:10:3","tags":["ArchLinux","Linux","zsh","oh-my-zsh"],"title":"Archlinux 安裝 Part 4 - 程序員終端標配 oh-my-zsh","uri":"/archlinux_install_part4_on_my_zsh/"},{"categories":["ArchLinux"],"content":"git-open git-open 插件可以在你 Git 項目下打開遠程倉庫瀏覽項目。 git clone https://github.com/paulirish/git-open.git $ZSH_CUSTOM/plugins/git-open plugins=(其他的插件 extract) 使用： git open [remote-name] [branch-name] # Open the page for this branch on the repo website git open --commit git open -c # Open the current commit in the repo website git open --issue git open -i # If this branch is named like issue/#123, this will open the corresponding # issue in the repo website git open --print git open -p # Only print the url at the terminal, but don't open it ","date":"2020-01-05","objectID":"/archlinux_install_part4_on_my_zsh/:10:4","tags":["ArchLinux","Linux","zsh","oh-my-zsh"],"title":"Archlinux 安裝 Part 4 - 程序員終端標配 oh-my-zsh","uri":"/archlinux_install_part4_on_my_zsh/"},{"categories":["ArchLinux"],"content":"bat bat 代替 cat。 cat 某個文件，可以在終端直接輸出文件內容，bat 相比 cat 增加了行號和顏色高亮。 P.S. 我好像不怎麼用這個。所以沒裝。 2020/07/29 更新：bat 實在是太好看了，大推。 sudo pacman -S bat ","date":"2020-01-05","objectID":"/archlinux_install_part4_on_my_zsh/:10:5","tags":["ArchLinux","Linux","zsh","oh-my-zsh"],"title":"Archlinux 安裝 Part 4 - 程序員終端標配 oh-my-zsh","uri":"/archlinux_install_part4_on_my_zsh/"},{"categories":["ArchLinux"],"content":"incr 可以說 incr.zsh 這插件是最強的自動補全插件，還能幫你搜索線上的倉庫是否有你所需要的軟體包。建議搭配 zsh-autosuggestion 一起使用，我將這兩個插件都裝了。 到這個網站下載 incr.zsh 文件，將此文件放置 ~/.oh-my-zsh/custom/plugins/incr 資料夾裡，如果沒有資料夾就自己新增。 在 ~/.zshrc 文末添加一行。 source ~/.oh-my-zsh/custom/plugins/incr/incr*.zsh ","date":"2020-01-05","objectID":"/archlinux_install_part4_on_my_zsh/:10:6","tags":["ArchLinux","Linux","zsh","oh-my-zsh"],"title":"Archlinux 安裝 Part 4 - 程序員終端標配 oh-my-zsh","uri":"/archlinux_install_part4_on_my_zsh/"},{"categories":["ArchLinux"],"content":"插件配置 vim ~/.zshrc source ~/.zshrc 以下是我的 ~/.zshrc 設定。 # If you come from bash you might have to change your $PATH.# export PATH=$HOME/bin:/usr/local/bin:$PATH# Path to your oh-my-zsh installation.export ZSH=\"/home/rem/.oh-my-zsh\"# npmexport PATH=$PATH:~/.npm-global/bin# Set name of the theme to load --- if set to \"random\", it will# load a random theme each time oh-my-zsh is loaded, in which case,# to know which specific one was loaded, run: echo $RANDOM_THEME# See https://github.com/robbyrussell/oh-my-zsh/wiki/ThemesZSH_THEME=\"ys\"# Set list of themes to pick from when loading at random# Setting this variable when ZSH_THEME=random will cause zsh to load# a theme from this variable instead of looking in ~/.oh-my-zsh/themes/# If set to an empty array, this variable will have no effect.# ZSH_THEME_RANDOM_CANDIDATES=( \"robbyrussell\" \"agnoster\" )# Uncomment the following line to use case-sensitive completion.# CASE_SENSITIVE=\"true\"# Uncomment the following line to use hyphen-insensitive completion.# Case-sensitive completion must be off. _ and - will be interchangeable.# HYPHEN_INSENSITIVE=\"true\"# Uncomment the following line to disable bi-weekly auto-update checks.# DISABLE_AUTO_UPDATE=\"true\"# Uncomment the following line to automatically update without prompting. DISABLE_UPDATE_PROMPT=\"true\"# Uncomment the following line to change how often to auto-update (in days).# export UPDATE_ZSH_DAYS=13# Uncomment the following line if pasting URLs and other text is messed up.# DISABLE_MAGIC_FUNCTIONS=true# Uncomment the following line to disable colors in ls.# DISABLE_LS_COLORS=\"true\"# Uncomment the following line to disable auto-setting terminal title.# DISABLE_AUTO_TITLE=\"true\"# Uncomment the following line to enable command auto-correction.# ENABLE_CORRECTION=\"true\"# Uncomment the following line to display red dots whilst waiting for completion.# COMPLETION_WAITING_DOTS=\"true\"# Uncomment the following line if you want to disable marking untracked files# under VCS as dirty. This makes repository status check for large repositories# much, much faster.# DISABLE_UNTRACKED_FILES_DIRTY=\"true\"# Uncomment the following line if you want to change the command execution time# stamp shown in the history command output.# You can set one of the optional three formats:# \"mm/dd/yyyy\"|\"dd.mm.yyyy\"|\"yyyy-mm-dd\"# or set a custom format using the strftime function format specifications,# see 'man strftime' for details.# HIST_STAMPS=\"mm/dd/yyyy\"# Would you like to use another custom folder than $ZSH/custom?# ZSH_CUSTOM=/path/to/new-custom-folder# Which plugins would you like to load?# Standard plugins can be found in ~/.oh-my-zsh/plugins/*# Custom plugins may be added to ~/.oh-my-zsh/custom/plugins/# Example format: plugins=(rails git textmate ruby lighthouse)# Add wisely, as too many plugins slow down shell startup.plugins=( git extract archlinux vscode z colored-man-pages zsh-syntax-highlighting zsh-autosuggestions git-open)source $ZSH/oh-my-zsh.shsource /etc/profile# User configuration# export MANPATH=\"/usr/local/man:$MANPATH\"# You may need to manually set your language environment# export LANG=en_US.UTF-8# Preferred editor for local and remote sessions# if [[ -n $SSH_CONNECTION ]]; then# export EDITOR='vim'# else# export EDITOR='mvim'# fi# Compilation flags# export ARCHFLAGS=\"-arch x86_64\"# Set personal aliases, overriding those provided by oh-my-zsh libs,# plugins, and themes. Aliases can be placed here, though oh-my-zsh# users are encouraged to define aliases within the ZSH_CUSTOM folder.# For a full list of active aliases, run `alias`.## Example aliases# alias zshconfig=\"mate ~/.zshrc\"# alias ohmyzsh=\"mate ~/.oh-my-zsh\"source ~/.oh-my-zsh/plugins/incr/incr*.zsh ","date":"2020-01-05","objectID":"/archlinux_install_part4_on_my_zsh/:11:0","tags":["ArchLinux","Linux","zsh","oh-my-zsh"],"title":"Archlinux 安裝 Part 4 - 程序員終端標配 oh-my-zsh","uri":"/archlinux_install_part4_on_my_zsh/"},{"categories":["ArchLinux"],"content":"Reference oh-my-zsh,让你的终端从未这么爽过 oh-my-zsh让终端好用到飞起~ ohmyzsh - github zsh+on-my-zsh配置教程指南（程序员必备）【已备份】 git-open - Github ","date":"2020-01-05","objectID":"/archlinux_install_part4_on_my_zsh/:12:0","tags":["ArchLinux","Linux","zsh","oh-my-zsh"],"title":"Archlinux 安裝 Part 4 - 程序員終端標配 oh-my-zsh","uri":"/archlinux_install_part4_on_my_zsh/"},{"categories":["ArchLinux"],"content":"前言 我們在 Part 2 中已將基本的圖形界面以及中文字體等配置好，接下來我會在這篇中推薦一些實用的軟體與界面風格。 ","date":"2020-01-05","objectID":"/archlinux_install_part3_install_some_software_and_mac_style/:1:0","tags":["ArchLinux","Linux"],"title":"Archlinux 安裝 Part 3 - 基本軟體包安裝與 Mac 風界面設計","uri":"/archlinux_install_part3_install_some_software_and_mac_style/"},{"categories":["ArchLinux"],"content":"文本編輯器 ","date":"2020-01-05","objectID":"/archlinux_install_part3_install_some_software_and_mac_style/:2:0","tags":["ArchLinux","Linux"],"title":"Archlinux 安裝 Part 3 - 基本軟體包安裝與 Mac 風界面設計","uri":"/archlinux_install_part3_install_some_software_and_mac_style/"},{"categories":["ArchLinux"],"content":"Kate 可作為記事本使用。 sudo pacman -S kate ","date":"2020-01-05","objectID":"/archlinux_install_part3_install_some_software_and_mac_style/:2:1","tags":["ArchLinux","Linux"],"title":"Archlinux 安裝 Part 3 - 基本軟體包安裝與 Mac 風界面設計","uri":"/archlinux_install_part3_install_some_software_and_mac_style/"},{"categories":["ArchLinux"],"content":"Typora 美化你的文本，編寫 Markdowm 語言，具有跨平台優點，Linux 上的 *.docx 拿到 Windows 上的 Office 容易走版，使用 Markdown 寫的文件不會有這問題。 sudo pacman -S typora ","date":"2020-01-05","objectID":"/archlinux_install_part3_install_some_software_and_mac_style/:2:2","tags":["ArchLinux","Linux"],"title":"Archlinux 安裝 Part 3 - 基本軟體包安裝與 Mac 風界面設計","uri":"/archlinux_install_part3_install_some_software_and_mac_style/"},{"categories":["ArchLinux"],"content":"Visual Studio Code 一個輕快的編輯器，讓你的開發效率迅速提升。 在 AUR 中 VScode 軟體包稱作 code。 sudo pacman -S code ","date":"2020-01-05","objectID":"/archlinux_install_part3_install_some_software_and_mac_style/:2:3","tags":["ArchLinux","Linux"],"title":"Archlinux 安裝 Part 3 - 基本軟體包安裝與 Mac 風界面設計","uri":"/archlinux_install_part3_install_some_software_and_mac_style/"},{"categories":["ArchLinux"],"content":"辦公軟體 ","date":"2020-01-05","objectID":"/archlinux_install_part3_install_some_software_and_mac_style/:3:0","tags":["ArchLinux","Linux"],"title":"Archlinux 安裝 Part 3 - 基本軟體包安裝與 Mac 風界面設計","uri":"/archlinux_install_part3_install_some_software_and_mac_style/"},{"categories":["ArchLinux"],"content":"WPS Office 作為在 Linux 上的最佳 MS 替代品，因為 MS 的 Office 不開源，所以無法在 Linux 使用 MS Office。WPS 在 Linux 不會有廣告，所以放心。 你可以使用 pacman 安裝 WPS Office，但僅限 64-bit Arch 使用者。 yay -S wps-office ttf-wps-fonts # WPS 與 WPS 需要的符號字體 WPS 改變界面語言的方法是，隨便開啟 WPS 其中一個軟體，像是 Writer，新增一個空白文件，後在右上角的小框框選界面語言。 WPS 變更界面語言01.png \" WPS 變更界面語言 選擇簡體中文，似乎沒有正體中文的選項 :( WPS 變更界面語言選項02.png \" WPS 變更界面語言選項 接著重啟 WPS 就會出現簡體中文的界面，也能正常輸入中文，每次開機打開 WPS 都會出現個錯誤框，按關閉就好，不影響使用。 ","date":"2020-01-05","objectID":"/archlinux_install_part3_install_some_software_and_mac_style/:3:1","tags":["ArchLinux","Linux"],"title":"Archlinux 安裝 Part 3 - 基本軟體包安裝與 Mac 風界面設計","uri":"/archlinux_install_part3_install_some_software_and_mac_style/"},{"categories":["ArchLinux"],"content":"LibreOffice 同時支持 Windows、Macintosh 和 Linux 系統。 如果不在乎一定要 MS 的風格，我強烈建議使用 LibreOffice，功能齊全，軟體多，提供了六種文檔編輯與數據應用的應用。 sudo pacman -S libreoffice-fresh # 嘗新版 sudo pacman -S libreoffice-still # 穩定版 LibreOffice 中文界面的語言包 簡體中文使用者 sudo pacman -S libreoffice-fresh-zh-cn # 嘗新版 sudo pacman -S libreoffice-still-zh-cn # 穩定版 繁體中文使用者 sudo pacman -S libreoffice-fresh-zh-tw # 嘗新版 sudo pacman -S libreoffice-still-zh-tw # 穩定版 ","date":"2020-01-05","objectID":"/archlinux_install_part3_install_some_software_and_mac_style/:3:2","tags":["ArchLinux","Linux"],"title":"Archlinux 安裝 Part 3 - 基本軟體包安裝與 Mac 風界面設計","uri":"/archlinux_install_part3_install_some_software_and_mac_style/"},{"categories":["ArchLinux"],"content":"文件管理器 我這裡建議是安裝 Dolphin，重要的是好看。 sudo pacman -S dolphin 然後因為文件管理器預設是滑鼠左鍵點一下就進入資料夾或執行動作，所以需要到設定 \u003e 工作空間 \u003e 工作空間行為 \u003e 一般行為中將點擊行為改成按兩下開啟檔案或資料夾，接著應用變更。 設置滑鼠點擊事件03.png \" 設置滑鼠點擊事件 ","date":"2020-01-05","objectID":"/archlinux_install_part3_install_some_software_and_mac_style/:4:0","tags":["ArchLinux","Linux"],"title":"Archlinux 安裝 Part 3 - 基本軟體包安裝與 Mac 風界面設計","uri":"/archlinux_install_part3_install_some_software_and_mac_style/"},{"categories":["ArchLinux"],"content":"媒體播放器 ","date":"2020-01-05","objectID":"/archlinux_install_part3_install_some_software_and_mac_style/:5:0","tags":["ArchLinux","Linux"],"title":"Archlinux 安裝 Part 3 - 基本軟體包安裝與 Mac 風界面設計","uri":"/archlinux_install_part3_install_some_software_and_mac_style/"},{"categories":["ArchLinux"],"content":"MPV MPV 算是 Linux 下簡潔的音訊播放器。 sudo pacman -S mpv ","date":"2020-01-05","objectID":"/archlinux_install_part3_install_some_software_and_mac_style/:5:1","tags":["ArchLinux","Linux"],"title":"Archlinux 安裝 Part 3 - 基本軟體包安裝與 Mac 風界面設計","uri":"/archlinux_install_part3_install_some_software_and_mac_style/"},{"categories":["ArchLinux"],"content":"網易雲音樂 網易雲還是不錯的音樂播放器。 sudo pacman -S netease-cloud-music 網易雲04.png \" 網易雲 ","date":"2020-01-05","objectID":"/archlinux_install_part3_install_some_software_and_mac_style/:5:2","tags":["ArchLinux","Linux"],"title":"Archlinux 安裝 Part 3 - 基本軟體包安裝與 Mac 風界面設計","uri":"/archlinux_install_part3_install_some_software_and_mac_style/"},{"categories":["ArchLinux"],"content":"圖形 ","date":"2020-01-05","objectID":"/archlinux_install_part3_install_some_software_and_mac_style/:6:0","tags":["ArchLinux","Linux"],"title":"Archlinux 安裝 Part 3 - 基本軟體包安裝與 Mac 風界面設計","uri":"/archlinux_install_part3_install_some_software_and_mac_style/"},{"categories":["ArchLinux"],"content":"截圖工具 我使用 flameshot 習慣了，而且蠻好用。 sudo pacman -S flameshot flameshot gui # 截圖 flameshot gui -d 3000 # 延時 3 秒截圖 Spectacle 也是不錯的截圖工具，但是功能上沒 flameshot 那麼完備。 sudo pacman -S spectacle ","date":"2020-01-05","objectID":"/archlinux_install_part3_install_some_software_and_mac_style/:6:1","tags":["ArchLinux","Linux"],"title":"Archlinux 安裝 Part 3 - 基本軟體包安裝與 Mac 風界面設計","uri":"/archlinux_install_part3_install_some_software_and_mac_style/"},{"categories":["ArchLinux"],"content":"圖片檢視器 安裝 digikam 後就自動幫你安裝了 sudo pacman -S showfoto ","date":"2020-01-05","objectID":"/archlinux_install_part3_install_some_software_and_mac_style/:6:2","tags":["ArchLinux","Linux"],"title":"Archlinux 安裝 Part 3 - 基本軟體包安裝與 Mac 風界面設計","uri":"/archlinux_install_part3_install_some_software_and_mac_style/"},{"categories":["ArchLinux"],"content":"圖片編輯器 遺憾的是目前做好的圖片編輯自依然是 PhotoShop，而且 PS 不開源也不兼容 Linux，所以如果真的想要使用 PS 高級圖片處理就切到 Windows 去吧，Linux 都是開源軟體，沒有軟體能比得上 PS。 sudo pacman -S digikam ","date":"2020-01-05","objectID":"/archlinux_install_part3_install_some_software_and_mac_style/:6:3","tags":["ArchLinux","Linux"],"title":"Archlinux 安裝 Part 3 - 基本軟體包安裝與 Mac 風界面設計","uri":"/archlinux_install_part3_install_some_software_and_mac_style/"},{"categories":["ArchLinux"],"content":"Gif 圖片 註：不推薦用這個錄屏。推薦使用下面的 kazam Peek 可以錄製螢幕並轉成 Gif。 sudo pacman -S peek ","date":"2020-01-05","objectID":"/archlinux_install_part3_install_some_software_and_mac_style/:6:4","tags":["ArchLinux","Linux"],"title":"Archlinux 安裝 Part 3 - 基本軟體包安裝與 Mac 風界面設計","uri":"/archlinux_install_part3_install_some_software_and_mac_style/"},{"categories":["ArchLinux"],"content":"錄屏工具 這個工具使用很方便，推薦。 yay -S kazam ","date":"2020-01-05","objectID":"/archlinux_install_part3_install_some_software_and_mac_style/:6:5","tags":["ArchLinux","Linux"],"title":"Archlinux 安裝 Part 3 - 基本軟體包安裝與 Mac 風界面設計","uri":"/archlinux_install_part3_install_some_software_and_mac_style/"},{"categories":["ArchLinux"],"content":"繪圖 krita 堪稱 Linux 上的 PS，開源。 yay -S krita ","date":"2020-01-05","objectID":"/archlinux_install_part3_install_some_software_and_mac_style/:6:6","tags":["ArchLinux","Linux"],"title":"Archlinux 安裝 Part 3 - 基本軟體包安裝與 Mac 風界面設計","uri":"/archlinux_install_part3_install_some_software_and_mac_style/"},{"categories":["ArchLinux"],"content":"百度網盤 沒錯，你沒看錯，在 Linux 也可以使用百度雲下載東西。 sudo pacman -S baidunetdisk-bin ","date":"2020-01-05","objectID":"/archlinux_install_part3_install_some_software_and_mac_style/:7:0","tags":["ArchLinux","Linux"],"title":"Archlinux 安裝 Part 3 - 基本軟體包安裝與 Mac 風界面設計","uri":"/archlinux_install_part3_install_some_software_and_mac_style/"},{"categories":["ArchLinux"],"content":"通訊軟體 ","date":"2020-01-05","objectID":"/archlinux_install_part3_install_some_software_and_mac_style/:8:0","tags":["ArchLinux","Linux"],"title":"Archlinux 安裝 Part 3 - 基本軟體包安裝與 Mac 風界面設計","uri":"/archlinux_install_part3_install_some_software_and_mac_style/"},{"categories":["ArchLinux"],"content":"Telegram 強推 Telegram。 Telegram 需要翻牆。 sudo pacman -S telegram-desktop ","date":"2020-01-05","objectID":"/archlinux_install_part3_install_some_software_and_mac_style/:8:1","tags":["ArchLinux","Linux"],"title":"Archlinux 安裝 Part 3 - 基本軟體包安裝與 Mac 風界面設計","uri":"/archlinux_install_part3_install_some_software_and_mac_style/"},{"categories":["ArchLinux"],"content":"Discord 自從 zoom 取消免費之後，加上騰訊相關產品無法在 Linux 上運行，然而我們需要通訊會議，這個是最適合的，包括語音和屏幕分享。實在是太好用了。 Discord 網頁版也做得很好，騰訊會議就沒有網頁版。 sudo pacman -S discord # 穩定版 sudo pacman -S discord-ptb # 測試版 sudo pacman -S discord-canary # 最新版，我都直接裝最新版 ","date":"2020-01-05","objectID":"/archlinux_install_part3_install_some_software_and_mac_style/:8:2","tags":["ArchLinux","Linux"],"title":"Archlinux 安裝 Part 3 - 基本軟體包安裝與 Mac 風界面設計","uri":"/archlinux_install_part3_install_some_software_and_mac_style/"},{"categories":["ArchLinux"],"content":"TIM 你更沒聽錯，在 Linux 上真的可以使用 TIM，但是 WeChat 無法使用，只是我平常也不用 WeChat，WeChat 很垃圾。騰訊的通訊軟體都極度不安全。 sudo pacman -S deepin.com.qq.office Arch 發行版 KDE Plasma 桌面會無法打開 TIM，解決方法如下： 先下載安裝 gnome-settings-daemon 套件 sudo pacman -S gnome-settings-daemon 進入設置 \u003e 工作空間 \u003e啟動與關閉 \u003e 自動啟動中將 /usr/lib/gsd-xsettings設為自動啟動。 自動啟動05.png \" 自動啟動 ","date":"2020-01-05","objectID":"/archlinux_install_part3_install_some_software_and_mac_style/:8:3","tags":["ArchLinux","Linux"],"title":"Archlinux 安裝 Part 3 - 基本軟體包安裝與 Mac 風界面設計","uri":"/archlinux_install_part3_install_some_software_and_mac_style/"},{"categories":["ArchLinux"],"content":"IDE ","date":"2020-01-05","objectID":"/archlinux_install_part3_install_some_software_and_mac_style/:9:0","tags":["ArchLinux","Linux"],"title":"Archlinux 安裝 Part 3 - 基本軟體包安裝與 Mac 風界面設計","uri":"/archlinux_install_part3_install_some_software_and_mac_style/"},{"categories":["ArchLinux"],"content":"Intelli IDEA sudo pacman -S intellij-idea-community-edition # 社區免費版 sudo pacman -S intellij-idea-ultimate-edition # 付費專業版 安裝 Java 環境。 Arch Linux官方只支持 OpenJDK 實現。 安裝之後，Java 環境需要被 shell（$PATH 變量）識別。可以通過命令行用 source 處理 /etc/profile 或者重新登出登入桌面環境。 sudo pacman -S java-runtime-common # JRE sudo pacman -S java-environment-common # JDK 2020/07/29 更新：安裝 intellij-idea-ultimate-edition，因為一直無法啟動 IDEA，網上搜一下，發現還要裝另一個套件 原文：AUR intellij-idea-ultimate-edition 下面的討論區 sudo pacman -S intellij-idea-ultimate-edition-jre ","date":"2020-01-05","objectID":"/archlinux_install_part3_install_some_software_and_mac_style/:9:1","tags":["ArchLinux","Linux"],"title":"Archlinux 安裝 Part 3 - 基本軟體包安裝與 Mac 風界面設計","uri":"/archlinux_install_part3_install_some_software_and_mac_style/"},{"categories":["ArchLinux"],"content":"Pycharm 貌似需要使用 yay 直接從 AUR 下載安裝，pacman 庫沒有。其實我覺得 Python 直接用 VScode 寫就好了，但有些人不習慣，所以在這裡列出 Pycharm。 yay -S pycharm-community-edition # 社區版 yay -S pycharm-professional # 專業版 ","date":"2020-01-05","objectID":"/archlinux_install_part3_install_some_software_and_mac_style/:9:2","tags":["ArchLinux","Linux"],"title":"Archlinux 安裝 Part 3 - 基本軟體包安裝與 Mac 風界面設計","uri":"/archlinux_install_part3_install_some_software_and_mac_style/"},{"categories":["ArchLinux"],"content":"解壓 這裡還是要提醒，*.zip 才是壓縮檔案，不建議使用 *.rar，但是如果有人傳給你 *.rar，你也只能將他解壓縮，這裡下載 unrar。 sudo pacman -S zip unrar ","date":"2020-01-05","objectID":"/archlinux_install_part3_install_some_software_and_mac_style/:10:0","tags":["ArchLinux","Linux"],"title":"Archlinux 安裝 Part 3 - 基本軟體包安裝與 Mac 風界面設計","uri":"/archlinux_install_part3_install_some_software_and_mac_style/"},{"categories":["ArchLinux"],"content":"瀏覽器 這裡我主要推薦是使用 Firefox，在 Linux 上，Firefox 比 Chromium 更省內存，之前有段期間我一直是使用 Chromium，每次開機沒多久就整個電腦卡死，自從換成了 Firefox 就順暢很多。當然如果你有 Google 帳號的一些使用者存儲或是電腦性能夠好，裝個 Chromium 也沒問題。 重要的是 Firefox 的應用商店沒有被牆。 ","date":"2020-01-05","objectID":"/archlinux_install_part3_install_some_software_and_mac_style/:11:0","tags":["ArchLinux","Linux"],"title":"Archlinux 安裝 Part 3 - 基本軟體包安裝與 Mac 風界面設計","uri":"/archlinux_install_part3_install_some_software_and_mac_style/"},{"categories":["ArchLinux"],"content":"Chromium 就是 Chrome，然而使用上還是有很多問題。 sudo pacman -S chromium 通常翻牆需要 SwitchyOmega 這個工具，需要從 Chrome 應用商店下載，但是因為 Chrome 應用商店已經被牆了，所以必須用另一種方式開啟 Chromium。 Konsole 輸入指令，使用 Proxy 開啟 Chromium 瀏覽器，進行登入 Google 帳戶和安裝 SwitchyOmega。 先開啟 Proxy，關於 Proxy 請看下一個內容。 chromium --proxy-server=\"socks5://127.0.0.1:1080\" ","date":"2020-01-05","objectID":"/archlinux_install_part3_install_some_software_and_mac_style/:11:1","tags":["ArchLinux","Linux"],"title":"Archlinux 安裝 Part 3 - 基本軟體包安裝與 Mac 風界面設計","uri":"/archlinux_install_part3_install_some_software_and_mac_style/"},{"categories":["ArchLinux"],"content":"Firefox 強推。記得從應用商店安裝 SwitchyOmega。 sudo pacman -S firefox-nightly # 最新版 sudo pacman -S firefox # 穩定版 ","date":"2020-01-05","objectID":"/archlinux_install_part3_install_some_software_and_mac_style/:11:2","tags":["ArchLinux","Linux"],"title":"Archlinux 安裝 Part 3 - 基本軟體包安裝與 Mac 風界面設計","uri":"/archlinux_install_part3_install_some_software_and_mac_style/"},{"categories":["ArchLinux"],"content":"Proxy 在牆國，為了進行科學上網，建議各位還是租個翻牆比較好。這裡我就不貼出使用細節，畢竟涉及個人隱私。當然如果你喜歡 Baidu 也不是不行，但你要知道你使用 Baidu 是做不出任何科研成果的，Github 的訪問如果不開 Proxy 就是限速卡死。 ","date":"2020-01-05","objectID":"/archlinux_install_part3_install_some_software_and_mac_style/:12:0","tags":["ArchLinux","Linux"],"title":"Archlinux 安裝 Part 3 - 基本軟體包安裝與 Mac 風界面設計","uri":"/archlinux_install_part3_install_some_software_and_mac_style/"},{"categories":["ArchLinux"],"content":"Shadowsocks 以下是 GUI 版的客戶端。缺點是無法使用訂閱。 sudo pacman -S shadowsocks-qt5 Shadowsocks06.png \" Shadowsocks ","date":"2020-01-05","objectID":"/archlinux_install_part3_install_some_software_and_mac_style/:12:1","tags":["ArchLinux","Linux"],"title":"Archlinux 安裝 Part 3 - 基本軟體包安裝與 Mac 風界面設計","uri":"/archlinux_install_part3_install_some_software_and_mac_style/"},{"categories":["ArchLinux"],"content":"ShadowsocksR 簡稱 SSR，由於很久沒更新了，容易被牆識別，雖然使用方便，但不建議使用。以下是 GUI 版的客戶端。 sudo pacman -S electron-ssr ShadowsocksR07.png \" ShadowsocksR ","date":"2020-01-05","objectID":"/archlinux_install_part3_install_some_software_and_mac_style/:12:2","tags":["ArchLinux","Linux"],"title":"Archlinux 安裝 Part 3 - 基本軟體包安裝與 Mac 風界面設計","uri":"/archlinux_install_part3_install_some_software_and_mac_style/"},{"categories":["ArchLinux"],"content":"V2ray 算是蠻新的代理器，速度穩定快速，但是很燒流量，你翻牆的流量會被乘 2.5 倍。 sudo pacman -S v2ray # 下載安裝 v2ray v2ray -version # 查看版本 v2ray --config=config.json # 啟動 v2ray # 如果想開機自啟可以這樣做 systemctl enable v2ray # 開機自啟 systemctl start v2ray ","date":"2020-01-05","objectID":"/archlinux_install_part3_install_some_software_and_mac_style/:12:3","tags":["ArchLinux","Linux"],"title":"Archlinux 安裝 Part 3 - 基本軟體包安裝與 Mac 風界面設計","uri":"/archlinux_install_part3_install_some_software_and_mac_style/"},{"categories":["ArchLinux"],"content":"Clash 強推，可以自動偵測是否為大陸網域進行是否使用代理，但貌似只能使用訂閱。沒有 GUI。 下載 clash。 2020 / 10 / 20 更新：舊版 clash AUR 上的包出現了使用上的問題，改用 clash-premium-bin。使用指令也做了變更，需要指定訂閱文件。 sudo pacman -S clash-premium-bin 進入 ~/.config/clash 下載自己的 config.yml。如果 ./config 裡面 clash 沒有就自己新增。 這裡需要注意的是如果你的 Konsole 是 ZSH，你使用 Wget 需要將 URL 用雙引號包住。Bash 的話應該是沒關係。 cd ~/.config/clash sudo pacman -S wget wget -O config.yml \"xxxxxxxxxxxxxxx\" 接著修改 config.yml 的 socks-port 代理端口為 1080，用預設端口也可以。 接下來需要新的的文件是 Country.mmdb，這份文件已經被牆國牆了，所以需要手動到網上下載。我姑且將該份文件上傳到百度網盤，密碼是 vsor，希望別被砍掉。如果被砍掉了，我又在 Github 上傳該份文件。 將 Country.mmdb 放入 ~/.config/clash。如果需要看到隱藏的資料夾可以在檔案管理器檢視的地方選擇顯示隱藏檔案或資料夾。。 再來就是執行 clash 了。 clash -f .config/clash/config.yaml # konsole 執行 clash 可以進入 Clash Dashboard 進行切換節點與測延遲等操作。 ","date":"2020-01-05","objectID":"/archlinux_install_part3_install_some_software_and_mac_style/:12:4","tags":["ArchLinux","Linux"],"title":"Archlinux 安裝 Part 3 - 基本軟體包安裝與 Mac 風界面設計","uri":"/archlinux_install_part3_install_some_software_and_mac_style/"},{"categories":["ArchLinux"],"content":"neofetch 可以快速察看電腦狀況。好看。 sudo pacman -S neofetch neofetch # 執行 neofetch neofetch13.png \" neofetch ","date":"2020-01-05","objectID":"/archlinux_install_part3_install_some_software_and_mac_style/:13:0","tags":["ArchLinux","Linux"],"title":"Archlinux 安裝 Part 3 - 基本軟體包安裝與 Mac 風界面設計","uri":"/archlinux_install_part3_install_some_software_and_mac_style/"},{"categories":["ArchLinux"],"content":"界面美化 關於這部份我就寫自己推薦的部份，畢竟每個人的審美不同，沒必要照我的來。也可以自行探索，細節也不詳細講。可以在設置中玩玩。KDE Plasma 的使用者可以到線上的 KDE 商店看看，Gnome 則可到 Gnome 商店。 ","date":"2020-01-05","objectID":"/archlinux_install_part3_install_some_software_and_mac_style/:14:0","tags":["ArchLinux","Linux"],"title":"Archlinux 安裝 Part 3 - 基本軟體包安裝與 Mac 風界面設計","uri":"/archlinux_install_part3_install_some_software_and_mac_style/"},{"categories":["ArchLinux"],"content":"Latte Dock 像 Mac 風的任務管理器。強推，很好看。 sudo pacman -S latte-dock 下載完在應用管理器開啟就能跑出來了。 ","date":"2020-01-05","objectID":"/archlinux_install_part3_install_some_software_and_mac_style/:14:1","tags":["ArchLinux","Linux"],"title":"Archlinux 安裝 Part 3 - 基本軟體包安裝與 Mac 風界面設計","uri":"/archlinux_install_part3_install_some_software_and_mac_style/"},{"categories":["ArchLinux"],"content":"Theme 我偏向 Mac 風，Mac 風真的好看。 將 McMojave KDE Theme 從 Github 下載下來，解壓壓縮包後進入資料夾，執行以下指令： ./install.sh preview McMojave Dark ThemeMcMojave_dark.png \" McMojave Dark Theme ","date":"2020-01-05","objectID":"/archlinux_install_part3_install_some_software_and_mac_style/:14:2","tags":["ArchLinux","Linux"],"title":"Archlinux 安裝 Part 3 - 基本軟體包安裝與 Mac 風界面設計","uri":"/archlinux_install_part3_install_some_software_and_mac_style/"},{"categories":["ArchLinux"],"content":"Icon 下面是我比較喜歡的 Icon 風格，你都可以裝來玩玩看。 yay -S numix-circle-icon-theme-git yay -S papirus-icon-theme-git # 推薦，太好看了 ","date":"2020-01-05","objectID":"/archlinux_install_part3_install_some_software_and_mac_style/:14:3","tags":["ArchLinux","Linux"],"title":"Archlinux 安裝 Part 3 - 基本軟體包安裝與 Mac 風界面設計","uri":"/archlinux_install_part3_install_some_software_and_mac_style/"},{"categories":["ArchLinux"],"content":"SDDM 2020 / 01 / 02 補充 我在這裡推薦使用 Suger Candy for SDDM，幸好也有人放上了 AUR。 官方文檔也在設置檔案的參數說明得很清楚，我就不再這多贅述了。在 /usr/share/sddm/themes/Sugar-Candy/ 的 theme.conf 進行修改。 sudo pacman -S sddm-theme-sugar-candy-git Sugar Candy SDDMPartialBlur.png \" Sugar Candy SDDM ","date":"2020-01-05","objectID":"/archlinux_install_part3_install_some_software_and_mac_style/:14:4","tags":["ArchLinux","Linux"],"title":"Archlinux 安裝 Part 3 - 基本軟體包安裝與 Mac 風界面設計","uri":"/archlinux_install_part3_install_some_software_and_mac_style/"},{"categories":["ArchLinux"],"content":"GRUB THEME 沒錯！GRUB 也可以改成自己想要的，將 Flat Design themes for Grub2 zip 包從 Github 下載下來，解壓後進入資料夾輸入官網說的安裝教學。細節修改可以進入 /usr/share/grub/themes/ 裡面自行修改。 我裝的主題是 Tela grub theme，有修改字體大小和字型，編輯 /usr/share/grub/themes/Tela/theme.txt： item_font = \"Noto Sans Regular 24\" Tela Grub Themegrub-theme-tela.jpg \" Tela Grub Theme ","date":"2020-01-05","objectID":"/archlinux_install_part3_install_some_software_and_mac_style/:14:5","tags":["ArchLinux","Linux"],"title":"Archlinux 安裝 Part 3 - 基本軟體包安裝與 Mac 風界面設計","uri":"/archlinux_install_part3_install_some_software_and_mac_style/"},{"categories":["ArchLinux"],"content":"窗口特效 在設置 \u003e 工作空間 \u003e 工作空間行為 \u003e 桌面效果中可以選擇特效。 我建議將以下選項勾起來，蠻好玩的。 桌面特效09.png \" 桌面特效 桌面特效 - 最小化視窗10.png \" 桌面特效 - 最小化視窗 ","date":"2020-01-05","objectID":"/archlinux_install_part3_install_some_software_and_mac_style/:14:6","tags":["ArchLinux","Linux"],"title":"Archlinux 安裝 Part 3 - 基本軟體包安裝與 Mac 風界面設計","uri":"/archlinux_install_part3_install_some_software_and_mac_style/"},{"categories":["ArchLinux"],"content":"窗口的 MAC 按鈕 將視窗搞的像 MAC 按鈕位置。 先隨意在一個視窗標題欄點擊滑鼠右鍵，更多工作 \u003e 設定視窗管理員。 視窗管理員11.png \" 視窗管理員 調整窗口的標題列按鈕。 設定視窗12.png \" 設定視窗 ","date":"2020-01-05","objectID":"/archlinux_install_part3_install_some_software_and_mac_style/:14:7","tags":["ArchLinux","Linux"],"title":"Archlinux 安裝 Part 3 - 基本軟體包安裝與 Mac 風界面設計","uri":"/archlinux_install_part3_install_some_software_and_mac_style/"},{"categories":["ArchLinux"],"content":"Reference WPS Office (简体中文) - ArchWiki LibreOffice (简体中文) - ArchWiki Localization/Simplified Chinese (简体中文) - ArchWiki netease-cloud-music - AUR 2019年wine QQ最完美解决方案（多Linux发行版通过测试并稳定运行） Java (简体中文) - ArchWiki Linux 下好用的四款 ss/ssr 客戶端 AUR intellij-idea-ultimate-edition 下面的討論區 ","date":"2020-01-05","objectID":"/archlinux_install_part3_install_some_software_and_mac_style/:15:0","tags":["ArchLinux","Linux"],"title":"Archlinux 安裝 Part 3 - 基本軟體包安裝與 Mac 風界面設計","uri":"/archlinux_install_part3_install_some_software_and_mac_style/"},{"categories":["ArchLinux"],"content":"前言 我們已經在 Part 1 將基本的系統裝好了，接下來是安裝完的後續步驟。 ","date":"2020-01-04","objectID":"/archlinux_install_part2_general_recommendations/:1:0","tags":["ArchLinux","Linux"],"title":"Archlinux 安裝 Part 2 - 安裝後工作","uri":"/archlinux_install_part2_general_recommendations/"},{"categories":["ArchLinux"],"content":"確認連網 我們在上次的安裝教學 Part 1 已經在尾部補充將 networkmanager 裝上了，所以你不需要像上次教學那麼繁瑣，基本插網線就能連到。 註：注意使用 systemctl 啟用 networkmanager 服務時要注意大小寫，開頭要大寫。 systemctl enable NetworkManager # 設定開機自啟 systemctl start NetworkManager # 啟用 Netmanager ping baidu.com # 確認連網 ","date":"2020-01-04","objectID":"/archlinux_install_part2_general_recommendations/:2:0","tags":["ArchLinux","Linux"],"title":"Archlinux 安裝 Part 2 - 安裝後工作","uri":"/archlinux_install_part2_general_recommendations/"},{"categories":["ArchLinux"],"content":"添加使用者 在上一期教學我們已經設定了超級使用者，即 Root，但是使用 Root 進行日常操作是不安全的，應創建用戶組進行日常操作，僅在系統管理時使用 Root。 另一方面，我們無法使用超級使用者進入圖形界面。 註：將以下的所有 user 改成自己的使用者名稱。 useradd -G wheel user # 新增使用者 passwd user # 設定使用者密碼 chfn user # 添加使用者信息，可暫時不填 mkdir -m 700 /home/user # 創建主目錄 chown user:user /home/user # 修改使用者與使用者群組 ","date":"2020-01-04","objectID":"/archlinux_install_part2_general_recommendations/:3:0","tags":["ArchLinux","Linux"],"title":"Archlinux 安裝 Part 2 - 安裝後工作","uri":"/archlinux_install_part2_general_recommendations/"},{"categories":["ArchLinux"],"content":"sudo 安裝 為了安全，我們可以使用 sudo 進行 root 權限操作，編輯 /etc/sudoers。 註：這裡不能使用 vim 編輯，會顯示權限不足，是只讀狀態，所以要改用 nano。 pacman -S sudo # 安裝 sudo nano /etc/sudoers # 編輯 /etc/sudoers 接著將上一步驟的使用者添加到 sudo。添加 user ALL = (ALL) ALL 在 root 下面。 註：將 user 改成上一步驟你新增的使用者名稱。 root ALL = (ALL) ALLuser ALL = (ALL) ALL # 新增使用者 ","date":"2020-01-04","objectID":"/archlinux_install_part2_general_recommendations/:4:0","tags":["ArchLinux","Linux"],"title":"Archlinux 安裝 Part 2 - 安裝後工作","uri":"/archlinux_install_part2_general_recommendations/"},{"categories":["ArchLinux"],"content":"添加 ArchLinuxcn 源 註：2020/07/29 關於 GPG 金鑰遇到的問題解決方法，我已經補充到此文末的重要補充 Archlinuxcn 庫有很多平常實用的工具，但是官方倉庫沒有的東西。 編輯 /etc/pacman.conf nano /etc/pacman.conf 在文件末添加清華大學 CN 源，並順便將 multilib 註解去除，因為後續裝一些軟體需要到這個庫。 # 去掉 multilib 註解[multilib]Include = /etc/pacman.d/mirrorlist# 添加 CN 源[archlinuxcn]Server = https://mirrors.ustc.edu.cn/archlinuxcn/$arch archlinuxcn-keyring 套件導入 GPG 金鑰。 pacman -Sy archlinuxcn-keyring ","date":"2020-01-04","objectID":"/archlinux_install_part2_general_recommendations/:5:0","tags":["ArchLinux","Linux"],"title":"Archlinux 安裝 Part 2 - 安裝後工作","uri":"/archlinux_install_part2_general_recommendations/"},{"categories":["ArchLinux"],"content":"安裝圖形界面 ","date":"2020-01-04","objectID":"/archlinux_install_part2_general_recommendations/:6:0","tags":["ArchLinux","Linux"],"title":"Archlinux 安裝 Part 2 - 安裝後工作","uri":"/archlinux_install_part2_general_recommendations/"},{"categories":["ArchLinux"],"content":"Xorg 使用 xorg 啟動桌面環境。 pacman -S xorg ","date":"2020-01-04","objectID":"/archlinux_install_part2_general_recommendations/:6:1","tags":["ArchLinux","Linux"],"title":"Archlinux 安裝 Part 2 - 安裝後工作","uri":"/archlinux_install_part2_general_recommendations/"},{"categories":["ArchLinux"],"content":"圖形界面選擇 我比較推薦 KDE Plasma 或是 Gnome，兩者是最大主流，但因為 KDE 比 Gnome 乾淨，所以我選擇了 KDE Plasma。 KDE Plasma KDE Plasma01.png \" KDE Plasma 有三種選擇的安裝包，我建議是 安裝第二種完整版，因為完整版就像 Google 一整套全家統，一個套件更新，其他依賴套件一起更新。 基本包 pacman -S plasma 完整包 pacman -S plasma-meta # 推薦 最簡安裝包（僅有桌面軟體） pacman -S plasma-desktop Gnome Gnome02.png \" Gnome Gnome 桌面只要安裝 gnome 包即可，還有一個 gnome-extra 包可以提供額外的常用軟體和幾個遊戲，你可以安裝時選擇你要的軟體，沒必要全選，當然也可以不装這个包。 私人強烈建議不安裝 gnome-extra 這個包，太多垃圾了，我後面刪得很累 註：在輸入 pacman 下載安裝指令時套件之間的空格不影響其指令執行。 pacman -S gnome # 推薦 pacman -S gnome gnome-extra # 不推薦 ","date":"2020-01-04","objectID":"/archlinux_install_part2_general_recommendations/:6:2","tags":["ArchLinux","Linux"],"title":"Archlinux 安裝 Part 2 - 安裝後工作","uri":"/archlinux_install_part2_general_recommendations/"},{"categories":["ArchLinux"],"content":"啟動器 安裝啟動器後先別急進入圖形界面，如果你是雙顯卡會有顯卡衝突。 KDE Plasma 使用 SDDM 登入啟動器 pacman -S sddm Gnome 使用 GDM 登入啟動器 pacman -S gdm ","date":"2020-01-04","objectID":"/archlinux_install_part2_general_recommendations/:6:3","tags":["ArchLinux","Linux"],"title":"Archlinux 安裝 Part 2 - 安裝後工作","uri":"/archlinux_install_part2_general_recommendations/"},{"categories":["ArchLinux"],"content":"顯卡衝突 相信如果你的筆電是雙顯卡，那很有可能遇到雙顯卡衝突，像我的是 Intel 和 nvidia 衝突，一般我會建議使用 Intel 內顯去驅動圖形界面。當然因為我的筆記型電腦是聯想 Y7000，所以對於顯卡的處理很麻煩。 一般處理方法 安裝 optimus-manager，幫你自動產生 xorg.conf。 pacman -S optimus-manager # 安裝 optimus-manager systemctl enable --now optimus-manager # 二選一 optimus-manager --switch intel # 切換到內顯 optimus-manager --switch nvidia # 切 N 卡 如果你需要重新選擇圖形界面的驅動方式，也就是選擇以哪個顯卡驅動，要刪除 /etc/X11/xorg.conf，再重新設定。 rm /etc/X11/xorg.conf # 刪除 /etc/X11/xorg.conf systemctl enable --now optimus-manager # 二選一 optimus-manager --switch intel # 切換到內顯 optimus-manager --switch nvidia # 切 N 卡 重啟電腦後使用啟動器進入圖形界面如果沒有問題就可以啟用自動啟動圖形界面。 KDE Plasma systemctl start sddm # 啟用圖形界面 systemctl enable sddm # 開機自啟 Gnome systemctl start gdm # 啟用圖形界面 systemctl enable gdm # 開機自啟 聯想 Y7000 的方法 因為 optimus-manager 無法解決聯想 Y7000 的顯卡衝突，關於這裡的解決方法我是詢問 Telegram #archlinux-cn 群中的 @HiyoriCao 大佬才得以解決。我因為不能使用獨顯進入圖形界面，所以就一直是用一個模式（核顯）。 首先 yay 大佬的包 – arch-prime-git 註：yay 可以直接從 AUR 倉庫上下載用戶上傳的最新軟件包。 註：Arch 使用者軟體倉庫 (AUR) 是由社群推動的使用者軟體庫。它包含了軟體包描述單 (PKGBUILD)，可以用 makepkg 從原始碼編譯軟體包，並透過 Pacman 安裝。 透過 AUR 可以在社群間分享、組織新進軟體包，熱門的軟體包有機會被收錄進 community[broken link: invalid section] 軟體庫。這份文件將解釋如何存取、使用 AUR。 pacman -S yay # 下載安裝 yay pacman -S base-devel # 下載安裝 base-devel 編譯工具包 yay -S arch-prime-git # 下載 arch-prime-git 如果有 Nvidia 卡，要先安裝 nvidia 套件，然後重起電腦，讓 arch-prime-git 能偵測到顯卡（Nvidia）。 pacman -S nvidia # 安裝 N 卡套件 先初始化 arch-prime-git。 註：這個指令貌似要在一般使用者中執行，不能是 Root 使用者（超級使用者），如果在 Root 使用者下無法執行 init，就輸入 exit 指令登出，重新以一般使用者登入。 prime-select init 這軟件包提供三種模式： 只用核顯 prime-select set intel 只用獨顯 prime-select set nvidia 動態切換 註：在設置環境變量的時候不能添加到 ./profile，因為這樣會設成全局變量，失去了動態切換的意義，在 Linux 上很少程序需要用到獨顯，除非是遊戲或是 Tenserflow 使用獨顯訓練。 prime-select set prime # 跑在核顯上 glxinfo | grep vendor # 跑在獨顯上 export NV_PRIME_RENDER_OFFLOAD=1 # 設置環境變量 GLX_VENDOR_LIBRARY_NAME=nvidia glxinfo | grep vendor 接著試著重啟電腦進入圖形界面，如果沒問題就啟用自啟圖形界面。 ","date":"2020-01-04","objectID":"/archlinux_install_part2_general_recommendations/:6:4","tags":["ArchLinux","Linux"],"title":"Archlinux 安裝 Part 2 - 安裝後工作","uri":"/archlinux_install_part2_general_recommendations/"},{"categories":["ArchLinux"],"content":"中文字體 進入 Plasma，預設會是英文，我推薦使用 Google 的開源字體 Noto Sans CJK，渲染出來的字體很好看。 pacman -S noto-fonts-cjk 進入 Plasma 後可以在設置中調整字體了，登出再登入就可以看到中文字體。 ","date":"2020-01-04","objectID":"/archlinux_install_part2_general_recommendations/:7:0","tags":["ArchLinux","Linux"],"title":"Archlinux 安裝 Part 2 - 安裝後工作","uri":"/archlinux_install_part2_general_recommendations/"},{"categories":["ArchLinux"],"content":"中文輸入法 我這裡選擇 Fcitx。這裡我參考了 @cheergo （Chun Yu）寫的文章內容。 註：Fcitx (Flexible Input Method Framework) ── 即小企鵝輸入法，它是一個以 GPL 方式發布的輸入法平台，可以通過安裝引擎支持多種輸入法，支持簡入繁出，是在 Linux 操作系統中常用的中文輸入法。它的優點是，短小精悍、跟程序的兼容性比較好。 註：Linux KDE 上切換輸入法的快捷建是 Ctrl + Space。 pacman -S fcitx fcitx-im 安裝新酷音輸入法。 pacman -S fcitx-chewing 輸入法設定介面。 pacman -S kcm-fcitx # KDE pacman -S fcitx-configtool # GNOME 編輯 /etc/profile，開頭加入三行。 vim /etc/profile export XMODIFIERS=\"@im=fcitx\"export GTK_IM_MODULE=\"fcitx\"export QT_IM_MODULE=\"fcitx\" ","date":"2020-01-04","objectID":"/archlinux_install_part2_general_recommendations/:8:0","tags":["ArchLinux","Linux"],"title":"Archlinux 安裝 Part 2 - 安裝後工作","uri":"/archlinux_install_part2_general_recommendations/"},{"categories":["ArchLinux"],"content":"NTFS-3G 為了能掛載病讀取外部磁碟（e.g. HDD、SSD），需要安裝 ntfs-3g。 如果你使用的文件系統是 Btrfs 或是 XFS 就不需要下載這東西。 pacman -S ntfs-3g ","date":"2020-01-04","objectID":"/archlinux_install_part2_general_recommendations/:9:0","tags":["ArchLinux","Linux"],"title":"Archlinux 安裝 Part 2 - 安裝後工作","uri":"/archlinux_install_part2_general_recommendations/"},{"categories":["ArchLinux"],"content":"Konsole 進入圖形界面後需要安裝 Konsole 以便輸入指令。 pacman -S konsole ","date":"2020-01-04","objectID":"/archlinux_install_part2_general_recommendations/:10:0","tags":["ArchLinux","Linux"],"title":"Archlinux 安裝 Part 2 - 安裝後工作","uri":"/archlinux_install_part2_general_recommendations/"},{"categories":["ArchLinux"],"content":"重要補充 ","date":"2020-01-04","objectID":"/archlinux_install_part2_general_recommendations/:11:0","tags":["ArchLinux","Linux"],"title":"Archlinux 安裝 Part 2 - 安裝後工作","uri":"/archlinux_install_part2_general_recommendations/"},{"categories":["ArchLinux"],"content":"聯想 Y7000 的連網問題 聯想筆電通常在連無線網路上有一個坑 - Networkmanager 無法啟用無線網卡，算是…聯想筆電的特色，這裡我感謝 Telegram #archlinux-cn 群中的 @Asterism 大佬幫助我解決問題。 許多筆記本電腦都有一個硬體按鈕（或開關）來關閉無線網卡，但是，網卡也可能被內核阻止。 可以由 Rfkill 處理。通常來說你需要禁用 ideapod_laptop。 先輸入 rfkill list 查看關於筆電的硬件開關。 關於 Rfkill 硬件狀態03.png \" 硬件狀態 這張圖片是我已經處理過的狀態，關於 Wireless LAN 的軟體與硬體禁止皆為 NO，但如果是還沒處理之前我的 Soft blocked（軟卡禁止）為 no、Hard blocked（硬卡禁止）為 yes。 註：modprobe 是內核模塊，想了解更多可以參考 Kernel module (简体中文) - ArchWiki sudo modprobe -r ideapad_laptop # 禁用 ideapod_laptop sudo tee /etc/modprobe.d/ideapad.conf \u003c\u003c\u003c \"blacklist ideapad_laptop\" # 永久生效 接著再次輸入 rfkill list 查看狀態，如果發現 Wireless LAN 的 Soft blocked 和 Hard blocked 都是 no就行了，無線網路也能連結了。 ","date":"2020-01-04","objectID":"/archlinux_install_part2_general_recommendations/:11:1","tags":["ArchLinux","Linux"],"title":"Archlinux 安裝 Part 2 - 安裝後工作","uri":"/archlinux_install_part2_general_recommendations/"},{"categories":["ArchLinux"],"content":"pacman 中 archlinux-cn 無法更新下載 如果你有在更新或下載時，顯示 GPG 失效或錯誤等訊息，可以嘗試用以下方法解決。我也都是靠這方法解決大部份問題。做完以下步驟後用 pacman 同步一下資料庫，然後再試著下載看看。 rm -rf /etc/pacman.d/gnupg pacman-key --init pacman-key --populate archlinux pacman-key --populate archlinuxcn ","date":"2020-01-04","objectID":"/archlinux_install_part2_general_recommendations/:11:2","tags":["ArchLinux","Linux"],"title":"Archlinux 安裝 Part 2 - 安裝後工作","uri":"/archlinux_install_part2_general_recommendations/"},{"categories":["ArchLinux"],"content":"Reference General recommendations (简体中文) - ArchWiki Users and groups (简体中文) - ArchWiki Arch Linux下载与安装配置 - 天祺圍棋 NVIDIA Optimus (简体中文) - ArchWiki 在Arch Linux上使用aurman、yay、pakku、aurutils来替代Yaourt - ywnz Arch User Repository (正體中文) - ArchWiki Archlinux nvidia-prime like package arch-prime-git - AUR Fcitx (简体中文) - ArchWiki NTFS-3G (简体中文) - ArchWiki gnome_vs_kde Redirect to:Network configuration/Wireless#Rfkill caveat - ArchWiki Kernel module (简体中文) - ArchWiki ","date":"2020-01-04","objectID":"/archlinux_install_part2_general_recommendations/:12:0","tags":["ArchLinux","Linux"],"title":"Archlinux 安裝 Part 2 - 安裝後工作","uri":"/archlinux_install_part2_general_recommendations/"},{"categories":["Moment"],"content":"前言 近期，全球上映了一部電影 – 《小丑》（英語：Joker，香港譯《JOKER小丑》，中國大陸譯《小丑》）是一部於 2019 年上映的美國心理驚悚片，改編自DC漫畫旗下的同名角色，這部電影的預告片極為令人驚嘆，深層的黑暗、社會的底層、現實的矛盾……等都驅使著我期待著這部電影上映，可惜的是我現在於大陸唸書，這部電影大陸不會上映，畢竟這是部充滿反社會負面情緒的電影 (◞‸◟)，超想回台灣看小丑。 這部電影也因為作品的人物描繪、情感細緻等因素，獲得了金預告獎 - 最佳前導預告提名、多倫多國際電影節 - 演員成就獎、威尼斯電影節 - 金獅獎、金紙夾獎與原聲音樂星獎。 ","date":"2019-10-13","objectID":"/joker_movie_moment/:1:0","tags":["小丑","Joker","影片賞析"],"title":"影片賞析 -- 小丑（Joker）","uri":"/joker_movie_moment/"},{"categories":["Moment"],"content":"心靈感觸 首先我就先說一下開場給我的感覺就是一種懸疑的電影，讓我看不透也摸不清，男主角換上小丑裝時就像帶上了神秘的面具，好比每個人出面對不同的人時會有不同的態度與舉止看不透真正的他，在電影起頭，男主角在街頭身著小丑服手拿廣告牌，中途被街頭的混混狠狠捉弄後畫面切到了精神病院，男主角在心理醫師面前談論他的幻想，這裡就引起了我的注意，女醫師問男主角亞瑟：「你知道你為什麼你會被關在這裡嗎？」接著亞瑟出了醫院坐公車去領藥，(ﾟдﾟ≡ﾟдﾟ) 你不是被關在精神病院嗎？但我沒有在意地繼續看下去，這裡是電影裡的第一個玄疑點，這時我對亞瑟的印象還是個心理跟正常人差不多，但很不幸遇到了一些倒霉事。 實際上，在電影的前幾十分鐘，我都認為亞瑟是個老實人，心理上稍微不正常而已，遇到了老闆不講理的指責、槍枝曝光後同事的背叛、被老闆開除而失去最愛的工作、地鐵上的三個精英青年殺人事件，這些人生失意都刻印在觀眾眼中，亞瑟被社會無情地拋棄，這時我又想起亞瑟開頭日記上寫的一句話：「我希望我的死比我的生命有價值。」這確實是個充滿抑鬱壓抑的文章。 這整部電影都讓我感到驚悚，尤其是最後亞瑟拿出手槍殺了節目主持人，亞瑟也給我看到了現實世界中真實的一面，或許有被誇大的成份，但毫無疑問地，這部電影體現了亞瑟可悲的人生。 ","date":"2019-10-13","objectID":"/joker_movie_moment/:2:0","tags":["小丑","Joker","影片賞析"],"title":"影片賞析 -- 小丑（Joker）","uri":"/joker_movie_moment/"},{"categories":["Moment"],"content":"Reference 【小丑】首支官方預告，10月3日(週四) 上映 - Youtube 小丑 (電影) - 維基百科 DC《小丑》万字终极解析，一个精神病患从受害者到恶魔的自白 - Youtube 《小丑》影评：DC极度现实之作 - BiliBili ","date":"2019-10-13","objectID":"/joker_movie_moment/:3:0","tags":["小丑","Joker","影片賞析"],"title":"影片賞析 -- 小丑（Joker）","uri":"/joker_movie_moment/"},{"categories":["C/C++"],"content":"前言 最近我朋友問了我一個關於一個小數轉進制的題目，雖然我當時很忙，但最後我還是抽出了時間幫忙解決，解題的一開始我以為題目挺簡單的，但在解題過程發現還蠻多小技巧要使用，我會在這篇文章分享我的解題過程。 ","date":"2019-10-11","objectID":"/cpp_solving_decimal_programming/:1:0","tags":["C++","小數","進制","演算法"],"title":"C++ 關於某小數轉進制的題目-解題經驗","uri":"/cpp_solving_decimal_programming/"},{"categories":["C/C++"],"content":"題目 我先給各位看一下題目。 Objective Programming using basic data types and control structures. Specification Write a program which converts a base-S floating point number with value in the range [0,1) to its equivalent base-D representation, where S, D =2, … , 10. You program should be able to convert an input number with at least 8 significant digits而且. Hint: Use input/output manipulators std::setw, std::setfill, and std::setprecision to format the output. Sample run Base conversion for numbers [0,1) with at least 8 significant digits. Convert a number from base-S to base-D (2\u003c=S\u003c=10, 2\u003c=D\u003c=10): Input S: 4 Input D: 9 Input a number [0,1)in base-4: 0.12341234 Error: 0.12341234 is an invalid base-4 number Input a valid base-4 number: 0.12301230 0.12301230(4) is equivalent to 0.42352295(10) \u0026 0.37266541(9) Process another Conversion or Quit? (C/Q) C Convert a number from base-S to base-D (2\u003c=S\u003c=10, 2\u003c=D\u003c=10): Input S: 8 Input D: 5 Input a number in base-8: 0.66666666 0.66666666(8) is equivalent to 0.85714281(10) \u0026 0.41203241(5) Process another Conversion or Quit? (C/Q) Q Note: Ÿ Download the grade sheet as the cover page of your homework report. Ÿ You may check the base converter for the assessment of your results. ","date":"2019-10-11","objectID":"/cpp_solving_decimal_programming/:2:0","tags":["C++","小數","進制","演算法"],"title":"C++ 關於某小數轉進制的題目-解題經驗","uri":"/cpp_solving_decimal_programming/"},{"categories":["C/C++"],"content":"題目理解 這題目要我們先輸入我們想要轉換的進制，從 base-S 進制轉成 base-D 進制，接著要輸入一個至少小數點後有 8 位的小數，首先判斷該小數是否是否符合 base-S 的進制，如果不符合就重輸入，符合就轉進制，最後格式化分別輸出 10 進制與 base-D 進制的小數。 ","date":"2019-10-11","objectID":"/cpp_solving_decimal_programming/:3:0","tags":["C++","小數","進制","演算法"],"title":"C++ 關於某小數轉進制的題目-解題經驗","uri":"/cpp_solving_decimal_programming/"},{"categories":["C/C++"],"content":"程序設計思路 在決定小數的類型時，我們需要知道： float 類型的有效數字為 6 ~ 7 位 double 有效數字 15 ~ 16 位 long double 有效數字 18 ~ 19 位 根據題目要求至少輸入小數點後有 8 位有效數字，我們應該選擇 double 類型為我們的小數類型。 在全程使用 double 類型的變數存取小數時，會遇到數字精確度的問題，也就是在取小數位數時或是在轉換時數字的累加上，極有可能碰到數字尾部（有效數字外）出現了不知所然的位數，導致精確度不準確，也順帶影響運算結果。 為了避免這種情況，我們需要使用 String 類型來存取我們輸入的小數，以獲取我們輸入時的小數位數有多少，再利用位數使用循環將字符串轉成 double 類型，這一步我們主要就是小數位數，後面關於進制檢查與轉換都要用到小數位數。 在依序獲取小數每位數字時，可以先乘 10，再使用 (int) 強制轉換類型取得整數部份，將乘 10 的小數減去整數部份，持續循環。 題意不會要我們轉換 10 進制以上的小數（2 \u003c= S \u003c= 10, 2 \u003c= D \u003c= 10），這代表我們不需要擔心遇到英文字母，但遇到了其實也不麻煩，只要在轉換的地方添加字母條件去- 判斷是否為字母。 我們需要優先將小數轉成 10 進制，再轉成其他進制，這樣會有效讓我們去設計算法，如果是設計一個函式通用所有的轉制會很吃力。 從非 10 進制轉換到 10 進制的演算法，我們使用指數加權法： 註：來源參考 - 進制轉換 (二進制、八進制、十進制、十六進制) - NotFalse 技術客 指數加權法2.png \" 指數加權法 e.g. 指數加權法範例3.png \" 指數加權法範例 代碼實現 int n = -1; // the power of n double base10 = 0; // copy convert1 // Continuously taking decimal places // convert to base-10 for(int i = 0; i \u003c significant; i++) { number *= 10; *convert1 += (int)number * pow(S, n); // e.g. 1.1 (base-2) -\u003e 1*2^0 + 1*2^(-1) = 1.5 (base-10) number -= (int)number; n -= 1; } 從 10 進制轉成非 10 進制的演算法，我們使用餘數乘積法： 註：來源參考 - 十进制小数转二进制小数方法 餘數乘積法4.png \" 餘數乘積法 e.g. 餘數乘積法範例5.png \" 餘數乘積法範例 代碼實現 base10 = *convert1; // copy n = -1; // init // Continuously taking decimal places // convert base-10 to base-D /* Because the precision of double is 16 , so multiply it by 17 and execute at least 17 times, otherwise it will enter an infinite loop. */ for(int i = 0; i \u003c 17; i++) { base10 *= D; *convert2 += (int)base10 * pow(10, n); base10 -= (int)base10; n -= 1; if(base10 == 0) // End early { break; } } 在輸出時使用 API 提供的函式格式化。 cout \u003c\u003c setiosflags(ios::fixed) \u003c\u003c setprecision(8); 使用 GDB 進行調試，這樣能快速找到代碼問題。 ","date":"2019-10-11","objectID":"/cpp_solving_decimal_programming/:4:0","tags":["C++","小數","進制","演算法"],"title":"C++ 關於某小數轉進制的題目-解題經驗","uri":"/cpp_solving_decimal_programming/"},{"categories":["C/C++"],"content":"Functions int main() ：主程序 double Scan(string, int *)：輸入 string 的小數，轉換成 double 類型，並計算輸入小數的小數位數 bool isValid(double, int, int)：判斷輸入的小數是否符合 base-S 進制 void convert(double, int, int, double *, double *, int)：先將小數轉成 10 進制，再轉成 base-D 進制 ","date":"2019-10-11","objectID":"/cpp_solving_decimal_programming/:5:0","tags":["C++","小數","進制","演算法"],"title":"C++ 關於某小數轉進制的題目-解題經驗","uri":"/cpp_solving_decimal_programming/"},{"categories":["C/C++"],"content":"流程圖 此圖為我設計的流程圖。 註：不知道為什麼我從 draw.io 導出的圖片在 linux 下會跑版，格式亂了╮(╯_╰)╭ 最後只好使用截圖工具 繪製流程圖1.png \" 繪製流程圖 ","date":"2019-10-11","objectID":"/cpp_solving_decimal_programming/:6:0","tags":["C++","小數","進制","演算法"],"title":"C++ 關於某小數轉進制的題目-解題經驗","uri":"/cpp_solving_decimal_programming/"},{"categories":["C/C++"],"content":"源代碼 這裡還是強調一下，寫代碼時註解真的很重要，你的代碼不僅是要你自己可以快速釐清自己的代碼，不然一段時間後自己再看自己寫的內容又看不懂，而且要讓看你代碼的人能看懂。 #include\u003ciostream\u003e#include\u003cmath.h\u003e#include\u003ciomanip\u003e#include\u003cstring\u003e#include\u003cstdlib.h\u003e using namespace std; double Scan(string, int*); // count significant bool isValid(double, int, int); // Judge the number's correctness (Base-S) void convert(double, int, int, double *, double *, int); // convert the number from Base-S to Base-D and Base-10 int main() { // initialize double number = 0; // The number we need to input int S = 0; // base-S int D = 0; // base-D char isQuit = 'C'; // Judge whether to leave double convert1 = 0, convert2 = 0; // the result from convert() string count; // The number we need to input int significant = 0; // the number's significant // loop, if isQuit's value is 'Q',break it. while(isQuit == 'C') { // description cout \u003c\u003c \"Base conversion for numbers [0,1) with at least 8 significant digits.\\n\"; cout \u003c\u003c \"Convert a number from base-S to base-D (2\u003c=S\u003c=10, 2\u003c=D\u003c=10):\\n\"; // input Base-S cout \u003c\u003c \"Input S: \"; cin \u003e\u003e S; // input Base-D cout \u003c\u003c \"Input D: \"; cin \u003e\u003e D; fflush(stdin); // loop while(1) { // input number cout \u003c\u003c \"Input a valid base-\" \u003c\u003c S \u003c\u003c \" number: \"; // cin \u003e\u003e number; number = Scan(count, \u0026significant); if(isValid(number, S, significant)) // number is valid { break; } else // number is invalid { cout \u003c\u003c \"Error: \" \u003c\u003c setiosflags(ios::fixed) \u003c\u003c setprecision(8) \u003c\u003c number \u003c\u003c \" is an invalid base-\" \u003c\u003c S \u003c\u003c \" number\\n\"; } } convert(number, S, D, \u0026convert1, \u0026convert2, significant); // convert // output the result cout \u003c\u003c setiosflags(ios::fixed) \u003c\u003c setprecision(8) \u003c\u003c number \u003c\u003c \"(\" \u003c\u003c S \u003c\u003c\") is equivalent to \" \u003c\u003c convert1 \u003c\u003c\"(10) \u0026 \"\u003c\u003c convert2 \u003c\u003c\"(\"\u003c\u003c D \u003c\u003c \")\"\u003c\u003cendl; // input isQuit cout \u003c\u003c \"Process another Conversion or Quit? (C/Q) -\u003e \"; cin \u003e\u003e isQuit; // Letters into uppercase isQuit = toupper(isQuit); // initialize the values convert1 = 0; convert2 = 0; significant = 0; } system(\"pause\"); return 0; } double Scan(string count, int *significant) { *significant = 0; double number = 0; // we need to enter int N = -1; cin \u003e\u003e count; // enter the string fflush(stdin); for(int i = 2; i \u003c count.length(); i++) // use count's length to loop { *significant += 1; // count significant number += (count[i] - '0') * pow(10, N); // char -\u003e double N -=1; } return number; } bool isValid(double number, int S, int significant) { double swapDouble = 0; // Continuously taking decimal places for(int i = 0; i \u003c significant; i++) { number *= 10; if((int)number \u003e= S) // not meets Base-S { return false; // invalid } else { swapDouble = (double)((int)number); number -= swapDouble; } } return true; // valid } void convert(double number, int S, int D, double *convert1, double *convert2, int significant) { int n = -1; // the power of n double base10 = 0; // copy convert1 // Continuously taking decimal places // convert to base-10 /* Reference https://notfalse.net/17/positional-numeral-systems-conversion */ for(int i = 0; i \u003c significant; i++) { number *= 10; *convert1 += (int)number * pow(S, n); // e.g. 1.1 (base-2) -\u003e 1*2^0 + 1*2^(-1) = 1.5 (base-10) number -= (int)number; n -= 1; } base10 = *convert1; // copy n = -1; // init // Continuously taking decimal places // convert base-10 to base-D /* Because the precision of double is 16 , so multiply it by 17 and execute at least 17 times, otherwise it will enter an infinite loop. Reference https://www.cnblogs.com/upzone/articles/1389365.html */ for(int i = 0; i \u003c 17; i++) { base10 *= D; *convert2 += (int)base10 * pow(10, n); base10 -= (int)base10; n -= 1; if(base10 == 0) // End early { break; } } } ","date":"2019-10-11","objectID":"/cpp_solving_decimal_programming/:7:0","tags":["C++","小數","進制","演算法"],"title":"C++ 關於某小數轉進制的題目-解題經驗","uri":"/cpp_solving_decimal_programming/"},{"categories":["C/C++"],"content":"運行結果 運行結果6.png \" 運行結果 ","date":"2019-10-11","objectID":"/cpp_solving_decimal_programming/:8:0","tags":["C++","小數","進制","演算法"],"title":"C++ 關於某小數轉進制的題目-解題經驗","uri":"/cpp_solving_decimal_programming/"},{"categories":["C/C++"],"content":"結論 測試輸入測資，輸出與測資結果相同。 相信這題能幫助許多人能對小數進制轉換這類題目有所了解，並增進程序設計中的核心 – 演算法。祝各位學習順利，我也建議各位多主動做題目，積極去學習，這樣才會有所成長。 ","date":"2019-10-11","objectID":"/cpp_solving_decimal_programming/:9:0","tags":["C++","小數","進制","演算法"],"title":"C++ 關於某小數轉進制的題目-解題經驗","uri":"/cpp_solving_decimal_programming/"},{"categories":["C/C++"],"content":"Reference [C\u0026C++] 浮點數精準度 (Floating-Point Precision) - 逍遙文工作室 進制轉換 (二進制、八進制、十進制、十六進制) - NotFalse 技術客 十进制小数转二进制小数方法 ","date":"2019-10-11","objectID":"/cpp_solving_decimal_programming/:10:0","tags":["C++","小數","進制","演算法"],"title":"C++ 關於某小數轉進制的題目-解題經驗","uri":"/cpp_solving_decimal_programming/"},{"categories":["ArchLinux"],"content":"前言 我分享一下如何安裝 Arch Linux 的方法，因為我之前裝 Arch Linux 時踩了很多坑，加上我是小白，所以遇到的問題很多，我會在這篇文章中教導各位如何安裝 Arch Linux 在各位的電腦，優雅地使用 Arch Linux 發行版，這篇文章是面向小白向的教學文，這篇只會提及如何安裝，至於初始化與其餘部份會另外寫篇文章。 由於我的電腦型號是聯想 y7000，所以遇到的坑真的很多，我會按特殊情況講解，雖然 Installation guide - ArchWiki 的安裝指南已經很詳細了，但對於剛接觸的新手根本是火星文 :( 因為我這是專給小白寫的文章，所以寫了很多細節和注意點，如果你是高手，覺得我寫了很多廢話，那請你忍耐吧，也可以選擇不看我的文章，直接去看 ArchWiki。 ","date":"2019-09-28","objectID":"/archlinux_install_part1_basic/:1:0","tags":["ArchLinux","Linux"],"title":"Archlinux 安裝 Part 1 - Windows \u0026 Archlinux 雙系統","uri":"/archlinux_install_part1_basic/"},{"categories":["ArchLinux"],"content":"安裝前準備 ","date":"2019-09-28","objectID":"/archlinux_install_part1_basic/:2:0","tags":["ArchLinux","Linux"],"title":"Archlinux 安裝 Part 1 - Windows \u0026 Archlinux 雙系統","uri":"/archlinux_install_part1_basic/"},{"categories":["ArchLinux"],"content":"1. 至 清華大學 Archlinux 軟件鏡像站下載最新版的 archlinux*.ios 鏡像 清華大學鏡像站1.png \" 清華大學鏡像站 ","date":"2019-09-28","objectID":"/archlinux_install_part1_basic/:2:1","tags":["ArchLinux","Linux"],"title":"Archlinux 安裝 Part 1 - Windows \u0026 Archlinux 雙系統","uri":"/archlinux_install_part1_basic/"},{"categories":["ArchLinux"],"content":"2. 下載 Rufus - 用來匯入 Archlinux 鏡像至 USB Refus 官網2.png \" Refus 官網 ","date":"2019-09-28","objectID":"/archlinux_install_part1_basic/:2:2","tags":["ArchLinux","Linux"],"title":"Archlinux 安裝 Part 1 - Windows \u0026 Archlinux 雙系統","uri":"/archlinux_install_part1_basic/"},{"categories":["ArchLinux"],"content":"3. 準備一個至少 8G 的 USB 使用 Rufus 將 Arch 鏡像匯入在目標 USB 裝置。 註：在此只需修改您的目標 USB 和鏡像源即可，按下開始鍵進行匯入。 關於燒錄方式 2020/01/21 補充燒錄方式。 我幫家裡已經十年的 HP CQ40 重裝系統，因為過於老舊，電腦沒有 UEFI，只有 Legacy，所以開機無法以 UEFI 開機，這時關於燒錄鏡像的方式就需要做調整。 如果你的 Bios 有 UEFI 就使用 GPT 燒錄，如果是像我上面一樣，電腦過於老舊，當時的年代只有 Lengcy，這時你需要使用已經淘汰的 MBR 燒錄鏡像，然後建議使用 dd 燒錄。至於怎麼看自己電腦有沒有 UEFI，只需要查看自己的 Bios 是否有開機模式選項並且有 UEFI 選項。 現在大部份的電腦都有 UEFI，所以正常選擇 GPT 就好。 e.g. MBR 燒錄。 MBR 燒錄3.png \" MBR 燒錄 ","date":"2019-09-28","objectID":"/archlinux_install_part1_basic/:2:3","tags":["ArchLinux","Linux"],"title":"Archlinux 安裝 Part 1 - Windows \u0026 Archlinux 雙系統","uri":"/archlinux_install_part1_basic/"},{"categories":["ArchLinux"],"content":"4. 分割磁區 我們假設在固態硬碟割出 40GB 空間（40GB root），在虛擬硬碟割出102GB 空間（2GB swap, 100GB home），此時別格式化割出來的磁區，讓它們保持為未配置狀態。 在 Windows 工作列的 win 圖標上點擊滑鼠右鍵選擇磁區管理，將自己的磁區切割，現在大部份的電腦是 110GB 左右的固態 SSD 和 1TB 左右的虛擬硬碟，當然少部份例外，我建議固態硬碟割出至少 40GB 給 /root 根目錄（類似 Windows的 C槽），接著可以在虛擬硬碟割出 100GB 以上給 /home 家目錄，也有特殊情況，像我的室友他電腦只有固態 SSD 所以只能割固態硬碟給 /home，我室友我幫他割了 30GB 給 /root，40GB 給 /home，2GB 給 swap。 註：我強烈不建議將 Linux 灌在 USB 上或是像移動固態 SSD 等移動裝置上，首先在啟動上很不方便，每次都要進入 BIOS 調整開機順序，又容易電腦卡頓，電腦容易發燙，加上電源的耗電速度快等因素，其實我就在我室友的移動固態 SSD 上嘗試過，甚至安裝失敗，連圖形界面都進不去。 磁區管理示意圖： Windows 磁區管理4.png \" Windows 磁區管理 在磁區上點擊滑鼠右鍵選擇壓縮磁碟，應你的需求壓縮適當大小的磁區。 ","date":"2019-09-28","objectID":"/archlinux_install_part1_basic/:2:4","tags":["ArchLinux","Linux"],"title":"Archlinux 安裝 Part 1 - Windows \u0026 Archlinux 雙系統","uri":"/archlinux_install_part1_basic/"},{"categories":["ArchLinux"],"content":"5. USB 使用 UEFI 方式開機 進入 BIOS，調整 Boot 開機順序，改為你的 USB 優先開機，主機與 USB 開機模式為 UEFI 每台電腦進入 BIOS 的方法都不同，像我的電腦是聯想 y7000，所以我在開機時一直按住 Fn + F2 ，就能進入 BIOS 調整開機順序，因為幫室友們裝了 Arch，所以 ThinkPad 是 F1，華碩是按 Esc 或 F2，小米是 F2，我記得小米筆電進入 BIOS 還需要輸入 Password，有點麻煩就是了。當然還是勸大家上網搜一下自己電腦型號的進入 BIOS 快捷建。不好意思，我因為 linux 無法掛載我的移動 SSD，具體是因為我之前想將 arch 灌到 SSD 上，後來覺得使用上麻煩所以放棄了， 所以我先將該磁區刪除再新增， 成功進入 USB 後選擇第一個選項 Boot Arch Linux (X86_64) 按 Enter 進入，當你看到 root # 就代表你已經進入 USB 裡的 Arch 安裝鏡像。 註：切記要是 UEFI 開機，因為我們最後要在 BIOS 安裝引導程序，來引導我們開機選擇進入的 OS。如果沒有使用 UEFI 開機的話會裝不上引導程序 grub。 當然如果你的電腦沒辦法使用 UEFI，並且前面的燒錄方式使用的是 MBR，在後面分割磁區時就需要用不同的方式，然後 GRUB 引導也是不同的指令。 Arch Linux Live CD5.png \" Arch Linux Live CD ","date":"2019-09-28","objectID":"/archlinux_install_part1_basic/:2:5","tags":["ArchLinux","Linux"],"title":"Archlinux 安裝 Part 1 - Windows \u0026 Archlinux 雙系統","uri":"/archlinux_install_part1_basic/"},{"categories":["ArchLinux"],"content":"6. 確認連到網路 在安裝過程我們需要用到網路，我們需要確認我們連的到網路，輸入以下指令 ping baidu.com # 確認是否可連上百度 如果你的結果與下圖相同則代表你已連上了網路，按下 Ctrl + C 中止命令， ping 指令測試連網6.png \" ping 指令測試連網 如果無法從 baidu.com 接收 packets，掉包率（packets loss）100%，代表你沒有連上網路，這時我建議插網線連有線網路，不建議連無線網路，因為在無線網路使用上會出些問題，不建議新手使用，我最常用的方法是將使用數據線將電腦與手機連結，然後手機開 USB 共用網路，手機可以連行動數據或 WiFi 給電腦網路。 1.插上網線 ip link #顯示自己的網路接口 顯示網路接口7.png \" 顯示網路接口 enp7s0 是我的有線接口，wlp0s20f3 是我的無線接口，當然這些接口名稱會隨著電腦不同而不同但大多相似。 ip link set enp7s0 up # 將有線接口打開 dhcpcd enp7s0 # 連接接口 ping baidu.com # 再測試一次是否連網 以上如果沒問題就可跳過用手機共用網路步驟 2.用數據線將手機與電腦連結，並開啟 USB 共用網路 輸入 ip link 後出現了新的有線接口 enp0s20f0u1，此為你的手機網路接口。 註：通常自己電腦的有線網路接口名稱比手機的網路接口名稱短。 手機網路接口8.png \" 手機網路接口 ip link set enp7s0 down # 關閉自己電腦的有線接口 ip link set enp0s20f0u1 up # 開啟手機的有線接口 dhcpcd enp0s20f0u1 # 連接手機的有線接口 ping baidu.com # 測試是否連上網路 通常到這裡網路是連上的，如果還連不上那可能就要連無線 WiFi 了，我就不多說明了，可以參考 Wireless network configuration (简体中文) - ArchWiki 和 某網友的 Blog 和 某教程網 有提及，因為之前我幫我朋友安裝 Archlinux 時要連無線 WiFi 時搞了很久，還出了錯誤，最後直接使用手機的共用網路才解決。 ","date":"2019-09-28","objectID":"/archlinux_install_part1_basic/:2:6","tags":["ArchLinux","Linux"],"title":"Archlinux 安裝 Part 1 - Windows \u0026 Archlinux 雙系統","uri":"/archlinux_install_part1_basic/"},{"categories":["ArchLinux"],"content":"7. 更新系統時間 使用 timedatectl 確保系統時間是準確的，後面我們在同步數據庫時需要系統時間與網路時間的同步。 註：這一步真的很重要，我之前因為忘了這一步驟導致數據庫無法同步，開啟時間同步後還要進入 Chroot 重裝一次系統 pacman -S linux timedatectl set-ntp true # 開啟時間同步 timedatectl status # 檢查服務狀態 查看系統時間9.png \" 查看系統時間 請確保 NTP service 狀態為 active，且確定自己的系統時間是否正確。 ","date":"2019-09-28","objectID":"/archlinux_install_part1_basic/:2:7","tags":["ArchLinux","Linux"],"title":"Archlinux 安裝 Part 1 - Windows \u0026 Archlinux 雙系統","uri":"/archlinux_install_part1_basic/"},{"categories":["ArchLinux"],"content":"8. 分割磁區 我們使用 cfdisk 來分割磁區 ArchWiki 建議的分區參考 ArchWiki 建議的磁區分區10.png \" ArchWiki 建議的磁區分區 我們已經在 Windows 分割好了我們的磁區。我們使用的是 GPT 的方案。 lsblk # 檢查磁區狀態 檢查磁區分區情況11.png \" 檢查磁區分區情況 以上是我的磁區狀態，因為我是已經裝好了系統，所以會顯示這樣的狀態，但你現在的狀態是不會顯示出你切割出來的磁區，這裡記得你的磁區大小以便在這裡辨認出你的磁區哪些是固態硬碟和虛擬硬碟。 註：有些指南標示 /dev/sdX 的 sdX 意思是你的磁區代號，有些電腦的固態硬碟代號是 sdb 或是 nvme0n1，虛擬硬碟通常代號是 sda，你可以將 sdX 當成一個代稱，因為沒人保證你電腦裡的硬碟的代號為何，像我有個室友他電腦的固態硬碟是 sdb。 在輸入路徑時可以搭配 Tab 鍵快速輸入，輸入開頭先按一次 Tab，如果指令行下出現許多路徑可按兩次 Tab 選取。 在這裡我們假設你的固態硬碟是 nvme0n1 - 割出 40GB 給 root，虛擬硬碟是 sda - 割出 102GB。輸入以下指令進入管理磁區界面。 cfdisk /dev/nvme0n1 # 管理固態硬碟磁區 管理固態硬碟磁區12.png \" 管理固態硬碟磁區 這裡是管理你的固態硬碟界面。先使用上下鍵調到你割出來的 Free Space 40GB，左右鍵調到 New 按下 Enter，輸好要分配出的大小再按 Enter 將空間分配出來，接著左右鍵調到 Type，選取 Linux root (ARM-64)，這是 64 bit 的系統，如果你的電腦是 32 bit 請選擇 Linux root (X86)，接著確認你的磁區上面有個磁區類型是 EFI System ，並記住磁區代號或大小，這裡是要掛載 boot 的磁區，如果沒有的話請找到可以自己在割出大概從某個磁區割出 250MB 調整類型為 EFI System 分區。接著左右鍵調到 Write 寫入設定，輸入 yes 按下 Enter，確認無誤後可以按下 Quit 離開此界面，再次 輸入 lsblk 就可以在 /dev/nvme0n1 看到你分割出的空間了。 註：記得一定要寫入，我之前很多次都忘了寫入，重搞了幾次。 cfdisk /dev/sda # 管理虛擬硬碟磁區 示意圖我就不放了，方式都跟上個步驟大同小異，分別割出 2GB Type 為 Linux Swap 和 100GB Type 為 Linux home 的分區。 註：有些人的電腦可能沒有我上述講的類型，如果找不到 Linux root (ARM-64)、Linux root (X86)、Linux home，可以將 Type 改成 Linux filesystem，只是 EFI System 與 Linux swap 不能這樣搞，而且這兩類型是找得到的。 ","date":"2019-09-28","objectID":"/archlinux_install_part1_basic/:2:8","tags":["ArchLinux","Linux"],"title":"Archlinux 安裝 Part 1 - Windows \u0026 Archlinux 雙系統","uri":"/archlinux_install_part1_basic/"},{"categories":["ArchLinux"],"content":"9. 格式化磁區 當分區建好後，我們需要對此格式化。每種類型的磁區格式化方式都不相同。 註：我們假設你分割出的 40GB 固態硬碟空間磁區代號為 nvme0n1p5，boot 為 nvme0n1p1，2GB Swap 為 sda3 ，100GB home 為 sda4。 註：mkfs.ext4 的創建方式與 mkfs.fat 的差別在於前者有創建 journal 日誌，後者沒有。注意：文件系統一定要創建日誌，不然個人的資料可能會造成損失等後果。 文件系統 root 與 home 關於文件系統可以建議裝 xfs 或是 btrfs。我會在後面的重要補充的地方說明。 mkfs.ext4 /dev/nvme0n1p5 #格式化 root mkfs.ext4 /dev/sda4 #格式化 home EFI 系統分區 boot 注意：這裡只是提供 EFI 格式化方式，如果你的 EFI 已是 Windows 系統的分區，則不建議格式化該 EFI 分區，會造成原有的 Windows 系統崩潰，直接略過格式化 boot。 mkfs.fat -F32 /dev/nvme0n1p1 # 格式化 boot 置換空間 swap mkswap /dev/sda3 # 格式化 swap swapon /dev/sda3 # 掛載置換空間 ","date":"2019-09-28","objectID":"/archlinux_install_part1_basic/:2:9","tags":["ArchLinux","Linux"],"title":"Archlinux 安裝 Part 1 - Windows \u0026 Archlinux 雙系統","uri":"/archlinux_install_part1_basic/"},{"categories":["ArchLinux"],"content":"10. 掛載分區 因為根目錄 /mnt 已在你的 USB 存在，所以不需要創建。注意：必須優先掛載 /mnt 再掛載其它目錄。 mount /dev/nvme0n1p5 /mnt # 掛載根目錄 root mkdir /mnt/boot # 創建 /boot 目錄 mount /dev/nvme0np1 /mnt/boot # 掛載 /boot mkdir /mnt/home # 創建 /home 目錄 mount /dev/sda4 /mnt/home # 掛載 /home lsblk # 查看分區無誤 掛載好後，接下來 genfstab 將會自動檢測掛載的文件系統和置換空間。 ","date":"2019-09-28","objectID":"/archlinux_install_part1_basic/:2:10","tags":["ArchLinux","Linux"],"title":"Archlinux 安裝 Part 1 - Windows \u0026 Archlinux 雙系統","uri":"/archlinux_install_part1_basic/"},{"categories":["ArchLinux"],"content":"安裝 ","date":"2019-09-28","objectID":"/archlinux_install_part1_basic/:3:0","tags":["ArchLinux","Linux"],"title":"Archlinux 安裝 Part 1 - Windows \u0026 Archlinux 雙系統","uri":"/archlinux_install_part1_basic/"},{"categories":["ArchLinux"],"content":"1. 選擇鏡像 編輯 /etc/pacman.d/mirrorlist 文件，將你的所在的鏡像地址優先排在前面，在列表中越前面的地址修先級越高。 vim /etc/pacman.d/mirrorlist # 編輯文件 關於 Vim 的編輯指令可參考 超簡明 Vim 操作介紹，用起來其實不難。 超簡明 VIM 編輯指令13.png \" 超簡明 VIM 編輯指令 關於 Vim 移動整行的指令 :12, 13 move 6 # 將第 12, 13 行剪貼至第 6 行 像我目前所在的地區為 China，所以我將 China 的鏡像源都移至最開頭。 編輯鏡像列表14.png \" 編輯鏡像列表 編輯好並確認無誤後退出 Vim 編輯器。 ","date":"2019-09-28","objectID":"/archlinux_install_part1_basic/:3:1","tags":["ArchLinux","Linux"],"title":"Archlinux 安裝 Part 1 - Windows \u0026 Archlinux 雙系統","uri":"/archlinux_install_part1_basic/"},{"categories":["ArchLinux"],"content":"2. 安裝基本系統 使用 pacstrap 腳本安裝 base 組： 註：在這裡請務必確認你的 /boot 是掛載在 EFI Syetem 分區上，不然後面需要進入 Chroot 執行 pacman -S linux 重裝系統。 ping baidu.com # 確認此時你是連上網的 pacstrap /mnt base linux linux-firmware # 安裝基本系統 如果你是第二次裝 ArchLinux 的小夥伴，你執行以上指令可能會遇到下載完後安裝時，顯示 /boot/vmlinuz-linux 已存在，所以無法安裝，這時執行以下指令。 rm /boot/vmlinuz-linux # 刪除該檔案 pacstrap /mnt base linux linux-firmware # 安裝基本系統 註：pacstrap 的安裝指令我在 2020/01/04 更新，因為幫同學重灌 ArchLinux 時發現指令變了，目前最新本的 ArchLinux 發行版指令是 pacstrap /mnt base linux linux-firmware。 ","date":"2019-09-28","objectID":"/archlinux_install_part1_basic/:3:2","tags":["ArchLinux","Linux"],"title":"Archlinux 安裝 Part 1 - Windows \u0026 Archlinux 雙系統","uri":"/archlinux_install_part1_basic/"},{"categories":["ArchLinux"],"content":"配置系統 ","date":"2019-09-28","objectID":"/archlinux_install_part1_basic/:4:0","tags":["ArchLinux","Linux"],"title":"Archlinux 安裝 Part 1 - Windows \u0026 Archlinux 雙系統","uri":"/archlinux_install_part1_basic/"},{"categories":["ArchLinux"],"content":"1. Fastab 執行以下指令生成 fstab 文件（用 -U 或 -L 選項設置 UUID 或卷標）。 genfstab -U /mnt \u003e\u003e /mnt/etc/fstab # 生成 fstab 文件 我個人強烈建議生成完 fstab 後使用 Vim 查看內容，尤其是重裝 Arch 和重新分配磁區的人一定要查看這份文件。 註：我之前因為將 /root 掛載在虛擬硬碟，所以在 Linux 環境下電腦特別卡，在重灌一次後因為沒有重新砍掉 fstab 文件生成一次，所以上一次安裝時的設定即使執行生成 fstab 文件指令，還是會保留設定無法去除，只是添加了設定，無法覆蓋源設定，造成第二次還是那麼卡。 vim /mnt/etc/fstab # 查看 fstab 文件 請確認這份文件裡只有四份資料（如果有多分割幾個磁區，就可能不是只有四份，你掛載幾個目錄就有幾份資料，不能多不能少）。 fstab 內容 tabletable.png \" fstab 內容 table fastab 內容15.png \" fastab 內容 如果你的文件有問題且資料混亂執行以下指令。 rm /mnt/etc/fstab # 移除原文件 genfstab -U /mnt \u003e\u003e /mnt/etc/fstab # 生成 fstab 文件 再次用 Vim 確認無誤之後，就可進入下一步。 ","date":"2019-09-28","objectID":"/archlinux_install_part1_basic/:4:1","tags":["ArchLinux","Linux"],"title":"Archlinux 安裝 Part 1 - Windows \u0026 Archlinux 雙系統","uri":"/archlinux_install_part1_basic/"},{"categories":["ArchLinux"],"content":"2. 進入 Chroot Change root 到新安裝的系統，顧名思義就是進入電腦以安裝好的系統，目前我們所在的地方是 USB，如果沒進入 Chroot 就進行安裝和設定就等於安裝和設定在你的 USB 上。 註：如果重裝系統或是需要重新插上 USB 做些設定，像我通常就發生在磁區分割錯誤或目錄掛載錯誤或 Windows 系統更新後引導程序設定檔被砍，需要先將所有的分區先掛載，再進入 Chroot 才會顯示你電腦裡的磁區，再次強調，先掛載 /mnt。 arch-chroot /mnt # 進入 Chroot ","date":"2019-09-28","objectID":"/archlinux_install_part1_basic/:4:2","tags":["ArchLinux","Linux"],"title":"Archlinux 安裝 Part 1 - Windows \u0026 Archlinux 雙系統","uri":"/archlinux_install_part1_basic/"},{"categories":["ArchLinux"],"content":"3. 時區 設置時區，Region 為你所在的洲，City 為你所在城市。 ln -sf /usr/share/zoneinfo/Region/City /etc/localtime # 設置時區 我設定的是台北時間。 ln -sf /usr/share/zoneinfo/Asia/Taipei /etc/localtime 執行 hwclock 生成 /etc/adjtime。 hwclock --systohc # 生成 /etc/adjtime 這個指令假定硬件時間已經設置為 UTF 時間。 ","date":"2019-09-28","objectID":"/archlinux_install_part1_basic/:4:3","tags":["ArchLinux","Linux"],"title":"Archlinux 安裝 Part 1 - Windows \u0026 Archlinux 雙系統","uri":"/archlinux_install_part1_basic/"},{"categories":["ArchLinux"],"content":"4. 添加本地語系 註：進入 arch-chroot 後需要將 nano 和 vim 裝上去，pacman -S nano vim，這樣才能使用這些工具。 編輯 locale.gen 把自己要用的語言註解去掉，也就是去掉開頭的 #，一定要取消註解 en_US.UTF-8 UTF-8，建議取消註解帶 UTF-8 的語言，把 GBK 和 BIG5 註解去掉可以支援更多字。 nano /etc/locale.gen # 編輯 locale.gen 以下是我要取消註解的語言，因為我繁體字和簡體字都很常用。 en_US.UTF-8 UTF-8zh_CN.GB18030 GB18030zh_CN.GBK GBKzh_TW.EUC-TW EUC-TWzh_TW.UTF-8 UTF-8 執行 locale-gen 生成 locale 訊息。 locale-gen # 生成 locale 訊息 接著創建 locale.conf 檔案並編輯 LANG 這一個語言環境環境變量為英語 en_US.UTF-8，如果你設為中文的話會造成 tty 出現亂碼。 vim /etc/locale.conf # 創建並編輯 locale.conf 修改語言環境。 LANG=en_US.UTF-8 # 變量設為英語 ","date":"2019-09-28","objectID":"/archlinux_install_part1_basic/:4:4","tags":["ArchLinux","Linux"],"title":"Archlinux 安裝 Part 1 - Windows \u0026 Archlinux 雙系統","uri":"/archlinux_install_part1_basic/"},{"categories":["ArchLinux"],"content":"5. 主機名稱與網路 創建 hostname 文件設置你的主機名稱。 vim /etc/hostname # 創建 hostname 文件 直接在 hostname 填入你主機名稱，myhostname是你的主機名。 myhostname # 你的主機名稱 添加對應訊息到 hosts(5)。 vim /etc/hosts # 編輯 hosts 寫入以下內容，將 myhostname 修改成你前面設定的主機名稱。 註：如果系統有一個永久的 IP 地址，請使用這個永久的 IP 地址，而不是 127.0.1.1。 像我就沒有設永久 IP，所以直接編輯成以下內容。 127.0.0.1 localhost::1 localhost127.0.1.1 myhostname.localdomain myhostname ","date":"2019-09-28","objectID":"/archlinux_install_part1_basic/:4:5","tags":["ArchLinux","Linux"],"title":"Archlinux 安裝 Part 1 - Windows \u0026 Archlinux 雙系統","uri":"/archlinux_install_part1_basic/"},{"categories":["ArchLinux"],"content":"6. Initramfs 創建 Initramfs，這是用來將內存盤初始化的腳本，例如開關機時掛載與卸載磁區，現在 Initramfs已取代了舊版的 initrd。 mkinitcpio -p linux # 創建 Initramfs 如果你想深入了解 Initramfs，可以參考 mkinitcpio (简体中文) - ArchWiki 和 Initramfs/指南 - gentoo linux。 ","date":"2019-09-28","objectID":"/archlinux_install_part1_basic/:4:6","tags":["ArchLinux","Linux"],"title":"Archlinux 安裝 Part 1 - Windows \u0026 Archlinux 雙系統","uri":"/archlinux_install_part1_basic/"},{"categories":["ArchLinux"],"content":"7. 設定 Root (超級使用者) 密碼 設定 Root 超級使用者的密碼，超級使用者的意思就是這個用戶相當於系統管理員，擁有修改系統設定的所有權力。 輸入以下指令後會要求你輸兩次密碼，第二次是確認你的密碼正確，輸入密碼時文字是隱藏的，所以不用慌張以為沒有輸入進去。 passwd # 設定密碼 ","date":"2019-09-28","objectID":"/archlinux_install_part1_basic/:4:7","tags":["ArchLinux","Linux"],"title":"Archlinux 安裝 Part 1 - Windows \u0026 Archlinux 雙系統","uri":"/archlinux_install_part1_basic/"},{"categories":["ArchLinux"],"content":"8. 安裝引導程序 因為我之前裝的引導程序是 rEFInd，但 rEFInd 實在太不穩了，好幾次隨著 Windows 更新而設定檔被砍進不了 Linux，需要重裝，然後我朋友推薦給我使用直接裝在 BIOS 的 grub，穩定不容易被砍，雖然界面比 rEFInd 丑了很多，但至少穩定。 grub 是引導程序，os-prober是可以偵測其他操作系統的軟體包，efibootmgr可以操控 UEFI 固件啟動管理器設置的工具。 註：請確定你是以 UEFI 模式開機，不然會一直報錯 efi variables are not supported on this system。這時你就必須重新開機進入 BIOS 調整開機模式再進到 Arch Linux 安裝碟安裝 grub。也請確定你的 Boot 是掛載在 EFI System 磁區，不然你無法產生 grub 設定檔，原因在於我們是要掛載在 Boot，但因為 Boot 沒掛載到 EFI 磁區，所以在 EFI 磁區找不到 Boot，產生路徑錯誤。 sudo pacman -Syu # 現在更新一下系統 sudo pacman -Syy # 同步數據庫 sudo pacman -S grub os-prober efibootmgr # 下載軟體包 接著把 grub 安裝到 EFI System 磁區，將以下指令--efi-directory 的 esp 改為你的 grub 掛載點，我們要將 grub 掛載到 /boot 上，所以 esp 改為 /boot。 指令格式 grub-install --target=x86_64-efi --efi-directory=esp --bootloader-id=grub 我的掛載方式 grub-install --target=x86_64-efi --efi-directory=/boot --bootloader-id=grub 然後掛載你的 Windows 磁區，你的固態硬碟 C 槽磁區，沒掛載的話到時候產生設定檔會找不到你的 Windows。 mkdir /mnt/windows # 創建 C 槽目錄 mount /dev/sdaX1 /mnt/windows # 掛載到目標磁區 當然如果你還想讀取其它 Windows 的磁區，你可以現在順便掛載好，當然後面再掛載也行。 現在我想將我的虛擬硬碟 Wiindows 的 D 槽掛載。 mkdir /mnt/Data # 創建 D 槽目錄 mount /dev/sdaX2 /mnt/Data # 掛載到目標磁區 然後產生 grub 設定檔。 grub-mkconfig -o /boot/grub/grub.cfg 確認設定檔產生無報錯後接著退出 Chroot。 exit # 退出 Chroot ","date":"2019-09-28","objectID":"/archlinux_install_part1_basic/:4:8","tags":["ArchLinux","Linux"],"title":"Archlinux 安裝 Part 1 - Windows \u0026 Archlinux 雙系統","uri":"/archlinux_install_part1_basic/"},{"categories":["ArchLinux"],"content":"重要補充 ","date":"2019-09-28","objectID":"/archlinux_install_part1_basic/:5:0","tags":["ArchLinux","Linux"],"title":"Archlinux 安裝 Part 1 - Windows \u0026 Archlinux 雙系統","uri":"/archlinux_install_part1_basic/"},{"categories":["ArchLinux"],"content":"MBR 的 GRUB 引導指令 sdX 為 /root 的磁區。 grub-install --target=i386-pc /dev/sdX ","date":"2019-09-28","objectID":"/archlinux_install_part1_basic/:5:1","tags":["ArchLinux","Linux"],"title":"Archlinux 安裝 Part 1 - Windows \u0026 Archlinux 雙系統","uri":"/archlinux_install_part1_basic/"},{"categories":["ArchLinux"],"content":"雙 Arch 系統 2020 / 02 / 05 補充 我想有些人會為了腦熱或好奇心而裝三系統，像我室友是 Windows + 兩個 Arch，這時引導 grub 的設置就顯得重要。 在做這三系統時，你必須確保你兩個 Arch 的系統不是共用一個 /boot，然後你只需要在其中一個 Arch 系統中設置安裝 GRUB。 你在其中一個 Arch 系統中執行完上述的步驟產生出 grub.cfg 設定檔後，我們開始我們設定我們的 GRUB 設定檔。 查看 UUID 你需要將你另一個 Arch 系統 /root 和 /boot 的 UUID 記住。像我的 root 的 UUID 是 a48c597a-d1f2-4f4a-82f8-ba96114912f1、boot 的 UUID 是 1258-CD76。 lsblk -f # 檢查各磁區 UUID # 以下是輸出結果 NAME FSTYPE FSVER LABEL UUID FSAVAIL FSUSE% MOUNTPOINT sda ├─sda1 ├─sda2 ntfs DATA FEBCDBDCBCDB8D91 ├─sda3 ext4 1.0 bcdb5959-181b-4a68-94e3-f5b79c0a14a8 55.1G 37% /home └─sda4 swap 1 867cc6ea-05af-4676-b36f-875dd7570a38 [SWAP] nvme0n1 ├─nvme0n1p1 vfat FAT32 SYSTEM_DRV 1258-CD76 164.3M 36% /boot ├─nvme0n1p2 ├─nvme0n1p3 ntfs Windows 46DA5983DA597063 ├─nvme0n1p4 ntfs F4B6F775B6F73728 └─nvme0n1p5 ext4 1.0 a48c597a-d1f2-4f4a-82f8-ba96114912f1 2.3G 87% / 編輯 GRUB 設定檔 紀錄後，就編輯 /boot/grub/grub.cfg。 vim /boot/grub/grub.cfg 加上以下內容，並將下面所有的 rootUUID 和 bootUUID 分別改成你另一個 Arch 系統的 /root 和 /boot 的 UUID。至於開頭的 Arch Linux 可改成自己想取的名字。Advanced options for Arch Linux 也改成你自己想取的名字。 menuentry 'Arch Linux' --class arch --class gnu-linux --class gnu --class os $menuentry_id_option 'gnulinux-simple-rootUUID' { load_video set gfxpayload=keep insmod gzio insmod part_gpt insmod fat if [ x$feature_platform_search_hint = xy ]; then search --no-floppy --fs-uuid --set=root bootUUID else search --no-floppy --fs-uuid --set=root bootUUID fi echo 'Loading Linux linux ...' linux /vmlinuz-linux root=UUID=rootUUID rw loglevel=3 quiet echo 'Loading initial ramdisk ...' initrd /initramfs-linux.img } submenu 'Advanced options for Arch Linux' $menuentry_id_option 'gnulinux-advanced-rootUUID' { menuentry 'Arch Linux, with Linux linux' --class arch --class gnu-linux --class gnu --class os $menuentry_id_option 'gnulinux-linux-advanced-rootUUID' { load_video set gfxpayload=keep insmod gzio insmod part_gpt insmod fat if [ x$feature_platform_search_hint = xy ]; then search --no-floppy --fs-uuid --set=root bootUUID else search --no-floppy --fs-uuid --set=root bootUUID fi echo 'Loading Linux linux ...' linux /vmlinuz-linux root=UUID=rootUUID rw loglevel=3 quiet echo 'Loading initial ramdisk ...' initrd /initramfs-linux.img } menuentry 'Arch Linux, with Linux linux (fallback initramfs)' --class arch --class gnu-linux --class gnu --class os $menuentry_id_option 'gnulinux-linux-fallback-rootUUID' { load_video set gfxpayload=keep insmod gzio insmod part_gpt insmod fat if [ x$feature_platform_search_hint = xy ]; then search --no-floppy --fs-uuid --set=root bootUUID else search --no-floppy --fs-uuid --set=root bootUUID fi echo 'Loading Linux linux ...' linux /vmlinuz-linux root=UUID=rootUUID rw loglevel=3 quiet echo 'Loading initial ramdisk ...' initrd /initramfs-linux-fallback.img } } ","date":"2019-09-28","objectID":"/archlinux_install_part1_basic/:5:2","tags":["ArchLinux","Linux"],"title":"Archlinux 安裝 Part 1 - Windows \u0026 Archlinux 雙系統","uri":"/archlinux_install_part1_basic/"},{"categories":["ArchLinux"],"content":"連網 因為拔掉 USB 重啟電腦後，會發現關於連網功能不好處理，使用 ip link 後 dhcpcd 過於繁瑣，建議就在這裡就安裝連網的管理器。 註：在 Chroot 中無法使用 systemctl，所以要等全部裝完後再啟用。 arch-chroot /mnt # 進入 Chroot pacman -S networkmanager # 安裝 networkmanager exit # 退出 Chroot ","date":"2019-09-28","objectID":"/archlinux_install_part1_basic/:5:3","tags":["ArchLinux","Linux"],"title":"Archlinux 安裝 Part 1 - Windows \u0026 Archlinux 雙系統","uri":"/archlinux_install_part1_basic/"},{"categories":["ArchLinux"],"content":"不裝雙系統，只有 Linux 如果你是將所有電腦裡的系統都砍了只裝 Archlinux，你一樣要裝引導，像之前我幫一個朋友裝 ArchLinux 時他將自己電腦上的 Windows 全砍了，剩下所有空間都給 Linux。 ","date":"2019-09-28","objectID":"/archlinux_install_part1_basic/:5:4","tags":["ArchLinux","Linux"],"title":"Archlinux 安裝 Part 1 - Windows \u0026 Archlinux 雙系統","uri":"/archlinux_install_part1_basic/"},{"categories":["ArchLinux"],"content":"文件系統 XFS 與 Btrfs 2020 / 02 / 05 補充文件系統 XFS 和 Btrfs。 2020 / 07 / 29 更新，我已經用上 Btrfs，真香，讀寫速度變很快。 因為我文件系統使用 ext4 使用 ntfs-3g 寫入時非常慢，甚至卡頓，我在這裡推薦使用 XFS 或是 Btrfs。但是 Btrfs 還不夠穩定，所以我這裡是推薦 XFS。 XFS 是一種高性能的日誌文件系統，XFS 特別擅長處理大文件，同時提供平滑的數據傳輸。當前 CentOS 7 也將 XFS + LVM 作為默認的文件系統。 Btrfs 是一種用於 Linux 的新的寫時複製文件系統，旨在實現高級功能，同時專注於容錯、修復和輕鬆的管理。 ","date":"2019-09-28","objectID":"/archlinux_install_part1_basic/:6:0","tags":["ArchLinux","Linux"],"title":"Archlinux 安裝 Part 1 - Windows \u0026 Archlinux 雙系統","uri":"/archlinux_install_part1_basic/"},{"categories":["ArchLinux"],"content":"XFS mkfs.xfs /dev/nvme0n1p5 #格式化 root mkfs.xfs /dev/sda4 #格式化 home 在安裝 base 時要輸入以下內容，將 xfsprogs 包加入： pacstrap /mnt base linux linux-firmware xfsprogs 更多請參考 XFS (简体中文) - ArchWiki。 ","date":"2019-09-28","objectID":"/archlinux_install_part1_basic/:6:1","tags":["ArchLinux","Linux"],"title":"Archlinux 安裝 Part 1 - Windows \u0026 Archlinux 雙系統","uri":"/archlinux_install_part1_basic/"},{"categories":["ArchLinux"],"content":"Btrfs mkfs.btrfs -L arch-root /dev/nvme0n1p5 #格式化 root mkfs.btrfs -L arch-home /dev/sda4 #格式化 home 在安裝 base 時要輸入以下內容，將 btrfs-progs 包加入： pacstrap /mnt base linux linux-firmware btrfs-progs 更多請參考 Btrfs (简体中文) - ArchWiki。 ","date":"2019-09-28","objectID":"/archlinux_install_part1_basic/:6:2","tags":["ArchLinux","Linux"],"title":"Archlinux 安裝 Part 1 - Windows \u0026 Archlinux 雙系統","uri":"/archlinux_install_part1_basic/"},{"categories":["ArchLinux"],"content":"重啟電腦 因為我手速不夠快，如果不小心在還沒完全關機或已經開機狀態下拔下 USB，會造成嚴重錯誤，所以我選擇直接關機再手動開機。 reboot # 重開機 poweroff # 直接關機 關機後立刻將 USB 拔出電腦，然後開機，如果開機沒有進入 grub，重開機一次進入 BIOS 會看到 有 grub 的開機選項，將這個選項調到最優先開機就行了。 登入時輸入 user 為 root，password 為你之前設的 Root 密碼。 ","date":"2019-09-28","objectID":"/archlinux_install_part1_basic/:7:0","tags":["ArchLinux","Linux"],"title":"Archlinux 安裝 Part 1 - Windows \u0026 Archlinux 雙系統","uri":"/archlinux_install_part1_basic/"},{"categories":["ArchLinux"],"content":"安裝後工作 我會之後會寫 Arch Linux 安裝後文章，並放入 Blog。 ","date":"2019-09-28","objectID":"/archlinux_install_part1_basic/:8:0","tags":["ArchLinux","Linux"],"title":"Archlinux 安裝 Part 1 - Windows \u0026 Archlinux 雙系統","uri":"/archlinux_install_part1_basic/"},{"categories":["ArchLinux"],"content":"Reference Installation guide (简体中文) - ArchWiki 超簡明 Vim 操作介紹 - 為你自己學 Git 请问vim如何移动当前行向上或向下？不用选中 - V2EX EFI system partition (简体中文) - ArchWiki Network configuration (简体中文) - ArchWiki mkinitcpio (简体中文) - ArchWiki Initramfs/指南 - gentoo linux Localization/Simplified Chinese (简体中文) - ArchWiki Unified Extensible Firmware Interface (简体中文) - ArchWiki GRUB (简体中文) - ArchWiki Linux文件系統格式有哪些類型？選錯你就要辭職了 - 今日頭條 XFS (简体中文) - ArchWiki Btrfs (简体中文) - ArchWiki ","date":"2019-09-28","objectID":"/archlinux_install_part1_basic/:9:0","tags":["ArchLinux","Linux"],"title":"Archlinux 安裝 Part 1 - Windows \u0026 Archlinux 雙系統","uri":"/archlinux_install_part1_basic/"},{"categories":["ArchLinux"],"content":"前言 相信我，肥宅我看了很多網站上教學，都是老舊的廢文，甚至如果照做就有可能造成出錯的問題。還有很多文章也沒有詳細講解該如何配置，關於 Linux 中的 GDB 配置在 VScode 的文章少之又少，錯誤百出。因此肥宅在這教導各位正確地在 Linux 環境下從安裝 VScode 到配置環境變量與 GDB 調試。 ","date":"2019-04-20","objectID":"/archlinux_vscode_build_gdb_gcc/:1:0","tags":["ArchLinux","VScode","C","C++","GCC","GDB"],"title":"在 Archlinux 搭建 VScode C/C++ 開發環境（GCC）及 調試（GDB）","uri":"/archlinux_vscode_build_gdb_gcc/"},{"categories":["ArchLinux"],"content":"肥宅的 Linux 發行版資訊 肥宅使用的發行版是 ArchLinux，圖形界面是 KDE Plasma。 系統資訊1.png \" 系統資訊 ","date":"2019-04-20","objectID":"/archlinux_vscode_build_gdb_gcc/:2:0","tags":["ArchLinux","VScode","C","C++","GCC","GDB"],"title":"在 Archlinux 搭建 VScode C/C++ 開發環境（GCC）及 調試（GDB）","uri":"/archlinux_vscode_build_gdb_gcc/"},{"categories":["ArchLinux"],"content":"下載安裝 VScode ","date":"2019-04-20","objectID":"/archlinux_vscode_build_gdb_gcc/:3:0","tags":["ArchLinux","VScode","C","C++","GCC","GDB"],"title":"在 Archlinux 搭建 VScode C/C++ 開發環境（GCC）及 調試（GDB）","uri":"/archlinux_vscode_build_gdb_gcc/"},{"categories":["ArchLinux"],"content":"在 Konsole 輸入下載指令 sudo pacman -S code 註：因爲圖形界面的使用者一定是一般使用者，不可能是超級使用者，所以在輸 pacman 前面要加上 sudo。 安裝 VScode2.png \" 安裝 VScode 輸入 y 並按下 Enter。 ","date":"2019-04-20","objectID":"/archlinux_vscode_build_gdb_gcc/:3:1","tags":["ArchLinux","VScode","C","C++","GCC","GDB"],"title":"在 Archlinux 搭建 VScode C/C++ 開發環境（GCC）及 調試（GDB）","uri":"/archlinux_vscode_build_gdb_gcc/"},{"categories":["ArchLinux"],"content":"下載 GCC GDB 註：肥宅是在 Windows OS 用習慣了 MinGW-w64，但在 Linux 這樣配置並不是很好的選擇，如果你使用 GCC 或 Clang 會跟 Linux 兼容性高。MinGW-w64 軟件包包含 gcc g++ GDB…等內容及 API。 在這裡肥宅使用 GCC 與 GDB ","date":"2019-04-20","objectID":"/archlinux_vscode_build_gdb_gcc/:4:0","tags":["ArchLinux","VScode","C","C++","GCC","GDB"],"title":"在 Archlinux 搭建 VScode C/C++ 開發環境（GCC）及 調試（GDB）","uri":"/archlinux_vscode_build_gdb_gcc/"},{"categories":["ArchLinux"],"content":"在 Konsole 輸入下載指令 ","date":"2019-04-20","objectID":"/archlinux_vscode_build_gdb_gcc/:4:1","tags":["ArchLinux","VScode","C","C++","GCC","GDB"],"title":"在 Archlinux 搭建 VScode C/C++ 開發環境（GCC）及 調試（GDB）","uri":"/archlinux_vscode_build_gdb_gcc/"},{"categories":["ArchLinux"],"content":"GCC sudo pacman -S gcc 安裝 GCC3.png \" 安裝 GCC 輸入 y 並按下 Enter。 ","date":"2019-04-20","objectID":"/archlinux_vscode_build_gdb_gcc/:4:2","tags":["ArchLinux","VScode","C","C++","GCC","GDB"],"title":"在 Archlinux 搭建 VScode C/C++ 開發環境（GCC）及 調試（GDB）","uri":"/archlinux_vscode_build_gdb_gcc/"},{"categories":["ArchLinux"],"content":"GDB sudo pacman -S gdb 安裝 GDB4.png \" 安裝 GDB 輸入 y 並按下 Enter。 補充： 註：有些小白可能不懂，在此肥宅附上 WIKI 連結 GCC-維基百科，自由的百科全書 Clang-維基百科，自由的百科全書 MinGW-維基百科，自由的百科全書 GDB-維基百科，自由的百科全書 什麼？！你還是不懂？ 你不會 GOOGLE 一下嗎5.png \" 你不會 GOOGLE 一下嗎 ","date":"2019-04-20","objectID":"/archlinux_vscode_build_gdb_gcc/:4:3","tags":["ArchLinux","VScode","C","C++","GCC","GDB"],"title":"在 Archlinux 搭建 VScode C/C++ 開發環境（GCC）及 調試（GDB）","uri":"/archlinux_vscode_build_gdb_gcc/"},{"categories":["ArchLinux"],"content":"安裝 VScode 插件 ","date":"2019-04-20","objectID":"/archlinux_vscode_build_gdb_gcc/:5:0","tags":["ArchLinux","VScode","C","C++","GCC","GDB"],"title":"在 Archlinux 搭建 VScode C/C++ 開發環境（GCC）及 調試（GDB）","uri":"/archlinux_vscode_build_gdb_gcc/"},{"categories":["ArchLinux"],"content":"安裝自己使用的語言並 Reload 在插件搜尋處搜尋自己要的語言，像肥宅我是用繁體中文，所以只要在搜尋處打上 traditional 就會出現安裝插件，按下 Install，並等它裝好 Reload就會切換到自己想要的語言界面，如果你想裝的是簡體中文，可以輸入 simplified，其實你只要輸入 Chinese 的 ch 基本繁體簡體都會顯示出來。 語言插件6.png \" 語言插件 ","date":"2019-04-20","objectID":"/archlinux_vscode_build_gdb_gcc/:5:1","tags":["ArchLinux","VScode","C","C++","GCC","GDB"],"title":"在 Archlinux 搭建 VScode C/C++ 開發環境（GCC）及 調試（GDB）","uri":"/archlinux_vscode_build_gdb_gcc/"},{"categories":["ArchLinux"],"content":"安裝 C/C++ 插件 搜尋 C/C++ 並安裝 C/C++ 插件7.png \" C/C++ 插件 其餘插件推薦請參考 Visual Studio Code 推薦使用插件 ","date":"2019-04-20","objectID":"/archlinux_vscode_build_gdb_gcc/:5:2","tags":["ArchLinux","VScode","C","C++","GCC","GDB"],"title":"在 Archlinux 搭建 VScode C/C++ 開發環境（GCC）及 調試（GDB）","uri":"/archlinux_vscode_build_gdb_gcc/"},{"categories":["ArchLinux"],"content":"VScode 一些設定參考 點擊左下角滾輪中的設定，再點擊右上角的 {}，可進入 settings.json。 設定文件8.png \" 設定文件 ","date":"2019-04-20","objectID":"/archlinux_vscode_build_gdb_gcc/:6:0","tags":["ArchLinux","VScode","C","C++","GCC","GDB"],"title":"在 Archlinux 搭建 VScode C/C++ 開發環境（GCC）及 調試（GDB）","uri":"/archlinux_vscode_build_gdb_gcc/"},{"categories":["ArchLinux"],"content":"settings.json { \"workbench.colorTheme\": \"One Dark Pro\", \"workbench.iconTheme\": \"vscode-icons\", \"terminal.integrated.fontFamily\": \"Source Code Pro\", \"code-runner.runInTerminal\": true, \"code-runner.saveFileBeforeRun\": true, \"code-runner.clearPreviousOutput\": true, \"typescript.locale\": \"zh-TW\", \"code-runner.fileDirectoryAsCwd\": true, \"editor.fontLigatures\": true, \"editor.fontFamily\": \"'Droid Sans Mono', 'monospace', monospace, 'Droid Sans Fallback', 'Source Code Pro'\", \"terminal.integrated.rendererType\": \"canvas\", \"files.autoSave\": \"afterDelay\", \"editor.fontSize\": 16, \"C_Cpp.default.intelliSenseMode\": \"clang-x64\" } 註：肥宅有裝 code-runer 插件，所以設定中有這個 code-runner。這裡不需要各位去複製貼上，只是給大家參考肥宅用了那些主題與插件。像肥宅目前使用 One Dark Pro 佈置主題。 注意：第 5 行的設定很重要，因為當你裝完 code-runner 時預設是不能在終端機輸入，所以才將 code-runner.runInTerminal 參數設為 true ","date":"2019-04-20","objectID":"/archlinux_vscode_build_gdb_gcc/:6:1","tags":["ArchLinux","VScode","C","C++","GCC","GDB"],"title":"在 Archlinux 搭建 VScode C/C++ 開發環境（GCC）及 調試（GDB）","uri":"/archlinux_vscode_build_gdb_gcc/"},{"categories":["ArchLinux"],"content":"配置 GDB 調試 這時你的電腦已配置了 gcc g++ 的環境變數，但你並還沒將其 IDE 完全配好，如果沒配好會出現一些問題，像肥宅在寫 C 敲上 #include \u003cstdio.h\u003e 時底部會出現綠色的波浪線，因爲沒將頭文件 *.h 都載入，雖然不影響編譯執行，但總會覺得很礙眼，感覺有瑕疵，在這裡肥宅一次幫各位解決。 註：下圖為綠色波浪底線示意圖 綠色波浪底線9.png \" 綠色波浪底線 讓我們開始配置吧~ 註：建議各位將所有代碼集中在一個資料夾方便管理，並有序分類。 Code 分類10.png \" Code 分類 註：這裡使用的是 Dolphin 來檢視檔案，類似 Windows OS 的檔案總管，這裡就不介紹這個。 顯示隱藏的 file 和 directory11.png \" 顯示隱藏的 file 和 directory 註：資料夾名或檔案名開頭是 . 的話會隱藏的，e.g. .vscode .git ，必須開啟可以顯示的設定才能看到。 請於代碼根目錄（也就是你使用 VScode 打開的資料夾）先將隱藏的檔案可以顯示，這裡因爲是肥宅先配置好的所以才會看到 .vscode，請在這新建個資料夾，資料夾名叫 .vscode，並分別新建四個文件，分別是 註：像肥宅在 VScode 開啟的資料夾是 Study，所以肥宅在 Study 這個資料夾目錄中新增名為 .vscode 的資料夾，並進入此資料夾新建四個檔案 settings.json c_cpp_properties.json launch.json task.json 接著分別填入以下內容 ","date":"2019-04-20","objectID":"/archlinux_vscode_build_gdb_gcc/:7:0","tags":["ArchLinux","VScode","C","C++","GCC","GDB"],"title":"在 Archlinux 搭建 VScode C/C++ 開發環境（GCC）及 調試（GDB）","uri":"/archlinux_vscode_build_gdb_gcc/"},{"categories":["ArchLinux"],"content":"settings.json { \"files.defaultLanguage\": \"cpp\", // ctrl+N新建文件后默认的语言 \"editor.formatOnType\": true, // 输入时就进行格式化，默认触发字符较少，分号可以触发 \"editor.formatOnSave\": true, // 每次存檔時，自動執行自動排版功能 \"editor.snippetSuggestions\": \"top\", // snippets代码优先显示补全 \"code-runner.runInTerminal\": true, // 设置成false会在“输出”中输出，无法输入 \"code-runner.executorMap\": { \"c\": \"cd $dir \u0026\u0026 gcc $fileName -o $fileNameWithoutExt \u0026\u0026 $dir$fileNameWithoutExt.out\", \"cpp\": \"cd $dir \u0026\u0026 g++ $fileName -o $fileNameWithoutExt \u0026\u0026 $dir$fileNameWithoutExt.out\" }, // 设置code runner的命令行 \"code-runner.saveFileBeforeRun\": true, // run code前保存 \"code-runner.preserveFocus\": true, // 若为false，run code后光标会聚焦到终端上。如果需要频繁输入数据可设为false \"code-runner.clearPreviousOutput\": false, // 每次run code前清空属于code runner的终端消息 \"C_Cpp.clang_format_sortIncludes\": true, // 格式化时调整include的顺序（按字母排序） \"C_Cpp.intelliSenseEngine\": \"Default\", // 可以为Default或Tag Parser，后者较老，功能较简单。具体差别参考cpptools扩展文档 } 註：在 Linux 中輸出檔的副檔名是 *.out，有別於 Windows 的 *.exe 注意：第八行與第九行的是 code-runner 插件的編譯執行命令行，因為是在 Linux 下編譯執行，所以肥宅在後面 fileNameWithoutExt 變數後面從 .exe 改成 .out，這樣在使用 code-runner 插件時幫你自動生成的輸出檔副檔名是 *.out ","date":"2019-04-20","objectID":"/archlinux_vscode_build_gdb_gcc/:7:1","tags":["ArchLinux","VScode","C","C++","GCC","GDB"],"title":"在 Archlinux 搭建 VScode C/C++ 開發環境（GCC）及 調試（GDB）","uri":"/archlinux_vscode_build_gdb_gcc/"},{"categories":["ArchLinux"],"content":"c_cpp_properties.json { \"configurations\": [ { \"name\": \"Linux\", \"includePath\": [ \"${workspaceFolder}/**\", \"/usr/include\", \"/lib64/gcc/x86_64-pc-linux-gnu/8.2.1/include/\" ], \"cStandard\": \"c11\", \"cppStandard\": \"c++17\", \"intelliSenseMode\": \"gcc-x64\", \"defines\": [ \"_DEBUG\", \"UNICODE\", \"__GNUC__=7\", \"__cdecl=__attribute__((__cdecl__))\" ], \"browse\": { \"path\": [ \"${workspaceFolder}\", \"/usr/include\", \"/lib64/gcc/x86_64-pc-linux-gnu/8.2.1/include/\", \"/lib64/gcc/x86_64-pc-linux-gnu/8.2.1/include-fixed/\", \"/lib64/gcc/x86_64-pc-linux-gnu/8.2.1/install-tools/include/\" ], \"limitSymbolsToIncludedHeaders\": true, \"databaseFilename\": \"\" } } ], \"version\": 4 } 註：肥宅之前就是這裡沒配置好（第 5 行的 \"includePath\"）所以才會在 #include \u003cstdio.h\u003e 這行底部出現綠色波浪 注意：肥宅 GCC 的版本是 8.2.1，所以如果你的版本改跟我不一樣請修改成你的當前版本，這裡最重要的是路徑不能有錯。也許你的路徑可能跟我不一樣，這些都可以在 root 根目錄中找到，請自行尋找與修改。 ","date":"2019-04-20","objectID":"/archlinux_vscode_build_gdb_gcc/:7:2","tags":["ArchLinux","VScode","C","C++","GCC","GDB"],"title":"在 Archlinux 搭建 VScode C/C++ 開發環境（GCC）及 調試（GDB）","uri":"/archlinux_vscode_build_gdb_gcc/"},{"categories":["ArchLinux"],"content":"launch.json { // 使用 IntelliSense 以得知可用的屬性。 // 暫留以檢視現有屬性的描述。 // 如需詳細資訊，請瀏覽: https://go.microsoft.com/fwlink/?linkid=830387 \"version\": \"0.2.0\", \"configurations\": [ { \"name\": \"Run C\", \"type\": \"cppdbg\", \"request\": \"launch\", \"program\": \"${workspaceFolder}/${fileBasenameNoExtension}.out\", \"args\": [], \"stopAtEntry\": false, \"cwd\": \"${workspaceFolder}\", \"environment\": [], \"externalConsole\": false, \"MIMode\": \"gdb\", \"setupCommands\": [ { \"description\": \"Enable pretty-printing for gdb\", \"text\": \"-enable-pretty-printing\", \"ignoreFailures\": false } ], \"preLaunchTask\": \"build \u0026 run file C\" }, { \"name\": \"Run C++\", \"type\": \"cppdbg\", \"request\": \"launch\", \"program\": \"${workspaceFolder}/${fileBasenameNoExtension}.out\", \"args\": [], \"stopAtEntry\": false, \"cwd\": \"${workspaceFolder}\", \"environment\": [], \"externalConsole\": false, \"MIMode\": \"gdb\", \"setupCommands\": [ { \"description\": \"Enable pretty-printing for gdb\", \"text\": \"-enable-pretty-printing\", \"ignoreFailures\": false } ], \"preLaunchTask\": \"build \u0026 run file C++\" }, { \"name\": \"Debug C\", \"type\": \"cppdbg\", \"request\": \"launch\", \"program\": \"${workspaceFolder}/${fileBasenameNoExtension}.out\", \"args\": [], \"stopAtEntry\": false, \"cwd\": \"${workspaceFolder}\", \"environment\": [], \"externalConsole\": false, \"MIMode\": \"gdb\", \"setupCommands\": [ { \"description\": \"Enable pretty-printing for gdb\", \"text\": \"-enable-pretty-printing\", \"ignoreFailures\": false } ], \"preLaunchTask\": \"build \u0026 debug file C\" }, { \"name\": \"Debug C++\", \"type\": \"cppdbg\", \"request\": \"launch\", \"program\": \"${workspaceFolder}/${fileBasenameNoExtension}.out\", \"args\": [], \"stopAtEntry\": false, \"cwd\": \"${workspaceFolder}\", \"environment\": [], \"externalConsole\": false, \"MIMode\": \"gdb\", \"setupCommands\": [ { \"description\": \"Enable pretty-printing for gdb\", \"text\": \"-enable-pretty-printing\", \"ignoreFailures\": false } ], \"preLaunchTask\": \"build \u0026 debug file C++\" } ] } 註：在分 C/C++ 的配置時可以分開，一個是 gcc 一個是 g++，然而有些人直接全部都是用 g++ 編譯，這樣也可以，只是不能使用 gcc 去編譯 C++。由於肥宅有強迫症，所以分成四個部份。 **注意：這裡肥宅分了四個類型，分別是 Run C Run C++ Debug C Debug C++， 其中每一個 \"program\" （進行調試的程序路徑）參數都是 \"${workspaceFolder}/${fileBasenameNoExtension}.out\"， \"preLaunchTask\" 的值則是對應到 task.json 的 \"label\"，如果兩者對應的名稱出錯在調試時會出現找不到對應名稱的錯誤訊息，要你開啟 launch.json 重新設定。** ","date":"2019-04-20","objectID":"/archlinux_vscode_build_gdb_gcc/:7:3","tags":["ArchLinux","VScode","C","C++","GCC","GDB"],"title":"在 Archlinux 搭建 VScode C/C++ 開發環境（GCC）及 調試（GDB）","uri":"/archlinux_vscode_build_gdb_gcc/"},{"categories":["ArchLinux"],"content":"tasks.json { \"version\": \"2.0.0\", \"tasks\": [ { \"label\": \"build \u0026 debug file C\", \"type\": \"shell\", \"command\": \"gcc\", \"args\": [ \"-g\", \"${file}\", \"-o\", \"${fileBasenameNoExtension}.out\" ], \"group\": { \"kind\": \"build\", \"isDefault\": true } }, { \"label\": \"build \u0026 debug file C++\", \"type\": \"shell\", \"command\": \"g++\", \"args\": [ \"-g\", \"${file}\", \"-o\", \"${fileBasenameNoExtension}.out\" ], \"group\": { \"kind\": \"build\", \"isDefault\": true } }, { \"label\": \"build \u0026 run file C\", \"type\": \"shell\", \"command\": \"gcc\", \"args\": [ \"${file}\", \"-o\", \"${fileBasenameNoExtension}.out\" ], \"group\": { \"kind\": \"build\", \"isDefault\": true } }, { \"label\": \"build \u0026 run file C++\", \"type\": \"shell\", \"command\": \"g++\", \"args\": [ \"${file}\", \"-o\", \"${fileBasenameNoExtension}.out\" ], \"group\": { \"kind\": \"build\", \"isDefault\": true } } ] } 註：-g 是調試的意思，-o 是輸出的意思。 注意：每個 \"args\" 參數中的 \"${fileBasenameNoExtension}.out\" 要特別注意尾端改成.out。 ","date":"2019-04-20","objectID":"/archlinux_vscode_build_gdb_gcc/:7:4","tags":["ArchLinux","VScode","C","C++","GCC","GDB"],"title":"在 Archlinux 搭建 VScode C/C++ 開發環境（GCC）及 調試（GDB）","uri":"/archlinux_vscode_build_gdb_gcc/"},{"categories":["ArchLinux"],"content":"調試畫面 配置完後，你可以在調試欄看到 Run C Run C++ Debug C Debug C++ 選項。 肥宅現在要調試 1.c 這個檔案，可以在代碼中設置斷點，並選擇 Debug C。 設置斷點12.png \" 設置斷點 註：調試快捷鍵 F5 調試13.png \" 調試 左側可以看到變數的值 註：肥宅已在 launch.json 中設定 \"externalConsole\": false，因爲這個設定的意思是使格外彈出個 Konsole，這功能只能在 Windows OS 中改成 true ","date":"2019-04-20","objectID":"/archlinux_vscode_build_gdb_gcc/:8:0","tags":["ArchLinux","VScode","C","C++","GCC","GDB"],"title":"在 Archlinux 搭建 VScode C/C++ 開發環境（GCC）及 調試（GDB）","uri":"/archlinux_vscode_build_gdb_gcc/"},{"categories":["ArchLinux"],"content":"純手工編譯執行 假設有個檔名叫 1，副檔名可以是 *.c 或 *.cpp ","date":"2019-04-20","objectID":"/archlinux_vscode_build_gdb_gcc/:9:0","tags":["ArchLinux","VScode","C","C++","GCC","GDB"],"title":"在 Archlinux 搭建 VScode C/C++ 開發環境（GCC）及 調試（GDB）","uri":"/archlinux_vscode_build_gdb_gcc/"},{"categories":["ArchLinux"],"content":"C 編譯標準 C99 gcc -std=c99 1.c -o 1.out 執行 ./1.out ","date":"2019-04-20","objectID":"/archlinux_vscode_build_gdb_gcc/:9:1","tags":["ArchLinux","VScode","C","C++","GCC","GDB"],"title":"在 Archlinux 搭建 VScode C/C++ 開發環境（GCC）及 調試（GDB）","uri":"/archlinux_vscode_build_gdb_gcc/"},{"categories":["ArchLinux"],"content":"C++ 編譯標準 C++11 g++ -std=c++11 1.cpp -o 1.out 執行 ./1.out ","date":"2019-04-20","objectID":"/archlinux_vscode_build_gdb_gcc/:9:2","tags":["ArchLinux","VScode","C","C++","GCC","GDB"],"title":"在 Archlinux 搭建 VScode C/C++ 開發環境（GCC）及 調試（GDB）","uri":"/archlinux_vscode_build_gdb_gcc/"},{"categories":["ArchLinux"],"content":"如果有引入其他自定義的標頭檔之實現檔 編譯時加入參數 e.g. 我有 main.c 且引入自定義的 Circle.h 標頭檔，並且將 Circle.h 標頭檔的實現部份寫在 Circle.cpp 編譯 gcc -std=c99 main.c Circle.cpp -o main.out 執行 ./main.out ","date":"2019-04-20","objectID":"/archlinux_vscode_build_gdb_gcc/:9:3","tags":["ArchLinux","VScode","C","C++","GCC","GDB"],"title":"在 Archlinux 搭建 VScode C/C++ 開發環境（GCC）及 調試（GDB）","uri":"/archlinux_vscode_build_gdb_gcc/"},{"categories":null,"content":" I am a college student studying at Central South University (CSU) in China. I love programming programs, and I hope that I can find myself by programming. I also like to watch Japanese animation. My favorite music is the theme song of PSYCHO-PASS, 名前のない怪物. My hometown is in Taipei, Taiwan. ","date":"2019-04-19","objectID":"/about/:0:0","tags":null,"title":"關於 Huang Po-Hsun","uri":"/about/"},{"categories":null,"content":"My Skill C/C++, Java, Python, Golang, Js, Front end design, Vue, React, Angular, Qt, Flask, Markdown, LaTeX, ArchLinux, MySQL etc. ","date":"2019-04-19","objectID":"/about/:1:0","tags":null,"title":"關於 Huang Po-Hsun","uri":"/about/"},{"categories":null,"content":"Contact Telegram : @HuangNO1 E-mail : fh831.cp9gw@gmail.com ","date":"2019-04-19","objectID":"/about/:2:0","tags":null,"title":"關於 Huang Po-Hsun","uri":"/about/"}]